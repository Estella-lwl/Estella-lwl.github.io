<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>polariis</title>
  
  <subtitle>where&#39;s my code?</subtitle>
  <link href="https://polariis.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://polariis.gitee.io/"/>
  <updated>2022-09-24T05:29:02.908Z</updated>
  <id>https://polariis.gitee.io/</id>
  
  <author>
    <name>polariis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3语法变更总结</title>
    <link href="https://polariis.gitee.io/posts/c33d6177/"/>
    <id>https://polariis.gitee.io/posts/c33d6177/</id>
    <published>2022-09-24T05:24:21.300Z</published>
    <updated>2022-09-24T05:29:02.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生命周期的变更"><a href="#1-生命周期的变更" class="headerlink" title="1.生命周期的变更"></a>1.生命周期的变更</h2><ul><li><p>销毁的概念改为<strong>卸载</strong>，更名：</p><ul><li>beforeDestroy改名为<span style="background-color: #f2f4f5;color: darkblue;">beforeUnmounted</span>。</li><li>destroyed改名为<span style="background-color: #f2f4f5;color: darkblue;">unmounted</span>。</li></ul></li><li><p>vue2中的两次判断改为一次（如图）。</p><p><img src="https://s2.loli.net/2022/08/10/9kmtAb8YxeMSqQV.png" alt="image-20220810114820457"></p></li><li><p>Vue3提供的**<span style="color: #0089FB;">Composition API</span>**形式对比：</p><ul><li>beforeCreate     =&gt;     <span style="color: #E95200;">setup()</span></li><li>created     =&gt;     <span style="color: #E95200;">setup()</span></li><li>beforeMount     =&gt;     <span style="color: #E95200;">onBeforeMount</span></li><li>mounted         =&gt;     <span style="color: #E95200;">onMounted</span></li><li>beforeUpdate      =&gt;     <span style="color: #E95200;">onBeforeUpdate</span></li><li>updated         =&gt;     <span style="color: #E95200;">onUpdated</span></li><li>beforeUnmounted     =&gt;     <span style="color: #E95200;">onBeforeUnmounted</span></li><li>unmounted     =&gt;     <span style="color: #E95200;">onUnmounted</span></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p><ul><li>下图打印结果可以看到：setup中的<span style="color: #FFB700;">组合式API优先级更高</span>。</li></ul><img src="https://s2.loli.net/2022/08/10/c82bMyzlovfEU9j.png" style="zoom:80%;" /></li></ul><hr><h2 id="2-setup函数"><a href="#2-setup函数" class="headerlink" title="2. setup函数"></a>2. setup函数</h2><h3 id="2-1-setup的两个注意点："><a href="#2-1-setup的两个注意点：" class="headerlink" title="2.1 setup的两个注意点："></a>2.1 setup的两个注意点：</h3><ul><li><p><strong>setup执行时机</strong>：</p><ul><li>在beforeCreated之前执行一次，并且this是undefined。</li></ul></li><li><p><strong>setup接收两个参数</strong>：</p><ul><li><p>1.**<span style="color: #0089FB;">props</span>**：值为对象。包含：组件外部传递进来，且在组件内部声明接收了的属性。</p><ul><li>当子组件传了，父组件却没接收/接收少了，都会控制台警告。接收多了则会拿到undefined。</li></ul></li><li><ol start="2"><li><p>**<span style="color: #0089FB;">context</span>**：<span style="background-color: #E9E9E9;color: #0089FB;">上下文对象</span></p><ul><li><p>**<span style="color: #E95200;">attrs</span>**：值为对象。包含：组件外部传递过来但没有在props配置中生命的属性，相当于this.$attrs。</p></li><li><p>**<span style="color: #E95200;">slots</span>**：收到的插槽内容，相当于this.$slots。</p></li><li><p>**<span style="color: #E95200;">emit</span>**：分发自定义事件的函数，相当于this.$emit。</p></li></ul></li></ol></li></ul></li></ul><h3 id="2-2-setup语法糖"><a href="#2-2-setup语法糖" class="headerlink" title="2.2 setup语法糖"></a>2.2 setup语法糖</h3><ul><li> <span style="color: #E95200;"><code>&lt;script setup&gt;</code></span>是单文件组件使用组合式API（上面笔记代码中）的语法糖。里面的代码会被编译为setup函数的内容。</li><li>无需export default，里面也不用return。</li><li>官方文档描述：<a href="https://staging-cn.vuejs.org/guide/introduction.html#api-styles">https://staging-cn.vuejs.org/guide/introduction.html#api-styles</a></li></ul><p><strong>什么时候使用</strong><span style="color: #E95200;"><code>setup()</code></span>：</p><p><img src="https://s2.loli.net/2022/08/18/LVO2ayMNCs3rB5p.png" alt="image-20220818121239514"></p><hr><h3 id="2-3-其他补充"><a href="#2-3-其他补充" class="headerlink" title="2.3 其他补充"></a>2.3 其他补充</h3><h4 id="1-vue3中插槽的使用变更："><a href="#1-vue3中插槽的使用变更：" class="headerlink" title="1. vue3中插槽的使用变更："></a>1. vue3中插槽的使用变更：</h4><ul><li>在vue3中使用插槽尽量用<code>v-slot</code>。</li><li>vue2中template里使用插槽可以使用：1. <code>name=&quot;xxx&quot;</code>  2. <code>v-slot=&quot;xxx&quot;</code>  。但由于vue3的兼容问题，使用第一种方法依旧显示的是默认插槽，自定义插槽名会失效。</li></ul><h4 id="2-vue3中props接收数据："><a href="#2-vue3中props接收数据：" class="headerlink" title="2. vue3中props接收数据："></a>2. vue3中props接收数据：</h4><p><strong>vue2中props接收数据</strong>：</p><ul><li>如果不用props，在VC的实例对象中也能拿到，通过<code>this.$attrs</code>；但如果使用props后，attrs中的数据就会消失（attrs就像捡漏）。</li></ul><hr><h2 id="3-Ref"><a href="#3-Ref" class="headerlink" title="3. Ref"></a>3. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：<code>const xxx = ref(initValue)</code>  </p><ul><li>创建一个包含响应式数据的<span style="color: #ff0001;">引用对象（reference对象）</span>。</li><li>模板中使用引用对象不用后面加.value，而<span style="color: #CC0000;">setup中使用该值时需要加.value</span>。</li></ul></li><li><p><strong>接收的数据</strong>：</p><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">基本类型： 响应式</span></strong><span style="background-color: #f2f4f5;color: darkblue;">依旧使用是<strong>defineProperty</strong></span> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">对象类型</span></strong><span style="background-color: #f2f4f5;color: darkblue;">时使用<strong>proxy</strong>实现的</span>（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要<span style="color: #FFB700;"> .value</span> 是因为<span style="color: #FFB700;">Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化</span>。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p>**<span style="color: darkblue;">注意：</span><strong>如果要在setup中拿到DOM元素，声明的变量名<span style="color: #ff0001;">必须与元素中写的ref</span></strong><span style="color: #CC0000;">一致</span>**。</p><pre><code>&lt;template&gt;  &lt;div id=&quot;countBox&quot; ref=&quot;countupRef&quot;&gt;    &lt;span class=&quot;countSpan&quot;&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p>在**<span style="background-color: #f2f4f5;color: darkblue;">onMounted</span>**中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="4-reactive"><a href="#4-reactive" class="headerlink" title="4. reactive"></a>4. reactive</h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：<code>const 代理对象 = reactive(源对象);</code>  接收一个对象或数组，返回一个**<span style="color: #CC0000;">代理对象</span>**<span style="color: #ff0001;">（Proxy的实例对象，简称proxy对象）</span>。</p><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul><p><img src="https://s2.loli.net/2022/08/18/UschZL52Pi7kz81.png" alt="image.png"></p></li><li><p>reactive定义的响应式数据是”深层次的“。</p></li><li><p>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</p></li></ul><h2 id="5-ref对比reactive总结"><a href="#5-ref对比reactive总结" class="headerlink" title="5. ref对比reactive总结"></a><strong>5. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p><ul><li>ref定义：<span style="color: #ff0001;">基本类型数据</span>。</li><li>reactive定义：<span style="color: #ff0001;">对象/数组类型数据</span>。</li><li><span style="color: #0089FB;">注意</span>：ref也可以定义对象/数组类型数据，它内部会自动通过<code>reactive</code><span style="color: #ff0001;">转为代理对象</span>。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p><ul><li>ref：通过<span style="color: #CC0000;"><code>Object.defineProperty()</code></span>的<code>get</code>和<code>set</code>实现响应式（数据劫持）。</li><li>reactive：通过使用<span style="color: #CC0000;"><code>Proxy</code></span>实现响应式（数据劫持），并通过<span style="color: #CC0000;"><code>Reflect</code></span>操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p><ul><li>ref定义的数据：操作数据<span style="color: #CC0000;">需要</span>.value，读取数据时模板会直接读取<span style="color: #CC0000;">不用</span><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据<span style="color: #CC0000;">均不需要</span><code>.value</code>。</li></ul></li></ul><h2 id="6-Vue2-amp-Vue3响应式原理对比"><a href="#6-Vue2-amp-Vue3响应式原理对比" class="headerlink" title="6. Vue2&amp;Vue3响应式原理对比"></a><strong>6. Vue2&amp;Vue3响应式原理对比</strong></h2><h3 id="6-1-Vue2的响应式"><a href="#6-1-Vue2的响应式" class="headerlink" title="6.1 Vue2的响应式"></a>6.1 Vue2的响应式</h3><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</li><li><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。<ul><li>比如：调用push方法，其实调用的是vue2二次封装后的push。</li><li>这个push里做了两件事：<ul><li>1.帮助正常调用push方法。</li><li>2.帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre> <img src="https://s2.loli.net/2022/08/18/KywkVsvl6uzL3CS.png" alt="image.png" style="zoom: 67%;" /></li><li><p><strong>Object.defineProperty</strong>:</p><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="6-2-Vue3的响应式"><a href="#6-2-Vue3的响应式" class="headerlink" title="6.2 Vue3的响应式"></a><strong>6.2 Vue3的响应式</strong></h3><h4 id="6-2-1实现原理："><a href="#6-2-1实现原理：" class="headerlink" title="6.2.1实现原理："></a><strong>6.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p><ul><li><strong>Proxy</strong>： window上内置的，接收<strong>两个参数</strong>（<span style="color: #FFB700;">必填</span>）：<strong>1</strong>. target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的**<span style="color: #ff0001;">reflect</span>**。）</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><img src="https://s2.loli.net/2022/08/18/CiEjvBrpIYJAsm5.png" alt="image.png" style="zoom: 67%;" /><h4 id="6-2-2-响应式中Reflect的应用："><a href="#6-2-2-响应式中Reflect的应用：" class="headerlink" title="6.2.2. 响应式中Reflect的应用："></a>6.2.2. 响应式中<span style="color: #ff0001;">Reflect</span>的应用：</h4><ul><li><p><strong>ES6</strong>，**<span style="color: #0089FB;">Windows内置</span>**。</p></li><li><p>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</p></li><li><p>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</p></li></ul><p><strong>与Object.definProperty<span style="color: #CC0000;">对比</span>：</strong></p><ul><li><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></li><li><strong>模Vue3中实现响应式</strong>（使用<strong>reflect</strong><span style="color: #ff0001;">改进后</span>）：<ul><li>用到了proxy代理对象，及reflect反射对象。</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre><hr><h2 id="7-toRef-amp-toRefs"><a href="#7-toRef-amp-toRefs" class="headerlink" title="7. toRef &amp; toRefs"></a>7. toRef &amp; toRefs</h2><h3 id="1-toRef"><a href="#1-toRef" class="headerlink" title="1. toRef"></a>1. toRef</h3><ul><li><p><strong>作用</strong>：创建个ref对象，其value的值指向另一个对象的某个属性。</p></li><li><p><strong>应用</strong>：要将响应式对象中的某个</p></li><li><p><strong>参数</strong>：1.目标对象；2.属性名。</p><ul><li><strong>举例</strong>：</li></ul><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre></li><li><p>和ref的区别：</p></li></ul><p>​    <strong>对比</strong>：</p><pre><code>let person = reactive(&#123;    name: &#39;&#39;,    hobby: &#123;        food: &#39;&#39;        &#125;&#125;)// 这里拿到的只是一个属性值：const name = person.name;console.log(&#39;name&#39;, name)// 使用toRef：const name2 = toRef(person, &#39;name&#39;);// 此时name不再是一个值，而是包在ref对象里的属性。console.log(&#39;name2&#39;, name2)</code></pre><p>如果要在setup函数return中：</p><p><strong>注意</strong>：这里return中ref也可以但ref生成的是新的数据，但使用toRef数据依旧是保持联系的。这是<strong>两者的区别</strong>。</p><pre><code>return &#123;    name: toRef(person, &#39;name&#39;);    food: toRef(person.hobby, &#39;food&#39;)&#125;</code></pre><p>当setup中的数据，return一个对象类型数据后，模板中每次使用都需要对象.xxxx。当在return时就写好对象.xxxx的话，会出现一种情况：数据不再是响应式。</p><p><strong>举例验证一下原因</strong>：</p><p>相当于：最后一行name是另外新定义的，和<code>p.name</code>没任何关联，所以响应式会没了。</p><img src="https://s2.loli.net/2022/08/18/ifGqWZsKODSmjhy.png" alt="image.png" style="zoom: 67%;" /><h3 id="2-toRefs"><a href="#2-toRefs" class="headerlink" title="2. toRefs"></a>2. toRefs</h3><ul><li><strong>作用</strong>：需要使用<span style="color: #0089FB;">多个toRef</span>时，可以用toRefs简写。</li><li><strong>使用</strong>：只需给一个参数。无需重复给多个属性写toRef。</li><li><strong>语法</strong>：toRefs(obj)</li></ul><p><strong>注意</strong>：</p><ul><li>return的时候不能直接就用，return的是对象，而toRefs返回的也是对象，直接写会报错。</li><li>按照这种格式（<span style="color: #FFB700;"><strong>…obj</strong></span>）：</li></ul><pre><code>return &#123;    // 这样数据的格式才正确：    ...toRefs(person)&#125;</code></pre><hr><h2 id="8-computed、watch与watchEffect"><a href="#8-computed、watch与watchEffect" class="headerlink" title="8. computed、watch与watchEffect"></a>8. computed、watch与watchEffect</h2><h3 id="1-computed"><a href="#1-computed" class="headerlink" title="1. computed"></a>1. computed</h3><ul><li>与vue2中computed配置功能一致。</li><li>写法：</li></ul><pre><code>import &#123; computed &#125; from &#39;vue&#39;;...    // vue3中computed与vue2语法一样：    let personObj = computed(&#123;      name: &#39;a&#39;,      age: 22    &#125;);</code></pre><p>完整：</p><img src="https://s2.loli.net/2022/08/18/O5n2zmlfTRqIHN1.png" alt="image.png" style="zoom:50%;" /><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2. watch函数"></a>2. watch函数</h3><ul><li>与vue2中配置功能一致。</li><li>两个小坑：<ul><li>监视<code>reactive</code>定义的响应式数据时：<span style="color: #CC0000;">oldValue无法正确获取；强制开启了深度监视（deep配置失效）</span>。</li><li>监视<code>reactive</code>定义的响应式数据中的<strong>某个属性</strong>时：<span style="color: #CC0000;">deep配置有效</span>。</li></ul></li></ul><h4 id="2-1-vue3中watch的变化："><a href="#2-1-vue3中watch的变化：" class="headerlink" title="2.1 vue3中watch的变化："></a>2.1 vue3中watch的变化：</h4><ul><li><p>watch能传递<strong>3个参数</strong>：</p><ul><li>监视谁：字符串/数组。</li><li>监视的回调：函数。</li><li>配置项：对象。</li></ul></li><li><p>监视reactive所定义的数据时，默认开启deep深度监视。且修改无效。</p></li><li><p><strong>immediate配置项</strong>的使用：</p><ul><li>情况1&amp;2中，配置有效。</li></ul></li><li><p><strong>deep配置项</strong>的使用：</p><ul><li>当监视的数据由<code>reactive</code><strong>直接管理时</strong>，<strong>deep默认开启</strong>。</li><li>当嵌套层级较深，则需<strong>手动配置</strong>开启。</li></ul></li><li><p><strong>获取不到oldValue</strong>的情况：可以总结为当是复杂数据类型时就获取不到。</p></li></ul><h4 id="2-2-六种使用情况："><a href="#2-2-六种使用情况：" class="headerlink" title="2.2 六种使用情况："></a>2.2 六种使用情况：</h4><p><span style="color: #0089FB;">1. </span>监视<span style="color: #2742B2;">一个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">2. </span>监视<span style="color: #2742B2;">多个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">3. </span>监视<span style="color: #2742B2;">reactive定义的全部数据</span>                      <code>deep配置无效；oldValue无法获取</code></p><p><span style="color: #0089FB;">4. </span>监视<span style="color: #2742B2;">一个reactive</span>定义的数据中的属性         <code>监视的属性要写为函数形式；oldValue可获取</code></p><p><span style="color: #0089FB;">5. </span>监视<span style="color: #2742B2;">多个reactive</span>定义的数据中的属性             <code>监视的属性要写在数组里且每项都是函数；oldValue可获取</code></p><p><span style="color: #0089FB;">6. </span><strong>特殊的情况</strong>：监视<span style="color: #2742B2;">reactive定义的数据中的对象</span>属性     <code>对象嵌套对象所以deep配置有效；oldValue无法获取</code></p><p><strong>全部代码示例：</strong></p><pre><code>const num = ref(0);const msg = ref(&#39;hello&#39;);let obj = reactive(&#123;  name: &#39;&#39;,  age: 30,  hobby: &#123;    food: &#39;anything&#39;  &#125;&#125;);// 情况1. 当监视一个ref定义的数据时：watch(  num,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况2. 当监视多个ref定义的数据时：watch(  [num, msg],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况3. 当监视reactive定义的全部数据时：// 注意：//    1.此时无法拿到正确的oldValue。//    2.默认开启deep；且修改无效。watch(  obj.age,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况4. 当监视一个reactive定义的数据中的属性时：// 注意：当监视这种数据时，watch的第1个形参需要是一个函数，函数里要有返回值,监视谁就返回谁。// 这时oldValue正确。watch(  () =&gt; &#123;    return obj.age;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况5. 当监视多个reactive定义的数据中的属性时：// 注意：watch的第1个形参是一个数组，监视几个数据里面就包几个函数。// 这时oldValue正确。watch(  [    () =&gt; &#123;      return obj.name;    &#125;,    () =&gt; &#123;      return obj.age;    &#125;  ],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 特殊的情况6. 当监视reactive定义的数据中的对象属性时：// 注意：当监视这种数据时，watch的第1个形参是函数。// oldValue无法获取。watch(  () =&gt; &#123;    return obj.hobby;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);</code></pre><p><strong>注意：</strong></p><ul><li><p>使用watch监视基本数据类型时，别用<code>.value</code>，这样拿到的是一个属性真正的值而非属性。</p></li><li><p>但<span style="color: #E95200;">对象类型（ref定义时）</span>：要用<code>.value</code>才会被监测到。<strong>因为</strong><span style="color: #CC0000;">此时的value是由reactive函数生成的proxy实例对象</span>。</p><ul><li>除了上面的<code>.value</code>，还有一个办法：加配置项 <code>deep: true</code>; </li></ul></li></ul><hr><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3. watchEffect函数"></a>3. watchEffect函数</h3><ul><li><p>watchEffect也是一个监视函数，但它不用指明监视目标。<span style="color: #E95200;"><code>默认开启immediate: true</code></span>。</p></li><li><p><strong>参数</strong>：监视的回调</p></li><li><p><strong>作用</strong>：观察<span style="color: #E95200;">监视的回调中用到了谁</span>，智能的选择监视谁。<span style="color: #E95200;">可以监视深层级数据</span>。</p></li><li><p><strong>使用场景</strong>：不用再多次写watch函数然后按照不同数据的语法写。watchEffect会自动识别并监视。</p></li><li><p><code>watchEffect</code>有点像<code>computed</code>，具体**<span style="color: #CC0000;">区别</span>**：</p></li><li><p>1.**computed注重计算出来的<span style="color: #E95200;">值</span>**（回调函数的返回值），所以必须要有返回值。执行时机：初始化时；所依赖的数据发生变化时。</p></li><li><ol start="2"><li><strong>watchEffect要的是过程（使用了谁），不用返回值</strong>。watchEffect也是所依赖的数据发生变化时重新执行一次。</li></ol></li></ul><hr><h2 id="9-hook"><a href="#9-hook" class="headerlink" title="9. hook"></a>9. hook</h2><ul><li><p>本质是函数，把setup中使用的Composition API进行了封装。类似于vue2中的mixin。</p></li><li><p>自定义hook的优势：复用代码，让setup中的逻辑更清楚。</p></li><li><p>把该功能相关的数据、方法、生命周期钩子全都抽离出去。</p><ul><li>新建hook文件后，将以上内容都放在个函数里。</li></ul></li><li><p>ps：hook文件取名一般为useXxx。</p></li></ul><p><strong>使用示例</strong>：</p><ul><li><p>实现一个点击鼠标拿到坐标的功能：（完整代码在vue3-practice）</p><ul><li><strong>改为hook前</strong>：</li></ul><pre><code>&lt;script setup&gt;import &#123; reactive &#125; from &#39;@vue/reactivity&#39;;import &#123; onBeforeUnmount, onMounted &#125; from &#39;@vue/runtime-core&#39;;const position = reactive(&#123;  x: 0,  y: 0&#125;);// // 组件挂载后执行// onMounted(() =&gt; &#123;//   // 这种写法的问题：组件卸载前销毁该事件时无法操作：//   window.addEventListener(&#39;click&#39;, function (event) &#123;//     console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);//     // 数据为响应式：//     position.x = event.pageX;//     position.y = event.pageY;//   &#125;);// &#125;);// 基于以上问题，改为这样（将点击事件的回调拎出去）：onMounted(() =&gt; &#123;  // 事件回调写进来：  window.addEventListener(&#39;click&#39;, savePosition);&#125;);function savePosition(event) &#123;  console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);  // 数据为响应式：  position.x = event.pageX;  position.y = event.pageY;&#125;// 需要注意的是，当组件被卸载时该事件也该失效，所以要在卸载前另外处理下：onBeforeUnmount(() =&gt; &#123;  // 这里需要两个参数：1.移除的事件；2.移除的事件所对应的回调。  window.removeEventListener(&#39;click&#39;, savePosition);&#125;);&lt;/script&gt;</code></pre><ul><li><strong>hook写法</strong>：   以下代码全都可以抽出去</li></ul></li></ul><img src="https://s2.loli.net/2022/08/18/L9qoVb2UTGaZnHu.png" alt="image.png" style="zoom:80%;" /><p>usePosition文件中：</p><pre><code>import &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;;// 默认暴露可以不用起名，汇依据使用时起的名字。export default function () &#123;  const position = reactive(&#123;    x: 0,    y: 0  &#125;);  function savePosition(event) &#123;    position.x = event.pageX;    position.y = event.pageY;    console.log(&#39;FROM UseHook position: &#39;, position.x, position.y);  &#125;  onMounted(() =&gt; &#123;    window.addEventListener(&#39;click&#39;, savePosition);  &#125;);  onBeforeUnmount(() =&gt; &#123;    window.removeEventListener(&#39;click&#39;, savePosition);  &#125;);  // 是函数，所以需要给返回值：  // 将组件中需要的数据传出去：  return position;&#125;</code></pre><hr><h2 id="10-其它Composition-API"><a href="#10-其它Composition-API" class="headerlink" title="10. 其它Composition API"></a>10. 其它Composition API</h2><h3 id="1-shallowReactive和shallowRef"><a href="#1-shallowReactive和shallowRef" class="headerlink" title="1. shallowReactive和shallowRef"></a><strong>1.</strong> shallowReactive和shallowRef</h3><ul><li><p><strong>shallowReactive：</strong>只处理对象中第一层的响应式，里层的不管（浅响应式）。</p></li><li><p><strong>shallowRef：</strong></p><ul><li>只处理基本类型，和ref的使用效果无区别。</li><li>当用来处理对象类型时，不再去借助reactive处理，而是直接不管了。</li></ul></li><li><p><strong>使用时机</strong>：</p><ul><li>如果一个对象数据，嵌套层级多，但只是外层属性变化(为了提升性能)。   ==》<span style="color: #FFB700;">shallowReactive</span></li><li>如果一个对象类型数据，后续使用不会修改对象中的属性(修改会失效)，而是生成新的对象替换。   ==》<span style="color: #FFB700;">shallowRef</span></li><li><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4</a></li></ul></li></ul><h3 id="2-readOnly和shallowReadOnly"><a href="#2-readOnly和shallowReadOnly" class="headerlink" title="2. readOnly和shallowReadOnly"></a>2. readOnly和shallowReadOnly</h3><ul><li><strong>readOnly</strong>：让响应式数据变为只读状态（<span style="color: #FFB700;">深只读</span>）。</li><li><strong>shallowReadOnly</strong>：让响应式数据变为只读状态（浅只读，除第一层只读外，里层的还可以修改）。</li><li><strong>应用场景</strong>：让数据不被修改。</li></ul><h3 id="3-toRaw和markRaw"><a href="#3-toRaw和markRaw" class="headerlink" title="3. toRaw和markRaw"></a>3. toRaw和markRaw</h3><p>raw：原始的</p><ul><li><p><strong>toRaw</strong>：</p><ul><li><strong>作用</strong>：将<code>reactive</code>生成的响应式数据转为普通对象（ref不行）。</li><li><strong>使用场景</strong>：用于读取响应式对象对应的普通对象，使其所有操作都不会引起页面更新（数据会变但不响应式）。</li></ul></li><li><p><strong>markRaw</strong>：</p><ul><li><strong>作用</strong>：标记一个对象，使其之后不能再成为响应式对象。</li><li><strong>应用场景</strong>：（应用场景比<code>toRaw</code>广）<ul><li>1.不应该设为响应式的值，比如复杂的第三方类库等。</li><li>2.当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ul></li></ul></li></ul><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4. customRef"></a>4. customRef</h3><ul><li><strong>作用</strong>：创建一个自定义的ref，并跟踪其依赖项和更新触发进行显示控制。</li></ul><p><strong>使用示例</strong>：（完整代码在vue3-practice的useCustomRef中）</p><pre><code>import &#123; customRef &#125; from &#39;vue&#39;;// 使用customRef自定义一个ref：function myRef(initVal, delay) &#123;  // customRef接收两个参数：  return customRef((track, trigger) =&gt; &#123;    // 下面的返回是customRef规定的：    return &#123;      get() &#123;        console.log(&#39;正在读value：&#39;, initVal);        // 在return之前通知vue追踪数据        track();        return initVal;      &#125;,      set(newVal) &#123;        console.log(&#39;正在修改value：&#39;, newVal);        // // 只有把新值赋回给初始值的变量才能动态的变化起来：        // initVal = newVal;        // // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。        // trigger();        // 这离开了定时器会出现一个状况：当输入速度太快，等到了页面刷新时，部分被积压的输入被刷掉，页面上能看到输入在回退。        // 解决办法：先定义一个timer定时器，每次进来执行前先清除定时器。（参考js防抖的原理）        clearTimeout();        setTimeout(() =&gt; &#123;          // 只有把新值赋回给初始值的变量才能动态的变化起来：          initVal = newVal;          // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。          trigger();        &#125;, delay);      &#125;    &#125;;  &#125;);&#125;// 给myRef两个实参：1.initVal初始值；2.delay延迟执行的时间。let num = myRef(0, 500);console.log(&#39;myRef自定义的数据:&#39;, num);</code></pre><ul><li><p><strong>可以优化的地方</strong>：延迟执行的时间是写死的，可以写为动态改变的。（<strong>已改</strong>）</p><ul><li>实现：多传递一个变量（比如delay）。</li></ul></li><li><p>实参写在调用<code>myRef</code>时的<code>()</code>中。</p></li></ul><hr><h2 id="11-provide-amp-inject"><a href="#11-provide-amp-inject" class="headerlink" title="11. provide &amp; inject"></a>11. provide &amp; inject</h2><ul><li><p>provide和inject（注入）是一种组件间通信的方式。</p></li><li><p><strong>作用</strong>：实现祖孙组件间的通信。</p></li><li><p><strong>使用</strong>：父组件使用<span style="color: #FFB700;"><code>provide</code></span>提供数据，后代组件通过<span style="color: #FFB700;"><code>inject</code></span>接收使用数据。</p><ul><li>provide两个参数：1.给传递的数据起的名字；2.实参。</li><li>inject通过传递的参数名拿到真实数据。（如下代码块）</li></ul></li><li><p><strong>语法</strong>：</p></li></ul><pre><code>// 父组件中：let num = ref(0);provide(&#39;xxx&#39;, num)// 后代组件中接收：const xxx = inject(&#39;xxx&#39;);</code></pre><ul><li><strong>注意</strong>：所有后代组件都可以使用<code>inject</code>拿到数据，但一般用在祖孙之间传递。</li></ul><hr><h2 id="12-几个用于判断响应式数据的API"><a href="#12-几个用于判断响应式数据的API" class="headerlink" title="12. 几个用于判断响应式数据的API"></a>12. 几个用于判断响应式数据的API</h2><p><strong>几个常用的用来判断的API：</strong></p><ol><li><strong>isRef</strong>：检查一个值是否是一个<code>ref</code>对象。</li><li><strong>isReactive</strong>：检查一个对象是否是由<code>reactive</code>创建的响应式代理。</li><li><strong>isReadonly</strong>：检查一个对象是否由<code>readonly</code>创建的只读代理。</li><li><strong>isProxy</strong>：检查一个对象是否由<code>reactive或者readonly</code>方法创建的代理。</li></ol><p><strong>使用场景</strong>：判断一个数据是否经过某些api的修饰。</p><p><strong>需要注意的一点</strong>：</p><ul><li>当<code>isProxy</code>判断一个由~所定义的数据时，它也会返回true。</li><li>这是因为<code>readonly</code>属性不会改变原数据的形式。依旧是proxy代理，而非转为普通object对象。</li></ul><pre><code>let obj1 = reactive(&#123;    a: 1,    b: 2&#125;)let obj2 = readonly(obj)// 打印为true：console.log(isProxy(obj2));</code></pre><hr><h2 id="13-新的组件"><a href="#13-新的组件" class="headerlink" title="13. 新的组件"></a>13. 新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1. Fragment"></a>1. Fragment</h3><blockquote><p>Fragment：碎片</p></blockquote><ul><li>在<strong>vue2</strong>中：组件必须有个根标签。</li><li><strong>vue3</strong>中：无需根标签，内部已经将多个标签包在一个Fragment虚拟元素中。</li><li><strong>优势</strong>：减少标签层级嵌套，减小内存占用。</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2. Teleport"></a>2. Teleport</h3><blockquote><p>teleport：瞬间移动；传送；</p></blockquote><ul><li><strong>作用</strong>：将一段HTML结构移动到指定位置。</li><li>to属性用来指定位置。</li></ul><pre><code>&lt;teleport to=&quot;body/或任意其他位置&quot;&gt;    &lt;div&gt;&lt;/div&gt;&lt;teleport&gt;</code></pre><h3 id="3-Suspense-（试验阶段）"><a href="#3-Suspense-（试验阶段）" class="headerlink" title="3. Suspense （试验阶段）"></a>3. Suspense （试验阶段）</h3><blockquote><p>Suspense:悬念</p></blockquote><ul><li><p><strong>作用</strong>：异步引入组件。</p></li><li><p><span style="color: #FFB700;"><strong>静态</strong></span> <strong>&amp;</strong> <span style="color: #FFB700;"><strong>动态</strong></span><span style="color: #FFB700;">(异步)</span><strong>引入组件的对比</strong>：</p><ul><li><p>写法：</p><pre><code>// 静态引入：import child from &#39;./文件路径&#39;;</code></pre><pre><code>import &#123; defineAsnycComponent &#125; from &#39;vue&#39;;// 动态(异步)引入组件：// import在以前用作一个关键词，在这里用作一个函数。const child = defineAsnycComponent(()=&gt; import(&#39;./文件路径&#39;)))</code></pre></li><li><p><strong>静态引入</strong>：当网速慢的时候，造成几个组件都不显示都在等着。</p></li><li><p><strong>动态引入</strong>：</p></li></ul></li><li><p><strong>Suspense使用</strong>：Suspense组件标签中内置了两个插槽：</p><ul><li>1.要放入展示的组件；</li><li>2.组件未加载时loading状态的内容。</li><li><strong>注意</strong>：<span style="color: #FFB700;">插槽的名字不能换</span>。</li></ul></li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;  &lt;h3&gt;我是App组件&lt;/h3&gt;  &lt;Suspense&gt;    &lt;template v-slot:default&gt;      &lt;Child/&gt;    &lt;/template&gt;        &lt;template v-slot:fallback&gt;      &lt;h3&gt;加载中.....&lt;/h3&gt;    &lt;/template&gt;  &lt;/Suspense&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>PS</strong>：当组件用了异步引入时，setup可以是async函数。</p>   <img src="https://s2.loli.net/2022/08/18/gi8sOUXRAJlphVy.png" alt="image.png" style="zoom:67%;" /><hr><h2 id="14-vue3的其它调整"><a href="#14-vue3的其它调整" class="headerlink" title="14. vue3的其它调整"></a>14. vue3的其它调整</h2><h3 id="1-全局API的转移："><a href="#1-全局API的转移：" class="headerlink" title="1. 全局API的转移："></a>1. 全局API的转移：</h3><p><img src="https://s2.loli.net/2022/08/18/ksXfFxdm8Hr65nI.png" alt="image.png"></p><h3 id="2-其它："><a href="#2-其它：" class="headerlink" title="2. 其它："></a>2. 其它：</h3><ul><li>data始终应被声明为函数。</li><li>过渡类名的更改：</li></ul><p><img src="https://s2.loli.net/2022/08/18/arnC83f6p4hHLRN.png" alt="image.png"></p><ul><li><p>移除keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p>移除<code>v-on.native</code>修饰符</p></li><li><ul><li>父组件中绑定事件</li></ul></li></ul><pre><code> &lt;my-component   v-on:close=&quot;handleComponentEvent&quot;   v-on:click=&quot;handleNativeClickEvent&quot; /&gt;</code></pre><ul><li><ul><li>子组件中声明自定义事件</li></ul></li></ul><pre><code> &lt;script&gt;   export default &#123;     emits: [&#39;close&#39;]   &#125; &lt;/script&gt;</code></pre><ul><li>移除过滤器（filter）</li></ul><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote><ul><li><p>其余去看官方文档…</p></li><li><ul><li><a href="https://staging-cn.vuejs.org/api/application.html">https://staging-cn.vuejs.org/api/application.html</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-生命周期的变更&quot;&gt;&lt;a href=&quot;#1-生命周期的变更&quot; class=&quot;headerlink&quot; title=&quot;1.生命周期的变更&quot;&gt;&lt;/a&gt;1.生命周期的变更&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;销毁的概念改为&lt;strong&gt;卸载&lt;/strong&gt;，更名：&lt;/p</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>ref &amp; reactive &amp; 响应式差异</title>
    <link href="https://polariis.gitee.io/posts/9badfa3f/"/>
    <id>https://polariis.gitee.io/posts/9badfa3f/</id>
    <published>2022-08-09T19:47:33.983Z</published>
    <updated>2022-08-09T20:34:14.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：const xxx = ref(initValue)  </p></li><li><ul><li>创建一个包含响应式数据的引用对象（reference对象）。</li><li>模板中使用引用对象不用后面加.value，而setup中使用该值时需要加.value。</li></ul></li><li><p><strong>接收的数据</strong>：</p></li><li><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong>基本类型： 响应式</strong>依旧使用是<strong>defineProperty</strong> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong>对象类型</strong>时使用<strong>proxy</strong>实现的（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要 .value 是因为Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p><strong>注意</strong>：如果要在setup中拿到DOM元素，声明的变量名必须与元素中写的ref<strong>一致</strong>。</p></li></ul><p><template>  <div id="countBox" ref="countupRef">    <span class="countSpan"></span>  </div> </template></p><ul><li><p>在<strong>onMounted</strong>中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="2-reactive："><a href="#2-reactive：" class="headerlink" title="2. reactive："></a><strong>2. reactive：</strong></h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：const 代理对象 = reactive(源对象);  接收一个对象或数组，返回一个<strong>代理对象</strong>（Proxy的实例对象，简称proxy对象）。</p></li><li><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul></li></ul><p> <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035136457-16600746990031.png" alt="image-20220810035136457"></p><ul><li>reactive定义的响应式数据是”深层次的“。</li><li>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</li></ul><h2 id="3-ref对比reactive总结"><a href="#3-ref对比reactive总结" class="headerlink" title="3. ref对比reactive总结"></a><strong>3. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p></li><li><ul><li>ref定义：基本类型数据。</li><li>reactive定义：对象/数组类型数据。</li><li>注意：ref也可以定义对象/数组类型数据，它内部会自动通过reactive转为代理对象。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p></li><li><ul><li>ref：通过Object.defineProperty()的get和set实现响应式（数据劫持）。</li><li>reactive：通过使用Proxy实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p></li><li><ul><li>ref定义的数据：操作数据需要.value，读取数据时模板会直接读取不用.value。</li><li>reactive定义的数据：操作数据与读取数据均不需要.value。</li></ul></li></ul><h2 id="4-响应式原理对比"><a href="#4-响应式原理对比" class="headerlink" title="4. 响应式原理对比"></a><strong>4. 响应式原理对比</strong></h2><h2 id="4-1-Vue2的响应式"><a href="#4-1-Vue2的响应式" class="headerlink" title="4.1 Vue2的响应式"></a><strong>4.1 Vue2的响应式</strong></h2><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><p><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</p></li><li><p><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。</p></li><li><ul><li><p>比如：调用push方法，其实调用的是vue2二次封装后的push。</p></li><li><p>这个push里做了两件事：</p></li><li><ul><li>\1. 帮助正常调用push方法。</li><li>\2. 帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p></li><li><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul></li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035246493-16600747685122.png" alt="image-20220810035246493"></p><ul><li><p><strong>Object.defineProperty</strong>:</p></li><li><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="4-2-Vue3的响应式"><a href="#4-2-Vue3的响应式" class="headerlink" title="4.2 Vue3的响应式"></a><strong>4.2 Vue3的响应式</strong></h3><h4 id="4-2-1实现原理："><a href="#4-2-1实现原理：" class="headerlink" title="4.2.1实现原理："></a><strong>4.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p></li><li><ul><li><strong>Proxy</strong>：window上内置的，接收<strong>两个参数</strong>（必填）：<strong>1</strong>.target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p></li><li><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的<strong>reflect</strong>。）</li></ul></li></ul><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035353361-16600748348953.png" alt="image-20220810035353361"></p><h4 id="4-2-2-响应式中Reflect的应用："><a href="#4-2-2-响应式中Reflect的应用：" class="headerlink" title="4.2.2. 响应式中Reflect的应用："></a>4.2.2. 响应式中Reflect的应用：</h4><ul><li><strong>ES6</strong>，<strong>Windows内置</strong>。</li><li>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</li><li>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</li></ul><p><strong>与Object.definProperty<strong><strong>对比</strong></strong>：</strong></p><ul><li><p><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></p></li><li><p> <strong>模拟Vue3中实现响应式</strong>（使用<strong>reflect</strong>改进后）：</p></li><li><ul><li><p>用到了proxy代理对象，及reflect反射对象。</p><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre></li></ul></li></ul><hr><p><strong>toRef</strong></p><ul><li>toRef可以创建一个ref，其的value值可以指向令一个对象的属性。</li></ul><p><strong>举例</strong>：</p><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre><p><strong>toRefs</strong></p><p>指向多个</p><p><strong>toRefs</strong></p><p>指向多个属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Ref&quot;&gt;&lt;a href=&quot;#1-Ref&quot; class=&quot;headerlink&quot; title=&quot;1. Ref&quot;&gt;&lt;/a&gt;1. Ref&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：定义一个响应式的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>vue3生命周期的变更</title>
    <link href="https://polariis.gitee.io/posts/2606f5b3/"/>
    <id>https://polariis.gitee.io/posts/2606f5b3/</id>
    <published>2022-08-09T18:58:33.334Z</published>
    <updated>2022-08-09T20:29:30.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p>销毁的概念改为<strong>卸载</strong>（unmounted），更名：</p></li><li><ul><li>beforeDestroy改名为beforeUnmounted。</li><li>destroyed改名为unmounted。</li></ul></li><li><p>vue2中的两次判断改为一次。</p></li></ul><p>​    <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810030613459.png" alt="image-20220810030613459"></p><ul><li><p>Vue3提供的<strong>Composition API</strong>形式对比：</p></li><li><ul><li>beforeCreate     =&gt;     <strong>setup()</strong></li><li>created     =&gt;     <strong>setup()</strong></li><li>beforeMount     =&gt;     <strong>onBeforeMount</strong></li><li>mounted         =&gt;     <strong>onMounted</strong></li><li>beforeUpdate      =&gt;     <strong>onBeforeUpdate</strong></li><li>updated         =&gt;     <strong>onUpdated</strong></li><li>beforeUnmounted     =&gt;     <strong>onBeforeUnmounted</strong></li><li>unmounted     =&gt;     <strong>OnUnmounted</strong></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p></li><li><ul><li><p>下图打印结果可以看到：setup中的组合式API优先级更高。</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810034139355-16600741018631.png" alt="image-20220810034139355"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;销毁的概念改为&lt;strong&gt;卸载&lt;/strong&gt;（unmounted），更名：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;befo</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="vue3" scheme="https://polariis.gitee.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>JS小总结</title>
    <link href="https://polariis.gitee.io/posts/ac58b7ea/"/>
    <id>https://polariis.gitee.io/posts/ac58b7ea/</id>
    <published>2021-12-11T02:08:45.530Z</published>
    <updated>2022-08-09T18:50:15.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-函数："><a href="#1-函数：" class="headerlink" title="1. 函数："></a><strong>1. 函数：</strong></h2><ul><li>在实际开发中，经常会使用一个变量来接收函数返回的结果。</li><li>return 有终止函数的作用，return后的语句不会被执行。</li><li>return只能返回一个值。（有多个时返回最后一个）</li><li>所以当要return返回多个时，可以使用数组：</li></ul><p>return [num1+num2,num1*num2]</p><ul><li><p>函数都有返回值。若有，则返回return后的值；若没有，则返回undefined。</p></li><li><ul><li><strong>arguments的使用：</strong> ( 注意：只有函数才有arguments)</li><li>当不确定有多少个参数传递的时候，可以用arguments来获取。在JS中，arguments实际上是当前函数的一个内置对象。<strong>所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</strong></li></ul></li><li><p>arguments的展示形式是一个伪数组，因此可以进行遍历。</p></li><li><p>伪数组的特点：     （伪数组并不是真正意义上的数组）</p></li><li><ul><li>具有length属性；</li><li>按索引方式存储数据；</li><li>不具有数组的push，pop等方法。</li></ul></li><li><p>代码从上往下执行。当执行到调用某函数时，会去找执行部分的代码，如下面的 函数中调用另一个函数：</p></li></ul><pre><code>function fn1() &#123;    console.log(111)         /* 第1个执行 */    fn2()    console.log(&#39;fn1&#39;)       /* 第4个执行 */  &#125;  function fn2() &#123;    console.log(222)         /* 第2个执行 */    console.log(&#39;fn2&#39;)       /* 第3个执行 */  &#125;  fn1();                     /* 先找到这里 */   // 执行顺序： // 从上往下，fn1和fn2的代码块都未调用，所以这两个代码块都先不管。 // 所以1.先走到fn1(); =&gt;找到fn1代码块=&gt;执行并输出111。 // 2.又走到fn2()=&gt;所以去找fn2代码块=&gt;执行并输出222，fn2。 // 3.回去接着执行并输出fn1。</code></pre><h2 id="2-JS作用域："><a href="#2-JS作用域：" class="headerlink" title="2. JS作用域："></a><strong>2. JS作用域：</strong></h2><ul><li><p>就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突。</p></li><li><p>在ES6之前：全局作用域，局部作用域（也叫函数作用域）。两者就算名字一样也互不影响。</p></li><li><p>注意：函数的形参也可以看作局部变量。</p></li><li><p>从执行效率来说，</p></li><li><ul><li>全局变量：只有在浏览亲关闭的时候才会销毁。比较占内存资源。</li><li>局部变量：当程序执行完之后就会销毁。比较节约内存资源。</li></ul></li><li><p>块级作用域：ES6新增的，原本JS中没有块级作用域。</p></li><li><p><strong>作用域链：</strong>     （<strong>就近原则</strong>）</p></li><li><ul><li>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值。这种结构就叫作用域链。</li></ul></li></ul><h2 id="3-JS预解析："><a href="#3-JS预解析：" class="headerlink" title="3. JS预解析："></a><strong>3. JS预解析：</strong></h2><ul><li><p>JS引擎运行JS分为两步：预解析、代码执行。</p></li><li><p>预解析：JS引擎会把JS里所有的var和function提升到当前作用域的最前面。</p></li><li><ul><li>变量预解析（变量提升）：就是把所有的变量声明提升到<strong>当前</strong>作用域的最前面，<strong>不提升赋值操作</strong>。</li><li>函数预解析（函数提升）：就是把所有函数声明提升到当前作用域的最前面，不调用函数。<strong>只有函数声明形式才有函数提升。</strong></li><li><strong>函数提升优先级高于变量提升。</strong></li></ul></li></ul><pre><code>// 1.下面的输出结果是什么：  console.log(num);  var num = 10;  // 其实相当于下面的代码：  var num;  console.log(num);                   /* 所以undefined */  num = 10;</code></pre><pre><code> // 2.下面的输出结果是什么：  fun();  var fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)  &#125;  // 其实相当于下面的代码：  var fun;  fun();  fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)                 /* 所以报错 */  &#125;</code></pre><pre><code>// 3.为什么调用写在最前面也可以：  fn();  function fn() &#123;    console.log(11);         /* 因为函数提升，把函数声明提升到当前作用域的最前面。 */  &#125;// 例子1 ：  var num= 10  fun();  function fun() &#123;    console.log(num);    var num = 20;  &#125;  // 相当于执行下面的代码：  var num;                         /* 外层的变量提升 */  function fun() &#123;                 /* 外层的函数提升 */    var num;                       /* 里层的变量提升 */    console.log(num);               /* undefined，因为就近原则 */    num = 20;  &#125;  num = 10;  fun();</code></pre><pre><code>// 例子2 ：  var num = 10;  function fn() &#123;    console.log(num);    var num = 20;    console.log(num);  &#125;  fn();​  // 相当于执行下面的代码：  var num;  function fn() &#123;    var num;    console.log(num);                   /* undefined，就近原则 */    num = 20;    console.log(num);                   /* 20 */  &#125;  num = 10;  fn();</code></pre><pre><code>// 例子3 ：  var a = 18;  f1();  function f1() &#123;    var b = 9;    console.log(a);    console.log(b);    var a = &#39;123&#39;;  &#125;  // 相当于执行下面的代码：  var a;  function f1() &#123;    var b;    b = 9;    var a;    console.log(a);                     /* undefined */    console.log(b);                     /* 9 */    a = &#39;123&#39;;  &#125;  a = 18;  f1();</code></pre><pre><code>// 例子4 ：     这道题需要注意  f1();  console.log(c);  console.log(b);  console.log(a);  function f1() &#123;    // 这句相当于var a =9； b = 9；c = 9; 而不是var a;var b;var c;    // 所以b、c并没有声明!!! 要当全局看    var a = b = c = 9;                  console.log(a);    console.log(b);    console.log(c);  &#125;  // 相当于执行下面的代码：  function f1() &#123;    var a;      a = b = c = 9;      // var b;     不是这样，写错了。。。    // var c;    // a = 9;    // b = 9;    // c = 9;    var a;    console.log(a);                   /* 9 */    console.log(b);                   /* 9 */    console.log(c);                   /* 9 */  &#125;  f1();  console.log(c);                     /* 9 */  console.log(b);                     /* 9 */  console.log(a);                     /* undefined,局部变量 */</code></pre><ul><li>代码执行：按照代码顺序从上往下执行。</li></ul><h2 id="对象："><a href="#对象：" class="headerlink" title="对象："></a><strong>对象：</strong></h2><ul><li><p>在JS中，对象是一组无序的相关属性和方法的集合，所有事物都是对象，如数组、字符串、函数、数值。</p></li><li><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的。</p></li><li><p>属性：是事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示。（常用名词）</p></li><li><p>方法：是事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示。（常用动词）</p></li><li><p>为什么需要对象：</p></li><li><ul><li>保存一个值时，可以使用变量，保存多个值时，可以使用数组，如果要保存一个人的完整信息嘞~    </li></ul></li><li><p>现阶段可以用三种方式创建对象：</p></li><li><ul><li>字面量创建；</li><li>new Object创建对象；</li><li>利用构造函数创建对象。</li></ul></li></ul><h2 id="类class："><a href="#类class：" class="headerlink" title="类class："></a><strong>类class：</strong></h2><ul><li>在ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。</li><li><strong>类</strong>抽象了对象的公共部分，它泛指某一大类(class)。</li><li><strong>对象</strong>特指某一个，通过类实例化一个具体的对象。</li></ul><h3 id="1-创建类："><a href="#1-创建类：" class="headerlink" title="1.创建类："></a><strong>1.创建类：</strong></h3><p>语法：</p><pre><code>class name &#123;    //class body&#125;</code></pre><p>创建实例：</p><pre><code>var xx =  new name();</code></pre><p>注意：类必须使用new实例化对象。</p><h3 id="2-类-constructor-构造函数"><a href="#2-类-constructor-构造函数" class="headerlink" title="2.类 constructor 构造函数"></a><strong>2.类 constructor 构造函数</strong></h3><ul><li><strong>constructor()</strong> 方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显式定义，类的内部会自动创建一个constructor()。</li><li>有了它就不用return。</li></ul><p>例：</p><pre><code>// 1.创建类class，创建一个Star类。class name &#123;    constructor(uname) &#123;        // this指向创建的实例：        this.uname = uname;      /* 将uname指向创建的实例，这样就接收了这个参数 */        this.age = age;    &#125;    sing(song) &#123;        console.log(&#39;略略略&#39;);        console.log(this.name + song);    &#125;&#125;// 2.利用类创建对象 newvar zs = new Star(&#39;张三&#39;,18);   /* 只要加了new，就自动调用constructor。 */var ls = new Star(&#39;李四&#39;,20); console.log(zs);           /* 输出张三 */console.log(ls);zs.sing(&#39;lost river&#39;);zs.sing(&#39;///////&#39;);</code></pre><p><strong>注意点：</strong></p><ol><li>通过class关键字创建类，类名要大写。</li><li>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象。</li><li>constructor函数只要new生成实例时，就会自动调用这个函数，如果不写这个函数，类也会自动生成这个函数。</li><li>生成实例，new不能省略。</li><li>最后注意语法规范，<strong>创建类</strong>，类名后面不要加小括号，<strong>生成实例</strong>，类名后面要加小括号，构造函数不需要加function。</li></ol><p>另外：</p><ul><li>类里面所有的函数都不用写function来声明。</li><li>类里面，所有函数/方法之间不能加逗号分割。</li><li></li></ul><h3 id="3-类的继承："><a href="#3-类的继承：" class="headerlink" title="3. 类的继承："></a><strong>3. 类的继承：</strong></h3><p>下次更新写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-函数：&quot;&gt;&lt;a href=&quot;#1-函数：&quot; class=&quot;headerlink&quot; title=&quot;1. 函数：&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 函数：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在实际开发中，经常会使用一个变量来接收函数返回的结果。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="JS" scheme="https://polariis.gitee.io/categories/JS/"/>
    
    
    <category term="基础回顾" scheme="https://polariis.gitee.io/tags/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    
    <category term="JS" scheme="https://polariis.gitee.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://polariis.gitee.io/posts/3eeb/"/>
    <id>https://polariis.gitee.io/posts/3eeb/</id>
    <published>2021-12-11T02:08:45.522Z</published>
    <updated>2021-12-04T11:08:37.514Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Gitee搭建博客踩坑总结</title>
    <link href="https://polariis.gitee.io/posts/hexo-gitee/"/>
    <id>https://polariis.gitee.io/posts/hexo-gitee/</id>
    <published>2021-04-03T22:37:56.000Z</published>
    <updated>2021-12-04T11:08:37.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、搭建过程如下："><a href="#一、搭建过程如下：" class="headerlink" title="一、搭建过程如下："></a>一、搭建过程如下：</h2><h3 id="阶段1：-本地搭建"><a href="#阶段1：-本地搭建" class="headerlink" title="阶段1： 本地搭建"></a>阶段1： 本地搭建</h3><p>1.下载安装node.js </p><p>2.下载安装git </p><p>3.使用命令行(win+r,输入cmd)下载淘宝镜像：    </p><pre><code>npm install -g cnpm --registry=https://.npm.taobao.org</code></pre><p>4.使用命令行下载hexo :    （git bash和cmd都可以）</p><pre><code>npm install -g hexo-cli</code></pre><p>5.建立空文件夹 ：</p><pre><code>md blog</code></pre><p>6.进入建好的文件夹：</p><pre><code>cd blog </code></pre><p>7.启动服务：</p><pre><code>hexo s</code></pre><p>8.停一下：ctrl c再按y </p><p>9.新建文章： hexo n “标题” </p><p>10.看这时在哪个目录下，然后cd进入 </p><p>11.确认新建的文章是否成功：dir </p><p>12.给博文加内容：这里我用typora写。用vim的方法是：vim 标题.md。然后保存退出：先按esc，再输入    wq(w保存，q退出)。 </p><p>13.文件退两层： cd../.. (到了blog目录) </p><p>14.win下写博文从文件夹用typora打开文章，然后保存刷新页面，不用重新启动hexo。 </p><p>15.清理 :</p><pre><code>hexo clean </code></pre><p>16.生成:</p><pre><code>hexo g </code></pre><h3 id="阶段2：部署到Gitee"><a href="#阶段2：部署到Gitee" class="headerlink" title="阶段2：部署到Gitee"></a>阶段2：部署到Gitee</h3><p>1.装一个git的部署插件cnpm install –save hexo-deployer-git(win用npm install) </p><p>2.注册登录Gitee账号，新建仓库，设置仓库名（一定要和用户名一样，否则可能会有无法预料结果）。</p><p>3.设置根目录的_config.yml文件，用typore打开，拉到最底下设置deploy的值：</p><pre><code>deploy:  type: git  repo: 你的仓库地址（去Gitee复制）  branch: master</code></pre><p>注意冒号和值之间一定要有空格，type后面有单引号的话可以直接删了。</p><p>4.这样就随时可以用电脑/手机访问了，地址可以直接复制仓库名访问。接下来就是换主题和自定义主题为满意的样式，我用的是Matery，网上有很多，Hexo官网也有。</p><h2 id="二、需要注意的地方："><a href="#二、需要注意的地方：" class="headerlink" title="二、需要注意的地方："></a>二、需要注意的地方：</h2><p>1.主题名别忘了在_config.ym中更改，这种配置文件一定要严格按照格式！否则一言不合就报错！</p><p>2.下载的主题在解压缩后不要更改</p><p>3.注意有没有漏下的插件，检查所有插件及版本号的指令：</p><pre><code>npm list</code></pre><p>4.卸载某个插件的指令：</p><pre><code>npm uninstall 插件名@版本号</code></pre><p>5.怕出错想找回改动前的文件：可以提前复制粘贴一份在桌面，方便随时对照/改动。</p><p>6.Typora可以选择是否显示目录，设置toc: true，如果某篇文章不显示目录了，可以查看文章最上方的设置是否正确。</p><h2 id="三、踩坑-amp-解决："><a href="#三、踩坑-amp-解决：" class="headerlink" title="三、踩坑&amp;解决："></a>三、踩坑&amp;解决：</h2><p>1.报错：FATAL err:[Error: EBUSY: resource busy or locked, rmdir ‘C:\User...]</p><p>网上搜索了一下，关闭软件重启电脑，果然有奇效。</p><p>2.我的页面刚开始一直404，我百思不得其解，大佬们的各路招数试了个遍，然而它的纹丝不动仿佛在告诉我不要浪费时间。</p><p>最后！我在Gitee Page页面看到了一个更新的按钮，我一脸疑惑的点了一下。接着，大不一样，顿时体会到柳暗花明又一村天无绝人之路。没错，我想了一下，大概是因为我的git一键部署功能出错了。总之，现在是记了，    每次终端部署完之后，在这个页面再点更新就好了。</p><p>3.我发现我的主题，在设置成功之后无法在网站中更新，在尝试了很多方法之后，我发现把根目录的config yml文件的repo由SSH的地址变换为HTTPS的位置，这样就可以成功解决，不过还有一个问题就是这样的话，每次重新部署都要输入用户名和密码。</p><p>然后我就尝试在网上搜集一些办法，但是没有什么用。这时我就想，如果我把repo. 再换成SSH的地址。这样换了之后我看会有什么变化变化，结果发现。重新部署之后是可以的，页面刷新也没有完全问题。</p><p>4.我在所选的主题下找到了read me，开始按照里面的提示来配置我的主题文件夹。其中有一个是配置评论的表情的。我在配置过后发现你发现在本地运行的时候都会报错，后来在网上查找，提示说检查Jason文件格式，一般情况下，他都是一对花括号是首尾。后来我把最上面那行Json删了也把最外层的中括号删了。结果发现依旧报    错，接着我又尝试把中括号加上，运行一下再也没有红色字段，就Json这四个字母导致了运行报错。</p><p>​    5.修改根目录配置文件时，注意缩进，有报错的情况！</p><p>​    6.卸载了<a href="mailto:&#x68;&#105;&#x67;&#104;&#x6c;&#105;&#103;&#x68;&#116;&#x2e;&#x6a;&#115;&#x40;&#49;&#x30;&#46;&#x37;&#x2e;&#49;">&#x68;&#105;&#x67;&#104;&#x6c;&#105;&#103;&#x68;&#116;&#x2e;&#x6a;&#115;&#x40;&#49;&#x30;&#46;&#x37;&#x2e;&#49;</a>：npm uninstall <a href="mailto:&#104;&#x65;&#x78;&#x6f;&#x2d;&#x71;&#x69;&#x6e;&#x69;&#117;&#45;&#x73;&#121;&#110;&#99;&#x40;&#x31;&#x2e;&#52;&#x2e;&#x37;">&#104;&#x65;&#x78;&#x6f;&#x2d;&#x71;&#x69;&#x6e;&#x69;&#117;&#45;&#x73;&#121;&#110;&#99;&#x40;&#x31;&#x2e;&#52;&#x2e;&#x37;</a> （相关的配置我暂时未删，试了一下已    经好了）</p><p>​    7.设置文章永久链接，下载指令：</p><pre><code>npm install hexo-abbrlink --save</code></pre><p>​    设置修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）:</p><pre><code>#设置永久链接permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlinkabbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: dec     #进制： dec(default) and hex</code></pre><p>​    8.npm resource busy or locked报错解决：</p><pre><code>npm cache verify</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、搭建过程如下：&quot;&gt;&lt;a href=&quot;#一、搭建过程如下：&quot; class=&quot;headerlink&quot; title=&quot;一、搭建过程如下：&quot;&gt;&lt;/a&gt;一、搭建过程如下：&lt;/h2&gt;&lt;h3 id=&quot;阶段1：-本地搭建&quot;&gt;&lt;a href=&quot;#阶段1：-本地搭建&quot; class</summary>
      
    
    
    
    <category term="hexo" scheme="https://polariis.gitee.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://polariis.gitee.io/tags/hexo/"/>
    
    <category term="gitee" scheme="https://polariis.gitee.io/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>CSS定位机制</title>
    <link href="https://polariis.gitee.io/posts/5d7648ee/"/>
    <id>https://polariis.gitee.io/posts/5d7648ee/</id>
    <published>2020-04-04T16:02:56.000Z</published>
    <updated>2021-12-04T11:08:37.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-文档流flow"><a href="#一-文档流flow" class="headerlink" title="一.文档流flow"></a>一.文档流flow</h2><ul><li><p>从上到下，从左到右。</p></li><li><h3 id="1-block元素："><a href="#1-block元素：" class="headerlink" title="1.block元素："></a>1.block元素：</h3><ul><li><p>元素独占一行；</p></li><li><p>元素的height、width、margin、padding都可以设置。</p></li><li><p>常见的block元素：div、p、h1~h6、ol、ul、table、form</p></li><li><p>将元素显示为block元素：<strong>display:block;</strong></p><p>例：</p></li></ul><pre><code>a&#123;    display:block;&#125;</code></pre><p>inline元素a转为block，从而使a元素具有块状元素的特点。</p></li><li><h3 id="2-inline元素："><a href="#2-inline元素：" class="headerlink" title="2.inline元素："></a>2.inline元素：</h3><ul><li>不用单独占用一行；</li><li>height、width不可设置；</li><li>width就是它已包含的文字或图片的宽度，不可改变。</li><li>常见inline元素：span、a</li><li>将元素显示为inline元素：<strong>display:inline;</strong></li><li>inline元素之间有个间距的问题，解决方法：转换为block。</li></ul></li><li><h3 id="3-inline-block元素："><a href="#3-inline-block元素：" class="headerlink" title="3.inline-block元素："></a>3.inline-block元素：</h3><ul><li>同时具备inline和block的特点：可平行的block；</li><li>不单独占用一行；</li><li>元素的height、width、margin、padding都可以设置；</li><li>常见的inline-block元素：img</li><li>显示为inline-block元素：<strong>display:inline-block；</strong></li></ul></li><li><h3 id="4-相互转换："><a href="#4-相互转换：" class="headerlink" title="4.相互转换："></a>4.相互转换：</h3><ul><li>display:none;                 元素不会被显示（<strong>不占原位置</strong>）</li><li>display:block                  显示为block元素</li><li>display:inline                  显示为inline元素</li><li>display:inline-block        显示为inline-block元素</li></ul></li></ul><h2 id="二-浮动定位float"><a href="#二-浮动定位float" class="headerlink" title="二.浮动定位float"></a>二.浮动定位float</h2><ul><li><p>float属性：left、right、none（不浮动）；</p></li><li><p>clear属性（清除）：left、right、both。</p></br></li></ul><p>*<em>当有3列都要水平时，将3列都设为左浮动即可。（宽度够用时）</em></p><h3 id="float属性的特点："><a href="#float属性的特点：" class="headerlink" title="float属性的特点："></a>float属性的特点：</h3><ul><li><p>当其中一个盒子移动时，<strong>其原有位置丢失，并被其他元素占用位置。</strong></p></br></li></ul><p>*<em>3个盒子并行，当高度不够时：</em></p><ul><li>第一种情况：box3下降</li><li>第二种情况：box1较高，box3向左下降时被卡住。</li></ul><h3 id="clear属性："><a href="#clear属性：" class="headerlink" title="clear属性："></a>clear属性：</h3><ul><li><p>单方向清除浮动的发法：比如将一行的box1和box2变为上下的列关系</p><ul><li><p>使box1位置不变，将box2设为：</p></li><li><pre><code>clear:right; </code></pre><p>  意思是清除右侧浮动，使其占据右侧。</p></br></li></ul></li><li><p>双侧清除：</p><pre><code>clear:right;</code></pre><p>意思是清楚两侧的浮动，使设置的元素单独占一行。</p></li></ul><h2 id="三-层定位layer"><a href="#三-层定位layer" class="headerlink" title="三.层定位layer"></a>三.层定位layer</h2><h3 id="position属性：（相对于谁定位）"><a href="#position属性：（相对于谁定位）" class="headerlink" title="position属性：（相对于谁定位）"></a>position属性：（相对于谁定位）</h3><ul><li><p>static：      默认值（没有定位，相当于不是层定位，定位的属性失效）</p></li><li><p>fixed：      固定定位（相对于浏览器窗口定位）</p></li><li><p>relative： 相对定位（相对于原来自己的位置定位），元素会脱离文档流，但在文档流中的<strong>位置还在，不会被占据。</strong></p></li><li><p>absolute：绝对定位（相对于static以外的第一个父元素定位），元素脱离文档流，在文档流中的<strong>原位置不再存在，会被占据</strong>。</p></br></li></ul><p>概述：像图像软件中的图层一样可以对每个layer进行精准定位操作。</p></br><p><em>当子元素相对于父元素定位，且父元素也相对于其父元素定位。可将最外层用相对定位，<strong>里面两层用绝对定位。</strong></em></p></br><p>*<em>特殊情况;：</em></p><p><em>对于absolute定位的层，若其父层都未定义absolute或relative，则将会<strong>相对body进行定位</strong>。</em></p></br><p><strong>relative+absolute：</strong>（父相子绝）</p><ul><li>父元素box1：position: relative;</li><li>子元素box2：position: absolute;</li><li>子元素box2：left、right、top、bottom相对于父元素进行偏移定位。</li></ul><p><strong>好处</strong>：当父元素box1移动时，子元素会相对于父元素的位置进行定位，可以一起移动。</p><h3 id="定位的属性："><a href="#定位的属性：" class="headerlink" title="定位的属性："></a>定位的属性：</h3><ul><li>left属性</li><li>right属性</li><li>top属性</li><li>bottom属性</li><li>z-index属性  （值大在上面）</li></ul><p>*<em>当想把图片设为背景，可将z-index设为负数，以留在最底层。</em></p></br></br>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-文档流flow&quot;&gt;&lt;a href=&quot;#一-文档流flow&quot; class=&quot;headerlink&quot; title=&quot;一.文档流flow&quot;&gt;&lt;/a&gt;一.文档流flow&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从上到下，从左到右。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="CSS" scheme="https://polariis.gitee.io/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://polariis.gitee.io/tags/CSS/"/>
    
    <category term="基础回顾" scheme="https://polariis.gitee.io/tags/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>CSS添加方法&amp;优先级&amp;CSS选择器</title>
    <link href="https://polariis.gitee.io/posts/6a1f6cdf/"/>
    <id>https://polariis.gitee.io/posts/6a1f6cdf/</id>
    <published>2020-03-30T16:02:56.000Z</published>
    <updated>2021-12-04T11:08:37.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、CSS添加方法："><a href="#一、CSS添加方法：" class="headerlink" title="一、CSS添加方法："></a>一、CSS添加方法：</h2><h3 id="1-行内样式："><a href="#1-行内样式：" class="headerlink" title="1.行内样式："></a>1.行内样式：</h3><p>表示当前样式作为CSS样式被添加到标签上（只对这个标签起作用）。</p><h3 id="2-内嵌样式："><a href="#2-内嵌样式：" class="headerlink" title="2.内嵌样式："></a>2.内嵌样式：</h3><p>将CSS代码内嵌到当前页面的head标签部分（只对当前页面起作用）。</p><p>首先body部分不再包含样式，将样式放在style标签中表示，和head标签为嵌套关系。</p><h3 id="3-链接样式（单独文件）："><a href="#3-链接样式（单独文件）：" class="headerlink" title="3.链接样式（单独文件）："></a>3.链接样式（单独文件）：</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;</code></pre><p>stylesheet为样式表文件；</p><p>href后面的是相对路径。</p><h2 id="二、样式优先级："><a href="#二、样式优先级：" class="headerlink" title="二、样式优先级："></a>二、样式优先级：</h2><ul><li><input disabled="" type="checkbox"> 多重样式可重叠，可覆盖。</li><li><input disabled="" type="checkbox"> 样式的优先级按”就近原则“。</li><li><input disabled="" type="checkbox"> 行内样式&gt;内嵌样式&gt;链接样式&gt;浏览器默认样式</li></ul><h2 id="三、CSS选择器："><a href="#三、CSS选择器：" class="headerlink" title="三、CSS选择器："></a>三、CSS选择器：</h2><h3 id="1-标签选择器："><a href="#1-标签选择器：" class="headerlink" title="1.标签选择器："></a>1.标签选择器：</h3><p>与标签同名，紧跟着一对花括号，例如：</p><pre><code>body&#123;    border-color: #aaaaff;&#125;</code></pre><h3 id="2-类选择器："><a href="#2-类选择器：" class="headerlink" title="2.类选择器："></a>2.类选择器：</h3><p>以.开头，例:</p><pre><code>.one&#123;    font-size:18px;&#125;</code></pre><h3 id="3-ID选择器："><a href="#3-ID选择器：" class="headerlink" title="3.ID选择器："></a>3.ID选择器：</h3><p>以#开头，例:</p><pre><code>#two&#123;    font-size:18px;&#125;</code></pre><p>2和3的区别：</p><ul><li><input disabled="" type="checkbox"> ID是唯一的，只能在HTML被引用一次。</li><li><input disabled="" type="checkbox"> 类选择器可以被多次引用，应用中多个页面元素上。</li><li><input disabled="" type="checkbox"> *因此：ID选择器用来布局，class选择器用在样式。</li></ul><h3 id="4-后代选择器："><a href="#4-后代选择器：" class="headerlink" title="4.后代选择器："></a>4.后代选择器：</h3><pre><code>p span&#123;    clor:red;            //作用于p标签内部的span标签&#125;</code></pre><p>两个标签之间使用空格空开。</p><h3 id="5-并集选择器："><a href="#5-并集选择器：" class="headerlink" title="5.并集选择器："></a>5.并集选择器：</h3><pre><code>p,span&#123;    clor:red;            //同时作用于两个标签&#125;</code></pre><p>连接符为,会使两者都变为红色。</p><h3 id="6-伪类选择器-Pseudo-classes-："><a href="#6-伪类选择器-Pseudo-classes-：" class="headerlink" title="6.伪类选择器(Pseudo-classes)："></a>6.伪类选择器(Pseudo-classes)：</h3><p>语法：</p><pre><code>selector:pseudo-class &#123;property:value;&#125;</code></pre><p>例如：</p><pre><code>a:link            //普通的，未被访问的链接a:visited         //用户已经访问过的链接a:hover         //鼠标悬停于链接上的样式a:active         //链接被点击时的样式</code></pre><p>​    注意：必须严格遵守以下顺序。</p><p>a:hover            <strong>必须在a:link和a:visited之后</strong></p><p>a:active             <strong>必须在a:hover之后</strong></p><p><strong>口诀：</strong></p><p><strong>l</strong>o<strong>v</strong>e&amp;<strong>ha</strong>te</p><h3 id="7-混合："><a href="#7-混合：" class="headerlink" title="7.混合："></a>7.混合：</h3><ul><li>多个class选择器混用，用空格分开。</li></ul><pre><code>&lt;div class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id和class混用：</li></ul><pre><code>&lt;div id=&quot;my&quot; class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id选择器不可以多个同时使用。</li></ul></br></br></br>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、CSS添加方法：&quot;&gt;&lt;a href=&quot;#一、CSS添加方法：&quot; class=&quot;headerlink&quot; title=&quot;一、CSS添加方法：&quot;&gt;&lt;/a&gt;一、CSS添加方法：&lt;/h2&gt;&lt;h3 id=&quot;1-行内样式：&quot;&gt;&lt;a href=&quot;#1-行内样式：&quot; class</summary>
      
    
    
    
    <category term="CSS" scheme="https://polariis.gitee.io/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://polariis.gitee.io/tags/CSS/"/>
    
    <category term="基础回顾" scheme="https://polariis.gitee.io/tags/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>图像格式和路径</title>
    <link href="https://polariis.gitee.io/posts/66ad3928/"/>
    <id>https://polariis.gitee.io/posts/66ad3928/</id>
    <published>2020-03-29T16:02:56.000Z</published>
    <updated>2021-12-04T11:08:37.516Z</updated>
    
    <content type="html"><![CDATA[</br><h2 id="一、图像格式："><a href="#一、图像格式：" class="headerlink" title="一、图像格式："></a>一、图像格式：</h2></br><p>JPG：有损压缩，图片色彩丰富。（快，不失真）</p><p>GIF：简单动画，背景透明。</p><p>PNG：无损压缩，透明，交错，动画（支持有/无损，比GIF色彩丰富）。</p></br><p>透明：可以给定图片一种颜色，使其不被显示而成为透明。</p><p>交错：在显示图片的过程中可以从概貌逐渐变化为全貌，看上去也就是清晰度从低到高。</p><h2 id="二、插入图片img："><a href="#二、插入图片img：" class="headerlink" title="二、插入图片img："></a>二、插入图片img：</h2></br><p>src属性：组成为 路径+文件名（不仅要带有图片的名字及后缀，还要有图片的完整路径）</p><p>alt属性：当图片没有被找到时，显示的替代文本。</p></br><h2 id="三、绝对路径-amp-相对路径："><a href="#三、绝对路径-amp-相对路径：" class="headerlink" title="三、绝对路径&amp;相对路径："></a>三、绝对路径&amp;相对路径：</h2></br><p>绝对路径：以根目录为基准。</p><p>相对路径：以该文件所在位置为基准。</p><ul><li><input disabled="" type="checkbox"> ..表示上一级</li><li><input disabled="" type="checkbox"> /表示下一级</li></ul></br></br></br></br></br>]]></content>
    
    
      
      
    <summary type="html">&lt;/br&gt;

&lt;h2 id=&quot;一、图像格式：&quot;&gt;&lt;a href=&quot;#一、图像格式：&quot; class=&quot;headerlink&quot; title=&quot;一、图像格式：&quot;&gt;&lt;/a&gt;一、图像格式：&lt;/h2&gt;&lt;/br&gt;

&lt;p&gt;JPG：有损压缩，图片色彩丰富。（快，不失真）&lt;/p&gt;
&lt;p&gt;GIF：简</summary>
      
    
    
    
    <category term="HTML" scheme="https://polariis.gitee.io/categories/HTML/"/>
    
    
    <category term="基础回顾" scheme="https://polariis.gitee.io/tags/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    
    <category term="HTML" scheme="https://polariis.gitee.io/tags/HTML/"/>
    
  </entry>
  
</feed>
