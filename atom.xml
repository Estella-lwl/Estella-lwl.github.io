<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>polariis</title>
  
  <subtitle>where&#39;s my code?</subtitle>
  <link href="https://polariis.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://polariis.gitee.io/"/>
  <updated>2023-05-20T10:48:18.953Z</updated>
  <id>https://polariis.gitee.io/</id>
  
  <author>
    <name>polariis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vite无法使用动态src路径的问题 &amp; 解决</title>
    <link href="https://polariis.gitee.io/posts/6a3db6b3/"/>
    <id>https://polariis.gitee.io/posts/6a3db6b3/</id>
    <published>2023-02-27T06:48:00.000Z</published>
    <updated>2023-05-20T10:48:18.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vite中使用动态图片路径src的三个方式："><a href="#vite中使用动态图片路径src的三个方式：" class="headerlink" title="vite中使用动态图片路径src的三个方式："></a>vite中使用动态图片路径src的三个方式：</h3><h4 id="1-使用-new-URL-的方式；"><a href="#1-使用-new-URL-的方式；" class="headerlink" title="1. 使用 new URL 的方式；"></a>1. 使用 <strong>new URL</strong> 的方式；</h4><h4 id="2-手动-import-引入每张图片；"><a href="#2-手动-import-引入每张图片；" class="headerlink" title="2. 手动 import 引入每张图片；"></a><strong>2.</strong> 手动 import 引入每张图片；</h4><h4 id="3-使用以下方式👇🏻："><a href="#3-使用以下方式👇🏻：" class="headerlink" title="3. 使用以下方式👇🏻："></a>3. 使用以下方式👇🏻：</h4><ol><li><p>将图片命名为统一前缀。</p></li><li><p>使用Vite提供的 **import.meta.glob()**方法匹配文件。参考<a href="https://vitejs.cn/vite3-cn/guide/features.html#glob-import">Vite官方文档</a>。</p></li><li><ul><li>import.meta.glob()：动态加载模块的方法，返回一个对象。例：<strong>import.meta.glob(“@/assets/imgs/pre_name*.png”)</strong></li><li>使用通配符*****匹配；</li></ul></li><li><p>遍历匹配到的文件列表</p></li><li><ul><li>通过对象的 key 值访问对应的模块；res为一个Module对象。</li><li>iconList.value[key] = res.default;   </li></ul></li></ol><p>将加载模块的default属性（路径）赋值给 iconList 对象的对应属性。</p><pre><code>  // 匹配图片列表：  const files = import.meta.glob(&quot;@/assets/imgs/game/game-project*.png&quot;);  const iconList = ref&lt;any&gt;(&#123;&#125;);    for (const key in files) &#123;    console.log(&quot;key: &quot;, key);    // 访问当前键名对应的文件模块 =》then回调将结果（路径）存入res中：    files[key]().then((res: any) =&gt; &#123;      // 将匹配到的文件路径放入iconList：      iconList.value[key] = res.default;      console.log(&quot;iconList: &quot;, iconList.value);    &#125;);  &#125;    // 返回一个对象键名（文件路径）组成的数组 &amp; 遍历  Object.keys(iconList.value).forEach((item) =&gt; &#123;    iconList.value[item][&quot;namespaced&quot;] = true;    console.log(&quot;modules2222: &quot;, iconList.value);  &#125;);</code></pre><p><strong>PS</strong>：</p><ul><li>官方提供new URL的方式，但打包后路径又会出问题。</li><li>新版本似乎会优化这个问题，最近没关注。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vite中使用动态图片路径src的三个方式：&quot;&gt;&lt;a href=&quot;#vite中使用动态图片路径src的三个方式：&quot; class=&quot;headerlink&quot; title=&quot;vite中使用动态图片路径src的三个方式：&quot;&gt;&lt;/a&gt;vite中使用动态图片路径src的三个方</summary>
      
    
    
    
    <category term="Vite" scheme="https://polariis.gitee.io/categories/Vite/"/>
    
    
    <category term="Vite" scheme="https://polariis.gitee.io/tags/Vite/"/>
    
  </entry>
  
  <entry>
    <title>使用InstanceType获取组件的类型</title>
    <link href="https://polariis.gitee.io/posts/26a2e475/"/>
    <id>https://polariis.gitee.io/posts/26a2e475/</id>
    <published>2023-01-07T06:22:23.000Z</published>
    <updated>2023-02-15T14:53:52.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-InstanceType作用-amp-使用"><a href="#1-InstanceType作用-amp-使用" class="headerlink" title="1. InstanceType作用&amp;使用"></a>1. InstanceType作用&amp;使用</h2><h3 id="1-1-前言："><a href="#1-1-前言：" class="headerlink" title="1.1 前言："></a><strong>1.1 前言</strong>：</h3><ul><li>使用<span style="color: #3850b8"><code>defineComponent</code></span>的vue组件，导出的是一个<span style="color: #3850b8">对象</span>👇🏻（里面将对象传给了defineComponent方法，但它还会返回出来）</li></ul><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230212195244969.png" alt="image-20230212195244969"></p><ul><li><ul><li><p>👆🏻这个组件经defineComponent后导出的对象{}只是组件的描述（可以看成是个class类，但它里面是一个个的值，对比类型中的class），而其他组件引入后使用的是根据这个对象创建出的实例对象。</p></li><li><ul><li><p>也就是说在其他组件引入后使用的是根据这个对象创建出的真正的<strong>组件实例</strong>，而不是直接使用这个组件导出的对象。</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230212195455412.png" alt="image-20230212195455412"></p></li></ul></li></ul></li></ul><h3 id="1-2-使用TS中的InstanceType获取组件的类型"><a href="#1-2-使用TS中的InstanceType获取组件的类型" class="headerlink" title="1.2 使用TS中的InstanceType获取组件的类型"></a>1.2 使用TS中的InstanceType获取组件的类型</h3><ul><li><p>所以需要找到使用组件类型的方法，也就引出了：<span style="color: #0091ff"><strong>InstanceType</strong></span>。</p></li><li><p><strong>InstanceType可以取到一个有构造函数的实例</strong>，利用这一点<span style="color: #CC0000"><strong>可以获取组件的类型</strong></span>。</p></li><li><p>先使用<code>typeof</code>拿到类型，再使用<code>InstanceType</code>拿到有构造函数的实例。这样就可以确认<code>demoRef</code>是<code>Demo</code>组件创建出来的。</p></li><li><p>在TS文档中：<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype">https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype</a></p></li><li><ul><li>文档中的例子👇🏻：（<span style="color: #E95200"><strong><code>C = InstanceType</code></strong></span>，跟上张图中的意思一致）</li></ul></li></ul><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230212195841335.png" alt="image-20230212195841335"></p><ul><li><strong>示例</strong>：</li></ul><p><span style="color: #0091ff">example2</span>. 使用typeof、InstanceType（TS提供的获取某个组件实例）：</p><ul><li><ul><li>使用组件<strong>对象的实例的类型</strong>，而不是直接使用组件对象的类型：</li></ul></li></ul><pre><code>// 引入子组件：import LoginAccount from &#39;./login-account.vue&#39;// 拿到组件对象类型（LoginAccount是给自定义组件绑定的ref）：const componentRef = ref&lt;InstanceType&lt;typeof LoginAccount&gt;&gt;();</code></pre><p><span style="color: #0091ff">example2</span>. 使用UI自带组件的类型：</p><pre><code>import &#123; ELForm &#125; from &#39;element-plus&#39;;// formRef是给el-form组件ref：const formRef = ref&lt;InstanceType&lt;typeof ELForm&gt;&gt;();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-InstanceType作用-amp-使用&quot;&gt;&lt;a href=&quot;#1-InstanceType作用-amp-使用&quot; class=&quot;headerlink&quot; title=&quot;1. InstanceType作用&amp;amp;使用&quot;&gt;&lt;/a&gt;1. InstanceType作</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/tags/TypeScript/"/>
    
    <category term="TypeScript在项目中使用&amp;技巧" scheme="https://polariis.gitee.io/tags/TypeScript%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用TS封装axios</title>
    <link href="https://polariis.gitee.io/posts/e96745cc/"/>
    <id>https://polariis.gitee.io/posts/e96745cc/</id>
    <published>2022-12-11T09:53:41.000Z</published>
    <updated>2023-05-20T02:13:43.610Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color: #8c7be9">大致步骤</span>👇🏻（PS：过程中的代码可能不是最终的，可以在后面看最终的总结及代码。）</p><h2 id="1-封装-axios-实例"><a href="#1-封装-axios-实例" class="headerlink" title="1. 封装 axios 实例"></a>1. 封装 axios 实例</h2><ul><li>封装后可以 new 出多个实例，每个实例可以有不同的 BASE_URL 等。</li></ul><h3 id="1-1-使用-class-封装-axios"><a href="#1-1-使用-class-封装-axios" class="headerlink" title="1.1 使用 class 封装 axios"></a>1.1 使用 class 封装 axios</h3><ul><li><p>这个类用作一种类型约束，在封装 X 时可以使用。</p></li><li><p>使用<strong>class 封装的原因</strong>：</p><ul><li>class 有更强的封装性； [类 class](./类 class（JS &amp; TS）.md)</li><li>constructor 每次执行是一个新的；</li></ul></li></ul><p>request/index.ts：</p><pre><code>import axios, &#123; AxiosInstance &#125; from &quot;axios&quot;;export class SelfAxios &#123;  instance?: AxiosInstance; //axios实例的类型&#125;</code></pre><h4 id="1-1-1-关于封装-axios-时的类型："><a href="#1-1-1-关于封装-axios-时的类型：" class="headerlink" title="1.1.1 关于封装 axios 时的类型："></a>1.1.1 关于封装 axios 时的类型：</h4><ul><li><p>其中<span style="background-color: #ebf5ff;"><strong>instance</strong></span>属性的 ts 类型由 Axios 提供：**<code>AxiosInstance</code>**。</p><ul><li>每个由 axios 创建出的<strong>实例</strong>，都会有 AxiosInstance 类型。</li></ul></li><li><p>而 instance 实例传进的<span style="background-color: #ebf5ff;"><strong>config 参数</strong></span>也有类型：**<code>AxiosRequestConfig</code>**。</p></li></ul><p>request/index.ts：</p><pre><code>import axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  constructor(config: AxiosRequestConfig) &#123;    this.instance = axios.create(config); //在构造器中将实例赋值axios的create方法  &#125;&#125;</code></pre><h3 id="1-2-创建实例-amp-添加-baseurl"><a href="#1-2-创建实例-amp-添加-baseurl" class="headerlink" title="1.2 创建实例 &amp; 添加 baseurl"></a>1.2 创建实例 &amp; 添加 baseurl</h3><ul><li><p>new 一个或多个实例，在以后写请求时调用该实例的 request 方法；</p></li><li><p>在实例中添加<code>baseURL、timeout</code>等信息。</p><ul><li><code>baseURL</code>可以根据环境变量来决定。</li></ul></li></ul><p>新建文件 api/common/config.ts： （根据环境切换 baseurl）</p><pre><code>//  根据process.env.NODE_ENV区分// 开发环境: development// 生成环境: production// 测试环境: testlet BASE_URL = &quot;&quot;;const TIME_OUT = 10000;if (process.env.NODE_ENV === &quot;development&quot;) &#123;  BASE_URL = &quot;http://123.207.32.32:8000&quot;;&#125; else if (process.env.NODE_ENV === &quot;production&quot;) &#123;  BASE_URL = &quot;http://123.207.32.32:8000&quot;;&#125; else &#123;  BASE_URL = &quot;http://123.207.32.32:8000&quot;;&#125;// 这里的定义方式只能这样导出，属于ES Module的语法：export &#123; BASE_URL, TIME_OUT &#125;;</code></pre><p>api/index.ts： （创建实例）</p><pre><code>// 统一出口：import &#123; SelfAxios &#125; from &quot;./request&quot;;import &#123; BASE_URL, TIME_OUT &#125; from &quot;./common/config&quot;;/* 本段创建实例的代码已放在 /request/index */// export function request(config: AxiosRequestConfig) &#123;//   // 创建一个实例对象：//   const instance = axios.create(&#123;//     baseURL: &quot;&quot;,//     timeout: 500//   &#125;);//   return instance(config);// &#125;export const request = new SelfAxios(&#123;  baseURL: BASE_URL, // 这里不会写死而是拿到不同配置文件中的值  timeout: TIME_OUT&#125;);</code></pre><p>api/request/index： （这个文件可以放在 utils 目录下）</p><pre><code>import axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;// *****该文件后续可能会移至utils文件夹*****// 这里使用class因为它有更强的封装性：export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  constructor(config: AxiosRequestConfig) &#123;    this.instance = axios.create(config); //在构造器中将实例赋值axios的create方法  &#125;  //以后实例化SelfAxios后可以使用这里的request方法：  request(config: AxiosRequestConfig) &#123;    this.instance.request(config).then((res) =&gt; &#123;      console.log(&quot;res&quot;, res);    &#125;);  &#125;&#125;</code></pre><h2 id="2-添加拦截器"><a href="#2-添加拦截器" class="headerlink" title="2. 添加拦截器"></a>2. 添加拦截器</h2><p><span style="background-color: #ebf5ff;">三种拦截器</span>： （都已记录）</p><ol><li> axios 实例中添加拦截器</li><li> 全局添加拦截器</li><li> 单个请求中添加拦截器</li></ol><h3 id="2-1-axios-实例中添加拦截器"><a href="#2-1-axios-实例中添加拦截器" class="headerlink" title="2.1 axios 实例中添加拦截器"></a>2.1 axios 实例中添加拦截器</h3><ul><li><p>之后在划分模块时，一定会有一些<strong>公有的逻辑</strong> =》可以将它们封装在请求中，写进拦截器中。</p><ul><li>比如<span style="color: #0091ff">携带 token</span>、<span style="color: #0091ff">loading 加载</span>。</li><li>除了上面的基本配置，在创建实例时<strong>还可以传进一些 hooks</strong>。</li></ul></li><li><p><span style="color: #CC0000"><strong>注意</strong></span>：但不能直接传 hook，因为这里 config 要求传进的是<span style="color: #8c7be9"><code>AxiosRequestConfig</code></span>类型（这个类型里没有 hook 属性），所以<span style="color: #8c7be9">要自定义 hook </span>👇🏻。</p></li></ul><p>新建 request/types.ts：</p><ol><li>对原本的 config 类型<span style="color: #8c7be9"><code>AxiosRequestConfig</code></span><strong>做扩展</strong>；</li><li>定义好传入哪些拦截器。</li></ol><pre><code>import &#123; AxiosRequestConfig, AxiosResponse &#125; from &quot;axios&quot;;// 在这里定义好可以传入哪些hook（拦截器）：export interface AxiosRequestInterceptors &#123;  // 可以有四个interceptor:  //  当interceptor传进来后，会被放进request实例中(看17行的使用)；  //  拦截器参数config的类型就是AxiosRequestConfig，其返回值也是AxiosRequestConfig。  requestInterceptor?: (config: AxiosRequestConfig) =&gt; AxiosRequestConfig;  requestInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型；  //  响应拦截：  responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse;  responseInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型&#125;// 对原本的AxiosRequestConfig做扩展，使其可以做到传递一些hooks拦截器：export interface SelfRequestConfig extends AxiosRequestConfig &#123;  //继承AxiosRequestConfig后，给它添加一个interceptor扩展。  interceptors?: AxiosRequestInterceptors;&#125;</code></pre><p>api/request/index.ts：</p><pre><code>import axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;import &#123; AxiosRequestInterceptors, SelfRequestConfig &#125; from &quot;./types&quot;;// *****该文件后续可能会移至utils文件*****// 这里使用class因为它有更强的封装性：export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  interceptors?: AxiosRequestInterceptors; //到时传进来的所有拦截器  constructor(config: SelfRequestConfig) &#123;    //这里config由AxiosRequestConfig换成上面SelfRequestConfig    this.instance = axios.create(config); //在构造器中将实例赋值axios的create方法    this.interceptors = config.interceptors; //这里也可以不保存起来；保存起来后下行可以使用到👇🏻    //在这里可以将上面扩展好的interceptors使用起来：    this.instance.interceptors.request.use(      this.interceptors?.requestInterceptor,      this.interceptors?.requestInterceptorCatch    );    //响应拦截：    this.instance.interceptors.response.use(      this.interceptors?.responseInterceptor,      this.interceptors?.responseInterceptorCatch    );    //👆🏻这样就可以给实例传入什么拦截就应用什么拦截。  &#125;  //实例化SelfAxios后可以使用这里的request方法：  request(config: AxiosRequestConfig) &#123;    this.instance.request(config).then((res) =&gt; &#123;      console.log(&quot;res&quot;, res);    &#125;);  &#125;&#125;</code></pre><p><strong>最终在实例中添加了拦截器的</strong> api/index：</p><pre><code>// 统一出口：import axios from &quot;axios&quot;;import type &#123; AxiosInstance &#125; from &quot;axios&quot;;import type &#123; SelfRequestInterceptors, SelfRequestConfig &#125; from &quot;./types&quot;;import &#123; SelfAxios &#125; from &quot;./request&quot;;import &#123; BASE_URL, TIME_OUT &#125; from &quot;./common/config&quot;;export class IRequestClass &#123;  instance?: AxiosInstance;&#125;/* 本段创建实例的代码已放在./request/index */// export function request(config:SelfRequestConfig) &#123;//   // 创建一个实例对象：//   const instance = axios.create(&#123;//     baseURL: &quot;&quot;,//     timeout: 500//   &#125;);//   return instance(config);// &#125;export const request = new SelfAxios(&#123;  baseURL: BASE_URL, // 这里不会写死而是拿到不同配置文件中的值  timeout: TIME_OUT,  //1. 除了上面的基本配置还可以传进hooks，里面对应的是一个个的拦截器。  //2. 但不能直接传hook，因为这里要求传进的是AxiosRequestConfig类型，所以要自定义hook。  interceptors: &#123;    requestInterceptor: (config) =&gt; &#123;      //在拦截时需要进行的操作可以在这里添加：      console.log(&quot;请求成功的拦截&quot;, config);      return config;    &#125;,    requestInterceptorCatch: (err) =&gt; &#123;      console.log(&quot;请求失败的拦截&quot;, err);      return err;    &#125;,    responseInterceptor: (config) =&gt; &#123;      console.log(&quot;响应成功的拦截&quot;, config);      return config;    &#125;,    responseInterceptorCatch: (err) =&gt; &#123;      console.log(&quot;响应失败的拦截&quot;, err);      return err;    &#125;  &#125;&#125;);</code></pre><h3 id="2-2-全局添加拦截器"><a href="#2-2-全局添加拦截器" class="headerlink" title="2.2 全局添加拦截器"></a>2.2 全局添加拦截器</h3><p>api/request/index.ts：</p><pre><code>import axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;import &#123; AxiosRequestInterceptors, SelfRequestConfig &#125; from &quot;./types&quot;;// *****该文件后续可能会移至utils文件*****// 这里使用class因为它有更强的封装性：export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  interceptors?: AxiosRequestInterceptors; //到时传进来的所有拦截器  constructor(config: SelfRequestConfig) &#123;    //这里config由AxiosRequestConfig换成上面SelfRequestConfig    this.instance = axios.create(config); //在构造器中将实例赋值axios的create方法    this.interceptors = config.interceptors; //这里也可以不保存起来；保存起来后下行可以使用到👇🏻    //在这里可以将上面扩展好的interceptors使用起来：    this.instance.interceptors.request.use(      this.interceptors?.requestInterceptor,      this.interceptors?.requestInterceptorCatch    );    //响应拦截：    this.instance.interceptors.response.use(      this.interceptors?.responseInterceptor,      this.interceptors?.responseInterceptorCatch    );    //👆🏻这样就可以给实例传入什么拦截就应用什么拦截。    //********以上是给实例添加拦截器，以下为全局的拦截器添加方式：    //  这种未指定实例的就是全局的：    this.instance.interceptors.request.use(      (config) =&gt; &#123;        console.log(&quot;全局请求拦截&quot;);        return config;      &#125;,      (err) =&gt; &#123;        console.log(&quot;全局请求拦截&quot;);        return err;      &#125;    );    this.instance.interceptors.response.use(      (res) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        return res.data;      &#125;,      (err) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        return err;      &#125;    );  &#125;  //实例化SelfAxios后可以使用这里的request方法：  request(config: AxiosRequestConfig) &#123;    this.instance.request(config).then((res) =&gt; &#123;      console.log(&quot;res&quot;, res);    &#125;);  &#125;&#125;</code></pre><h3 id="2-3-单个请求中添加拦截器"><a href="#2-3-单个请求中添加拦截器" class="headerlink" title="2.3 单个请求中添加拦截器"></a>2.3 单个请求中添加拦截器</h3><ul><li><p>request 方法的 config 参数类型需要做转化，</p><ul><li>方式 1. 转化 config 参数</li><li>方式 2. 判断当有请求拦截器传入时，使用 config.interceptors.requestInterceptor 的方式转化。</li></ul></li></ul><pre><code>// 有两种方式：  （注意这里的类型换了）  request(config: SelfRequestConfig): void &#123;    //config类型要先换成扩展后的    // // 方式1. 将config这里转化一下(transformRequest是本来就有提供的)：    // this.instance.request(&#123; ...config, transformRequest &#125;).then((res) =&gt; &#123;    //   console.log(&quot;res&quot;, res);    // &#125;);    // 方式2. 当👇🏻存在时，使用config.interceptors.requestInterceptor的方式转化：    if (config.interceptors?.requestInterceptor) &#123;      config = config.interceptors.requestInterceptor(config);    &#125;    this.instance.request(config).then((res) =&gt; &#123;      // 也可以对响应结果做处理：      if (config.interceptors?.responseInterceptor) &#123;        // 转换res:        res = config.interceptors.responseInterceptor(res);      &#125;      console.log(&quot;res&quot;, res);    &#125;);  &#125;</code></pre><p><strong>最终添加完拦截器的</strong> api/request/index.ts：</p><ul><li>其中声明的类型已单独新建&amp;放进 ./types.ts 中（在上面已记录）。</li></ul><pre><code>import axios, &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;import &#123; AxiosRequestInterceptors, SelfRequestConfig &#125; from &quot;./types&quot;;// *****该文件后续可能会移至utils文件*****// 这里使用class因为它有更强的封装性：export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  interceptors?: AxiosRequestInterceptors; //到时传进来的所有拦截器  constructor(config: SelfRequestConfig) &#123;    //这里config由AxiosRequestConfig换成上面SelfRequestConfig    this.instance = axios.create(config); //在构造器中将实例赋值axios的create方法    this.interceptors = config.interceptors; //这里也可以不保存起来；保存起来后下行可以使用到👇🏻    //在这里可以将上面扩展好的interceptors使用起来：    this.instance.interceptors.request.use(      this.interceptors?.requestInterceptor,      this.interceptors?.requestInterceptorCatch    );    //响应拦截：    this.instance.interceptors.response.use(      this.interceptors?.responseInterceptor,      this.interceptors?.responseInterceptorCatch    );    //👆🏻这样就可以给实例传入什么拦截就应用什么拦截。    //********以上是给实例添加拦截器，以下为全局的拦截器添加方式：    //  这种未指定实例的就是全局的：    this.instance.interceptors.request.use(      (config) =&gt; &#123;        console.log(&quot;全局请求拦截&quot;);        return config;      &#125;,      (err) =&gt; &#123;        console.log(&quot;全局请求拦截&quot;);        return err;      &#125;    );    this.instance.interceptors.response.use(      (res) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        return res.data;      &#125;,      (err) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        return err;      &#125;    );  &#125;  // //实例化SelfAxios后可以使用这里的request方法：  // request(config: AxiosRequestConfig) &#123;  //   this.instance.request(config).then((res) =&gt; &#123;  //     console.log(&quot;res&quot;, res);  //   &#125;);  // &#125;  // ******如果要给单个请求做拦截，request的写法：   ***********  // 有两种方式：  （注意这里的类型换了）  request(config: SelfRequestConfig): void &#123;    //config类型要先换成扩展后的    // // 方式1. 将config这里转化一下(transformRequest是本来就有提供的)：    // this.instance.request(&#123; ...config, transformRequest &#125;).then((res) =&gt; &#123;    //   console.log(&quot;res&quot;, res);    // &#125;);    // 方式2. 当👇🏻存在时，使用config.interceptors.requestInterceptor的方式转化：    if (config.interceptors?.requestInterceptor) &#123;      config = config.interceptors.requestInterceptor(config);    &#125;    this.instance.request(config).then((res) =&gt; &#123;      // 也可以对响应结果做处理：      if (config.interceptors?.responseInterceptor) &#123;        // 转换res:        res = config.interceptors.responseInterceptor(res);      &#125;      console.log(&quot;res&quot;, res);    &#125;);  &#125;&#125;</code></pre><h3 id="3-💡-以上封装的思路总结："><a href="#3-💡-以上封装的思路总结：" class="headerlink" title="3. 💡 以上封装的思路总结："></a>3. 💡 以上封装的思路总结：</h3><ol><li><p><strong>封装 axios</strong>：</p><ol><li>注意 instance 的类型和 request 方法的参数 config 的类型。</li><li>根据需要给类型做扩展，在之后的使用中直接使用扩展好的。</li></ol></li><li><p><strong>封装拦截器</strong>： （以下可 3 中可以都封装进去）</p><ul><li><p>每个<span style="color: #678f00"><strong>实例单独的拦截器</strong></span>：</p><ul><li>原先封装时的<code>constructor</code><strong>默认</strong>只能传 <strong><code>AxiosRequestConfig</code> 类型</strong>，但需要考虑到传递<code>hooks</code>的情况（拦截器） =》可以自定义个 class 再利用<code>extends</code>继承<code>AxiosRequestConfig</code>，<strong>实现对它的扩展</strong>。</li><li>然后在封装 axios 中替换为 👆🏻 新的 class，这样每个实例可以有不同的拦截器。<ul><li>PS：需要注意，由于拦截器是可选的，在实例中使用时应该写为<span style="color: #8c7be9"><strong>可选链</strong></span>形式。</li></ul></li></ul></li><li><p><span style="color: #678f00"><strong>全局所有实例的拦截器</strong></span>：</p><ul><li>PS：请求拦截是后添加的先执行；响应拦截是先添加的先响应。</li></ul></li><li><p><strong>请求单独的拦截器</strong>：</p><ol><li>这时封装 axios 实例时 request 的 config 参数不能使用默认的<code>AxiosRequestConfig</code>类型，而是为其做了拓展的<code>SelfRequestConfig</code>。</li><li></li><li>PS：一般单个请求的拦截不会拦截 error。</li></ol></li><li><p>举例：</p><ul><li>封装的地方：</li></ul></li></ul></li></ol><pre><code>...外层代码略...// ******如果要给单个请求做拦截，request的写法：   ***********  // 有两种方式：  （注意这里的类型换了）  request(config: SelfRequestConfig): void &#123;    //config类型要先换成扩展后的    // // 方式1. 将config这里转化一下(transformRequest是本来就有提供的)：    // this.instance.request(&#123; ...config, transformRequest &#125;).then((res) =&gt; &#123;    //   console.log(&quot;res&quot;, res);    // &#125;);    // 方式2. 当👇🏻存在时，使用config.interceptors.requestInterceptor的方式转化：    if (config.interceptors?.requestInterceptor) &#123;      config = config.interceptors.requestInterceptor(config);    &#125;    this.instance.request(config).then((res) =&gt; &#123;      // 也可以对响应结果做处理：      if (config.interceptors?.responseInterceptor) &#123;        // 转换res:        res = config.interceptors.responseInterceptor(res);      &#125;      console.log(&quot;res&quot;, res);    &#125;);  &#125;...</code></pre><ul><li><ul><li><ul><li>请求的地方：</li></ul></li></ul></li></ul><pre><code>export function loginRequest(account: IAccount) &#123;  return request.request(&#123;    url: LoginApi.AccountLogin,    method: &quot;get&quot;,    data: account, //data是放在account中的    // 给当前请求单独设置拦截：    interceptors: &#123;      requestInterceptor: (config) =&gt; &#123;        console.log(&quot;单独请求的config&quot;, config);        return config;      &#125;,      responseInterceptor: (res) =&gt; &#123;        console.log(&quot;单独响应的res&quot;, res);        return res;      &#125;    &#125;  &#125;);&#125;</code></pre><p>控制台结果打印：</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218153030722.png" alt="image-20230218153030722"></p><p>此处待整理：</p><blockquote><p>token 一般会放在请求头中。</p></blockquote><h2 id="4-完善封装"><a href="#4-完善封装" class="headerlink" title="4. 完善封装"></a>4. 完善封装</h2><h3 id="4-1-错误拦截的全局提示"><a href="#4-1-错误拦截的全局提示" class="headerlink" title="4.1 错误拦截的全局提示"></a>4.1 错误拦截的全局提示</h3><p>响应失败的错误返回分两种：</p><ul><li><p><span style="background-color: #ebf5ff; color: #8c7be9">HttpErrorCode</span>：403、404、501、502</p></li><li><p>返回 200，错误信息放在了返回中：</p></li><li><p>-</p></li></ul><pre><code>...外层代码已略...this.instance.interceptors.response.use(      (res) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        return res.data;      &#125;,      (err) =&gt; &#123;        console.log(&quot;全局响应拦截&quot;);        //全局响应失败的拦截： (根据后端返回的错误码做出提示)        switch (err.response.status) &#123;          case &quot;404&quot;:            alert(&quot;404&quot;);            break;          case &quot;501&quot;:            alert(&quot;501&quot;);            break;        &#125;        return err;      &#125;    );</code></pre><h3 id="4-2-全局-loading-amp-可配置"><a href="#4-2-全局-loading-amp-可配置" class="headerlink" title="4.2 全局 loading &amp; 可配置"></a>4.2 全局 loading &amp; 可配置</h3><ul><li>有些请求是不需要有<code>loading</code>状态的，所以应该是<span style="color: #FFB700"><strong>可配置</strong></span>的。</li><li>和上面的拦截器同理，可以在给 <u>AxiosRequestConfig 做的扩展中添加</u> 。</li></ul><p>utils/request/types.ts：</p><pre><code>// 对原本的AxiosRequestConfig做扩展，使其可以做到传递一些hooks拦截器：export interface SelfRequestConfig extends AxiosRequestConfig &#123;  //继承AxiosRequestConfig后，给它添加一个interceptor扩展。  interceptors?: AxiosRequestInterceptors;  showLoading?: boolean;    //将loading设为可选的&#125;</code></pre><p>在 utils/request/index 中：</p><pre><code>export class SelfAxios &#123;  instance: AxiosInstance; // axios提供的实例的类型  interceptors?: AxiosRequestInterceptors; //到时传进来的所有拦截器  showLoading: boolean; //记录是否showLoading;没有定义为可选的原因：使用👇🏻16行的写法使其有默认值  loading?: LoadingInstance;  //。。。后面省略。。。</code></pre><ul><li>某个接口中需要使用时：</li></ul><pre><code>export function loginRequest(account: IAccount) &#123;  return request.request(&#123;    url: &#39;xxx&#39;,    method: &quot;get&quot;,    showLoading: true // 如果这里不传，就会使用封装时设置的默认值true  &#125;);&#125;</code></pre><ul><li><span style="color: #CC0000"><strong>注意</strong></span>：<ul><li>如果某一接口将 loading 设置为 false 了，要<span style="color: #FFB700">在它后面设回 true 才可以在进入下一个页面后正常出现 loading</span>👇🏻。</li><li>同时，也要注意 catch err 后的 loading 状态。</li></ul></li></ul><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218153523649.png" alt="image-20230218153523649"></p><h3 id="4-3-封装完善-amp-响应拦截的类型完善"><a href="#4-3-封装完善-amp-响应拦截的类型完善" class="headerlink" title="4.3 封装完善 &amp; 响应拦截的类型完善"></a>4.3 封装完善 &amp; 响应拦截的类型完善</h3><blockquote><p><span style="color: #3850b8">前言 &amp; 大致思路</span>：</p><p>① 前部分已将 axios 基本封装&amp;加入了 loading，但存在一个<strong>问题</strong>👇🏻：</p><p>request 的 res 数据此时在封装的 instance 实例中拿到，而非具体的某个接口中。</p><p>②<span style="color: #8c7be9"><strong>解决</strong></span>：</p><ol><li>用 <code>return</code> 一个 <code>promise</code> 代替此时直接 <code>this.instance...</code> 的写法（这里使用类封装的，对比最开始的写法是 const instance 并 return）。</li><li>由此引出了 TS 类型约束的更换：<ol><li>先将<code>request</code>及 Promise 中拿到的返回分别更换为 Promise 类型、泛型。</li><li>使用 promise 后需要将 request 的 res 结果 <code>resolve</code> 返回出去 &amp; <code>reject</code>也要。</li><li>SelfRequestConfig 添加泛型（具体看 S2.）。</li></ol></li></ol><p>以下是具体实现过程 👇🏻：</p></blockquote><h4 id="S1-使用-Promise-写法-amp-更换其类型："><a href="#S1-使用-Promise-写法-amp-更换其类型：" class="headerlink" title="S1. 使用 Promise 写法 &amp; 更换其类型："></a>S1. 使用 Promise 写法 &amp; 更换其类型：</h4><ol><li>将 request 的封装更改为 promise 的写法；</li><li>这时类型也需要更换 👉🏻 将 request 类型由<code>void</code><span style="color: #0091ff">换为<code>Promise</code>类型</span>（因为给 request return 出去的就是个 Promise 对象）；</li><li>Promise 中拿到的<span style="color: #0091ff"><u>返回的类型</u></span>应该是由请求者决定，所以使用<span style="color: #8c7be9"><strong>泛型</strong></span>。</li></ol><ul><li><ol><li>before：</li></ol><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218154123851.png" alt="image-20230218154123851"></p></li></ul><p>after：</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218154134102.png" alt="image-20230218154134102"></p><ul><li><ol><li>相应的，接口处调用 request 时指定一个<span style="color: #0091ff">输入类型</span>。（<strong>存疑</strong>，预计不是最终形式）</li></ol></li></ul><pre><code>// 接口处为promise的返回泛型指定一个输入类型：interface DataType &#123;  data: any;  returnCode: string;  success: boolean;&#125;request.request&lt;DataType&gt;(&#123;  url: LoginApi.AccountLogin,  method: &quot;get&quot;,  data: account, //data是放在account中的&#125;).then((res) =&gt; &#123;    //此处res就会是DataType类型，并且有很好的提示：    console.log(&#39;&#39;, res);&#125;);</code></pre><ol start="4"><li><p>使用 Promise 后要把 res 结果 <code>resolve</code> 返回出去：<code>resolve(res);</code> ；以及 <code>reject</code> 也是。</p><ul><li><span style="color: #ff0001"><strong>引出的问题</strong></span>：提示<span style="color: #0091ff">要求 res 是 <code>AxiosResponse</code> 类型</span>，<span style="color: #ff0001">而这里是 <code>&lt;T&gt;</code></span>（res 的类型是跟着 request 的）。</li></ul></li></ol><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218154538075.png" alt="image-20230218154538075"></p><ul><li><span style="color: #0091ff"><strong>解决</strong></span>：<span style="background-color: #ebf5ff;">既然被推导错了，则<span style="color: #3850b8">直接指定 request 为 &lt;any, T&gt;</span></span>（指定时需要注意要求有两个泛型）。<ul><li><strong>PS</strong>：由于 AxiosResponse 要从<span style="color: #3850b8"><code>.data</code></span>中获取数据，而之前对 AxiosResponse 类型做过转化 → 赋值已是<span style="color: #3850b8"><code>res.data</code></span>，所以此时 instance 实例的 request 类型根本不是提示中的 AxiosResponse 类型了，这里被<span style="color: #ff0001">推导错了</span>，应该就是 <code>&lt;T&gt;</code> 。</li></ul></li></ul><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218154928398.png" alt="image-20230218154928398"></p><p><span style="color: #CC0000"><strong>注意</strong></span>：request 的泛型中有<span style="color: #CC0000">两个</span>：<code>T、AxiosResponse&lt;T&gt;</code>👇🏻，要改的是后者。</p><p><img src="https://note.youdao.com/yws/res/24754/WEBRESOURCEcd1d5151294312cd7f2c6d9bf9188bce" alt="0"></p><ul><li><p>（<strong>临时，S2 中已改</strong>）上面图中提到被注释的那行有问题， 暂时将响应拦截器类型改为 any👇🏻：</p><ul><li>utils/request/type.ts：</li></ul></li></ul><pre><code>// responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse; //由于request类型被推导后为其指定了泛型，为处理res的那行代码正常使用所以本行暂时改为：  responseInterceptor?: (res: any) =&gt; any;</code></pre><p><span style="color: #E95200"><strong>PS</strong></span>：</p><ul><li>以上（指 4.3 小节）是为发送请求时清楚拿到的<code>res的类型</code>是什么所做的处理；</li><li>这部分代码可以再参考 👉🏻 <a href="https://github.com/jekip">jekip</a> 封装的方式：<a href="https://github1s.com/jekip/naive-ui-admin/blob/HEAD/src/utils/http/axios/Axios.ts">https://github1s.com/jekip/naive-ui-admin/blob/HEAD/src/utils/http/axios/Axios.ts</a> （53 行、72 行）</li></ul><h4 id="S2-更改响应拦截器的类型：-（最终版）"><a href="#S2-更改响应拦截器的类型：-（最终版）" class="headerlink" title="S2. 更改响应拦截器的类型： （最终版）"></a>S2. 更改响应拦截器的类型： （最终版）</h4><ul><li>上面提到实例的<code>request</code>被推导错误遂将其指定为<code>&lt;any, T&gt;</code>类型，并暂时将 res 的处理代码注释了，之后又暂时将响应拦截器类型设为<code>any</code>（因为得有 res 的处理但这只是临时的权宜之计 👇🏻）。</li></ul><pre><code>//  响应拦截：// responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse; //由于request类型被推导后为其指定了泛型，为处理res的那行代码正常使用所以本行暂时改为：responseInterceptor?: (res: any) =&gt; any;</code></pre><ol><li>给接口<code>SelfRequestConfig</code>和接口<code>AxiosRequestInterceptors</code>添加泛型&amp;默认值<code>AxiosResponse</code>。<ul><li>当接口中的方法的类型是不确定的，则需要<span style="background-color: #ebf5ff;">将其类型提到接口上</span><u>（接口可以加泛型，但里面不行</u>），<span style="background-color: #ebf5ff;">这样里面的属性就可以使用泛型了</span>。</li></ul></li></ol><pre><code>// 给接口使用泛型 &amp; 给默认值（否则23行使用该接口时会报错）：export interface AxiosRequestInterceptors&lt;T = AxiosResponse&gt; &#123;  // 可以有四个interceptor:  //  当interceptor传进来后，会被放进request实例中(看17行的使用)；拦截器参数config的类型就是AxiosRequestConfig，其返回值也是AxiosRequestConfig。  requestInterceptor?: (config: AxiosRequestConfig) =&gt; AxiosRequestConfig;  requestInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型  //  响应拦截：  // responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse; //由于request类型被推导后为其指定了泛型，为处理res的那行代码正常使用所以本行暂时改为下一行：  // responseInterceptor?: (res: any) =&gt; any;   // 临时更改；最后改为下一行：  responseInterceptor?: (res: T) =&gt; T;  responseInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型&#125;</code></pre><ol start="2"><li><p>再结合<strong>S1.</strong> 中提到的<code>res的T类型与要求的AxiosResponse不符</code>，要做的是使 AxiosResponse 类型改为 T 类型。<span style="color: #ff0001"><strong>改的方法是</strong></span>：</p><ul><li>将 T 类型传至<code>SelfRequestConfig</code>接口中，再由它传至<code>AxiosRequestInterceptors</code>的类型中（因为<code>SelfRequestConfig</code>的<code>interceptors</code>属性使用了该接口），这时 <code>AxiosResponse</code> 类型就被改为 <code>T</code> 类型了。</li></ul></li></ol><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218155822404.png" alt="image-20230218155822404"></p><ul><li><span style="color: #CC0000"><strong>总之关键点在于</strong></span>：将<code>request</code>的参数<code>config</code>的类型<code>SelfRequestConfig</code>也加上泛型<code>&lt;T&gt;</code>，使其逐步传递至嵌套的接口中最后被识别为 T 泛型，因为 👇🏻 使用的就是 T 类型：</li></ul><pre><code>res = config.interceptors.responseInterceptor(res);</code></pre><ul><li><p>这时<strong>该泛型传递的顺序</strong>：<span style="color: #FFB700">SelfRequestConfig  </span>=》<span style="color: #FFB700">SelfRequestConfig</span> =》<span style="color: #FFB700">SelfRequestConfig 中的 interceptors</span> =》<span style="color: #FFB700">AxiosRequestInterceptors 中的 responseInterceptor </span>。</p></li><li><p><strong>最后这一块的代码</strong>：</p><ul><li><p>utils/request.index：</p><pre><code>request&lt;T&gt;(config: SelfRequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    //改用return Promise的方式；注意不再是void类型而是promise👆🏻。    // 注意：promise拿到结果的类型应该是由请求者决定，所以使用泛型👆🏻。    return new Promise((resolve, reject) =&gt; &#123;      //config类型要先换成扩展后的      // // 方式1. 将config这里转化一下(transformRequest是本来就有提供的)：      // this.instance.request(&#123; ...config, transformRequest &#125;).then((res) =&gt; &#123;      //   console.log(&quot;res&quot;, res);      // &#125;);      // 方式2. 当👇🏻存在时，使用config.interceptors.requestInterceptor的方式转化：      if (config.interceptors?.requestInterceptor) &#123;        config = config.interceptors.requestInterceptor(config);      &#125;      // 判断是否需要显示loading：      if (config.showLoading === false) &#123;        this.showLoading = config.showLoading;      &#125;      this.instance        .request&lt;any, T&gt;(config)        .then((res) =&gt; &#123;          // 也可以对响应结果做处理：          //  1. 单个请求对数据的处理：          if (config.interceptors?.responseInterceptor) &#123;            // 转换res:            res = config.interceptors.responseInterceptor(res);          &#125;          // 将showLoading设置为true，避免影响下一个请求：          this.showLoading = true;          console.log(&quot;res&quot;, res);          resolve(res);        &#125;)        .catch((err) =&gt; &#123;          // 将showLoading设置为true，避免影响下一个请求：          this.showLoading = true;          reject(err);          return err;        &#125;);    &#125;);  &#125;</code></pre></li><li><p>utils/request/types：</p></li></ul><pre><code>export interface AxiosRequestInterceptors&lt;T = AxiosResponse&gt; &#123;  // 可以有四个interceptor:  //  当interceptor传进来后，会被放进request实例中(看17行的使用)；拦截器参数config的类型就是AxiosRequestConfig，其返回值也是AxiosRequestConfig。  requestInterceptor?: (config: AxiosRequestConfig) =&gt; AxiosRequestConfig;  requestInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型  //  响应拦截：  // responseInterceptor?: (res: AxiosResponse) =&gt; AxiosResponse; //由于request类型被推导后为其指定了泛型，为处理res的那行代码正常使用所以本行暂时改为下一行：  // responseInterceptor?: (res: any) =&gt; any;   // 临时更改；最后改为下一行：  responseInterceptor?: (res: T) =&gt; T;  responseInterceptorCatch?: (err: any) =&gt; any; //错误拦截；any类型&#125;// 对原本的AxiosRequestConfig做扩展，使其可以做到传递一些hooks拦截器：// 很多地方使用到了SelfRequestConfig，可能会被单独使用到，最好给它也指定泛型和默认值：export interface SelfRequestConfig&lt;T = AxiosResponse&gt;  extends AxiosRequestConfig &#123;  interceptors?: AxiosRequestInterceptors&lt;T&gt;; //继承AxiosRequestConfig后，给它添加一个interceptor扩展。  showLoading?: boolean;&#125;</code></pre></li></ul><h3 id="4-4-其它完善-（略）"><a href="#4-4-其它完善-（略）" class="headerlink" title="4.4 其它完善 （略）"></a>4.4 其它完善 （略）</h3><ul><li><p>在请求时可能不只有 request 形式的，或许会有 get、post 等。</p><ul><li><p>所以继续在封装处添加 👇🏻： （本段未写在项目代码中…）</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230218160230231.png" alt="image-20230218160230231"></p></li><li><p>由于<strong>4.3 小节 S2.</strong> 中对 SelfRequestConfig 类型加了，所以此处也要加上 👇🏻：</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230219115404141.png" alt="image-20230219115404141"></p></li></ul></li></ul><h2 id="5-划分模块"><a href="#5-划分模块" class="headerlink" title="5. 划分模块"></a>5. 划分模块</h2><ul><li>根据页面划分不同文件夹。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;span style=&quot;color: #8c7be9&quot;&gt;大致步骤&lt;/span&gt;👇🏻（PS：过程中的代码可能不是最终的，可以在后面看最终的总结及代码。）&lt;/p&gt;
&lt;h2 id=&quot;1-封装-axios-实例&quot;&gt;&lt;a href=&quot;#1-封装-axios-实例&quot; class=</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/categories/TypeScript/"/>
    
    
    <category term="Axios" scheme="https://polariis.gitee.io/tags/Axios/"/>
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/tags/TypeScript/"/>
    
    <category term="封装" scheme="https://polariis.gitee.io/tags/%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>关于TS中描述Object类型的两种方式（类型签名和Record）</title>
    <link href="https://polariis.gitee.io/posts/61dca9cf/"/>
    <id>https://polariis.gitee.io/posts/61dca9cf/</id>
    <published>2022-12-10T08:18:02.000Z</published>
    <updated>2023-05-20T02:13:43.613Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong> ：由于 Object 的范围很大，对象中属性可能是任意类型，而这时区分不出一个 Object 具体是什么类型。</p><p>所以一般不在 TS 中直接使用 Object 类型，而是以下两种方式描述对象：</p><ol><li><strong>class / constructor</strong>；</li><li><strong>type</strong>或<strong>interface</strong>，推荐用这种，更灵活。</li></ol><h2 id="方式一：类型签名"><a href="#方式一：类型签名" class="headerlink" title="方式一：类型签名"></a>方式一：类型签名</h2><p>举例 1：</p><pre><code>type Obj = &#123;    [K: string]: number  //代表Obj中有一个字符串类型属性（具体属性名可以随便取只要是字符串就可），其属性值是数字。&#125;</code></pre><ul><li><ul><li>使用上有个共识，如果是泛型使用大写 K；若非泛型，是用小写 k。</li></ul></li></ul><p>上例基础上举例 2：</p><pre><code>type Obj = &#123;    [K: string]: number&#125;const a: Obj = &#123;    name: 1    123： 6  //虽然使用type规定了属性名为string，而这里写了数字，但会编译通过。&#125;</code></pre><ul><li><ul><li>例子中属性名的命名为数字编译会通过，是因为在 JS 层面：所有属性名最终被都是字符串形式。</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230211093401215.png" alt="image-20230211093401215"></h2><p>由例 2 引申的例 3：JS 中<strong>一个矛盾的情况</strong>。 （👈🏻 看下面的总结，number 类型也可以）</p><pre><code>type Obj = &#123;    [K: number]: number   //注意看这里，给属性名规定为number类型。&#125;const a: Obj = &#123;    name: 1   //这里无法编译通过，因为JS中所有key都是字符串（string或symbol）。    123： 6   //奇怪的在这行，既然key只能字符串但这里number居然编译通过了！！！！！&#125;</code></pre><ul><li><ul><li><strong>PS</strong>：<strong>当 symbol 作为 key</strong>，必须<strong>用中括号包</strong>一下。</li><li>这篇文章中提到了这个情况：<a href="https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html#typescript-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D">深入理解 TS——签名索引</a></li></ul></li></ul><p>-</p><p>综上，<strong>总结</strong>：</p><ul><li><p>对象中 key 的类型可以不是 string 吗？</p></li><li><ul><li>还可以是 symbol 或 number。</li></ul></li></ul><h2 id="方式二：Record"><a href="#方式二：Record" class="headerlink" title="方式二：Record"></a>方式二：Record</h2><p>其余待整理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt; ：由于 Object 的范围很大，对象中属性可能是任意类型，而这时区分不出一个 Object 具体是什么类型。&lt;/p&gt;
&lt;p&gt;所以一般不在 TS 中直接使用 Object 类型，而是以下两种方式描述对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/categories/TypeScript/"/>
    
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>类class（JS &amp; TS）</title>
    <link href="https://polariis.gitee.io/posts/ba1dc77a/"/>
    <id>https://polariis.gitee.io/posts/ba1dc77a/</id>
    <published>2022-11-12T08:47:53.000Z</published>
    <updated>2023-05-20T02:13:43.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h2><ul><li>使用class关键字；</li><li>在严格模式下，需要给属性初始化。</li><li>直接初始化，或在constructor中初始化都可以。</li></ul><pre><code>class Person &#123;    name: string = &#39;&#39;,  //1.直接初始化    age: number = 0,    // 2.也可以这样：在执行构造器时要求传进参数初始化：    constructor(name: string, age: number) &#123;        this.name = name;        this.age = age        &#125;    // 类中可以定义方法：    eating() &#123;        console.log(this.name + &#39;~&#39;);    &#125;&#125;const p = new Person(&#39;lwl&#39;, 24);  // 这里会执行类的constructorp.eating();   //调用类中定义的方法</code></pre><p><strong>PS</strong>：在TS中删去了动态属性的使用，例如👆🏻第2&amp;3行代码如果不写，constructor里的赋值会报错，而非添加属性，这时会找不到该属性。</p><h2 id="2-类的继承-extends"><a href="#2-类的继承-extends" class="headerlink" title="2. 类的继承 extends"></a>2. 类的继承 extends</h2><ul><li>当两个类有部分相同的属性，可以专门定义一个类抽进去。</li></ul><pre><code>class Person &#123;    name: string = &#39;&#39;,    age: number = 0    eating() &#123;        console.log(&#39;eat&#39;);        &#125;&#125;// 继承上面类中的属性：class Student extends Person &#123;    sId: number = 0    study() &#123;        console.log(&#39;study&#39;);        &#125;&#125;class Teacher extends Person &#123;    title: string = &#39;&#39;,    teach() &#123;        console.log(&#39;teach&#39;);    &#125;&#125;const stu =  new Student();stu.name = &#39;lwl&#39;;stu.age = 24;console.log(stu.name);console.log(stu.age);stu.eating();    // 会发现继承后，stu也能调到eating方法。</code></pre><h3 id="2-1-constructor-super"><a href="#2-1-constructor-super" class="headerlink" title="2.1 constructor super"></a>2.1 constructor super</h3><ul><li>super可以调用父类的构造器；</li><li></li><li>应该是创建某个对象时就初始化，</li></ul><pre><code>class Person &#123;    name: string    age: number        constructor(name: string, age: number) &#123;        this.name = name        this.age = age        &#125;        eating() &#123;        console.log(&#39;eat&#39;);        &#125;&#125;class Student extends Person &#123;    sId?: number        // 当有一项不用传时，需要写为可选类型：    constructor(name: string, age: number) &#123;        //super关键字可以调用到父类的        super        this.sid = sid;        &#125;        study() &#123;        console.log(&#39;study&#39;);        &#125;&#125;</code></pre><h2 id="3-TS中类的使用"><a href="#3-TS中类的使用" class="headerlink" title="3. TS中类的使用"></a>3. TS中类的使用</h2><p>三个<strong>访问修饰符</strong>：</p><ul><li>public：公有。</li><li>private：外部不能访问。</li><li>protected，与private的区别是：在子类中可以访问到。</li></ul><h3 id="3-1-类实现接口"><a href="#3-1-类实现接口" class="headerlink" title="3.1 类实现接口"></a>3.1 类实现接口</h3><p>当不同的类中有相同的方法，可以将它们提取为接口，并利用**<code>implements</code>**关键字实现。</p><p>使用示例：<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a></p><h3 id="3-3-接口继承类"><a href="#3-3-接口继承类" class="headerlink" title="3.3 接口继承类"></a>3.3 接口继承类</h3><p>PS：类继承接口未记录。</p><p>先看一个例子</p><ul><li>在TS中，接口可以继承类（JS中没有这种用法）。</li><li>声明一个类的同时，它也将是一个类型。</li></ul><pre><code>class Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;// 等价于上面的Point，因为Point同时可以当作一个TS类型：interface PointInstanceType &#123;    x: number;    y: number;&#125;function printPoint(p: PointInstanceType) &#123;    console.log(p.x, p.y);&#125;printPoint(new Point(1, 2));</code></pre><hr><p>待补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类的定义&quot;&gt;&lt;a href=&quot;#1-类的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 类的定义&quot;&gt;&lt;/a&gt;1. 类的定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用class关键字；&lt;/li&gt;
&lt;li&gt;在严格模式下，需要给属性初始化。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的操作符</title>
    <link href="https://polariis.gitee.io/posts/122feaea/"/>
    <id>https://polariis.gitee.io/posts/122feaea/</id>
    <published>2022-11-06T11:36:00.000Z</published>
    <updated>2023-02-15T14:53:52.172Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h2 id="和"><a href="#和" class="headerlink" title="!! 和 ??"></a>!! 和 ??</h2></li></ol><h3 id="1-1-的含义："><a href="#1-1-的含义：" class="headerlink" title="1.1  !!的含义："></a>1.1  !!的含义：</h3><ul><li><p>在JS中，当想把一个数据<strong>转为布尔类型</strong>时：</p></li><li><ul><li>可以直接<strong>取反</strong>，这样返回的就是布尔类型；但这样值也就反了，所以<strong>再取反</strong>得到正确的值。</li></ul></li><li><p>类似于 Boolean(变量) 的方式。</p></li></ul><h3 id="1-2-空值合并操作符："><a href="#1-2-空值合并操作符：" class="headerlink" title="1.2  ??  空值合并操作符："></a>1.2  ??  空值合并操作符：</h3><ul><li><p>ES11的新特性；</p></li><li><p>空值合并操作符是一个逻辑运算符。当左侧为null / undefined时返回右侧值；否则返回左侧值。</p></li><li><ul><li><span style="background-color: #f2f4f5;">相当于在null时返回一个默认值</span>，而不是直接返回null。</li></ul></li><li><p>看以下<strong>对比</strong>：</p><pre><code>// 当这里赋值为null时：let message: string | null = null;// 这里会返回该值：//let message: string | null ac &#39;有值，返回吧&#39;;  const content = message ?? &#39;左侧为null所以返回我&#39;;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;和&quot;&gt;&lt;a href=&quot;#和&quot; class=&quot;headerlink&quot; title=&quot;!! 和 ??&quot;&gt;&lt;/a&gt;!! 和 ??&lt;/h2&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-1-的含义：&quot;&gt;&lt;a href=&quot;#1-1-的含义：&quot; class=</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vuex4 &amp; 结合TS的特殊处理</title>
    <link href="https://polariis.gitee.io/posts/2c9a25cc/"/>
    <id>https://polariis.gitee.io/posts/2c9a25cc/</id>
    <published>2022-10-23T12:15:09.000Z</published>
    <updated>2023-02-15T14:53:52.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关于vuex4"><a href="#1-关于vuex4" class="headerlink" title="1. 关于vuex4"></a>1. 关于vuex4</h2><p>store/index.js文件：</p><ol><li>调用<code>createStore</code>创建仓库，它里面传入的是一个对象；</li><li>createStore会接收一个泛型，</li></ol><pre><code>// 先引入：import &#123; createStore &#125; from &#39;vuex&#39;;const store = createStore(&#123;    state() &#123;        // 最终要返回个对象：        return &#123;            //         &#125;        &#125;    &#125;)</code></pre><h3 id="1-1-在组件中使用："><a href="#1-1-在组件中使用：" class="headerlink" title="1.1 在组件中使用："></a>1.1 在组件中使用：</h3><p><strong>使用步骤</strong>： </p><ol><li><p>先引入vuex的<code>useStore</code>；</p></li><li><p>获取到<code>useStore</code> ；</p></li><li><p>调用其中的<code>dispatch</code>，同时传递<strong>两个参数</strong>：</p></li><li><ol><li>什么操作；</li><li>传递的值。</li></ol></li></ol><pre><code>import &#123; useStore &#125; from &quot;vuex&quot;;const store = useStore()；// 调用dispatch，同时传递两个参数：什么操作、传递的值：store.dispatch();</code></pre><h2 id="2-TS的相关支持"><a href="#2-TS的相关支持" class="headerlink" title="2. TS的相关支持"></a>2. TS的相关支持</h2><h3 id="2-1-对useStore的处理"><a href="#2-1-对useStore的处理" class="headerlink" title="2.1 对useStore的处理"></a>2.1 对useStore的处理</h3><ul><li><p>vuex4版本对TS的支持不够完善，其中一点体现在<code>useStore</code>上。</p></li><li><ul><li>在组件中正常引入<code>useStore</code>使用时，state 是 any 类型也意味着这里缺少类型检测，所以在取store的子模块时会出现报错。</li><li>例：</li></ul></li></ul><pre><code>import &#123; useStore &#125; from &quot;vuex&quot;;const store = useStore();const userMenu = store.state.login.userMenu;    // login报错</code></pre><ul><li><p><strong>解决</strong>：给<code>useStore</code>做了更改：</p></li><li><ul><li>Step1. 在 store/index.ts文件：</li></ul></li></ul><pre><code>/* 引入时顺便起别名因为自定义的也叫这个： *///     其中Store是vuex提供的一个类型：import &#123; createStore, Store, useStore as useVuexStore &#125; from &quot;vuex&quot;; export function useStore(): Store&lt;IStoreType&gt; &#123;  // 将vuex的useStore起别名后再return出去，而在这个过程中已经给它明确制定了类型：  return useVuexStore();&#125;</code></pre><ul><li><ul><li>Step2. 加类型，store/types.ts：</li></ul></li></ul><pre><code>import &#123; ILoginState &#125; from &quot;./modules/types&quot;;export interface IRootStore &#123;  name: string;  age: number;&#125;// 定义root中的module的类型：export interface IRootModule &#123;  login: ILoginState;&#125;// 规定为交叉类型：export type IStoreType = ILoginState &amp; IRootModule;</code></pre><ul><li>之后在使用useStore时就使用自己处理过的👆🏻。</li></ul><h3 id="2-2-每个module的类型-amp-传入的泛型"><a href="#2-2-每个module的类型-amp-传入的泛型" class="headerlink" title="2.2 每个module的类型&amp;传入的泛型"></a>2.2 每个module的类型&amp;传入的泛型</h3><ul><li><p>注意vuex4与TS类型的配合使用：</p></li><li><ol><li>首先<strong>每个模块的类型是Module</strong>；</li><li>而<strong>Modules****要传入两个泛型</strong>：<strong>S和R</strong>，（因为没有默认值）。</li></ol></li><li><ul><li><ul><li><strong>S指当前模块的state类型</strong>；</li><li><strong>R指根模块中的类型</strong>。 </li></ul></li></ul></li></ul><p>源码处：</p><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230214233106450.png" alt="image-20230214233106450"></p><p>store/modules/login.ts：</p><pre><code>import &#123; Module &#125; from &quot;vuex&quot;; // 为了与TS结合使用，使用vuex4时需要从vuex中引入Modules。import &#123; ILoginState &#125; from &quot;./types&quot;;import &#123; IRootStore &#125; from &quot;../types&quot;;// 划分模块后，每个模块中Module都要有两个泛型，分别代表：当前模块和根模块的state类型。const loginModule: Module&lt;ILoginState, IRootStore&gt; = &#123;  namespaced: true,  state() &#123;    return &#123;      token: &quot;&quot;,      userInfo: &#123;&#125;    &#125;;  &#125;,  getters: &#123;&#125;,  mutations: &#123;&#125;,  actions: &#123;    // action中的函数接收两个参数：上下文、value：    accountLoginAction(&#123; commit &#125;, payload: any) &#123;      console.log(&quot;执行accountLoginAction&quot;, payload);      // 1. 登录逻辑，发送请求：    &#125;  &#125;&#125;;export default loginModule;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-关于vuex4&quot;&gt;&lt;a href=&quot;#1-关于vuex4&quot; class=&quot;headerlink&quot; title=&quot;1. 关于vuex4&quot;&gt;&lt;/a&gt;1. 关于vuex4&lt;/h2&gt;&lt;p&gt;store/index.js文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;c</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/categories/TypeScript/"/>
    
    <category term="vuex4" scheme="https://polariis.gitee.io/categories/TypeScript/vuex4/"/>
    
    
    <category term="TypeScript" scheme="https://polariis.gitee.io/tags/TypeScript/"/>
    
    <category term="vuex" scheme="https://polariis.gitee.io/tags/vuex/"/>
    
    <category term="vue3" scheme="https://polariis.gitee.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>JSX基本语法&amp;使用</title>
    <link href="https://polariis.gitee.io/posts/69b0741a/"/>
    <id>https://polariis.gitee.io/posts/69b0741a/</id>
    <published>2022-10-16T12:55:38.000Z</published>
    <updated>2023-02-15T14:53:52.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JSX文档：<a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">https://zh-hans.reactjs.org/docs/introducing-jsx.html</a></p><p>PS：我只记录了一些注意点，前置的使用示例&amp;语法未在本篇笔记中。</p></blockquote><h1 id="1-jsx使用配置"><a href="#1-jsx使用配置" class="headerlink" title="1. jsx使用配置"></a>1. jsx使用配置</h1><ul><li><p><strong>babel配置</strong> ：</p><ul><li><p>安装Bable支持的<span style="color: #0091ff"> Vue的jsx插件</span>：</p><pre><code>npm install @vue/bable-plugin-jsx -D</code></pre></li></ul></li><li><p>在<span style="color: #0091ff"><code>bable.config.js</code></span>配置文件中<span style="color: #0091ff">配置插件</span>：</p><p>​    <img src="data:image/png;base64,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" alt="0"></p></li><li><p><span style="color: #0091ff">jsx中赋值变量</span>时要使用大括号：<span style="color: #3850b8"><strong><code>&#123;&#125;</code></strong></span></p><p> <img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230212192626262.png" alt="image-20230212192626262"></p></li><li><p><span style="color: #0091ff"><strong>插槽的使用</strong></span>：</p></li><li><ul><li>双括号代表：外层代表函数；里层的代表是对象形式。</li></ul></li><li><p><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230212192940925.png" alt="image-20230212192940925"></p></li><li><p><strong>优势</strong>：</p></li><li><ul><li>可以在里面任意写JS的代码👆🏻。</li></ul></li><li><p><strong>使用场景</strong>：</p></li><li><ul><li>封装组件库时可以使用。</li></ul></li></ul><hr><h2 id="2-语法-amp-注意点"><a href="#2-语法-amp-注意点" class="headerlink" title="2. 语法&amp;注意点"></a>2. 语法&amp;注意点</h2><ol><li><p>元素属性名使用<span style="color: #0091ff"><strong>驼峰</strong></span>命名法： （例👇🏻marginLeft属性）</p><pre><code>const renderDom = (  &lt;&gt;    &lt;n-button onClick=&#123;handleEditIncluded.bind(this, record, &#39;&#39;)&#125;&gt;&#123;text&#125;&lt;/n-button&gt;    &lt;n-button      v-show=&#123;record.join_status === 1&#125;      onClick=&#123;handleEditIncluded.bind(this, record, &#39;editRoleBtn&#39;)&#125;      style=&#123;&#123; marginLeft: '5px' &#125;&#125;    &gt;      更改入驻GS    &lt;/n-button&gt;  &lt;/&gt;);</code></pre></li><li><p>变量使用<span style="color: #CC0000">{ }</span>包裹。</p></li><li><p>添加样式时：class用<span style="color: #CC0000">className</span>替换（因为class在JS中是关键字）。</p></li></ol><h3 id="2-1-常用指令在JSX的写法"><a href="#2-1-常用指令在JSX的写法" class="headerlink" title="2.1 常用指令在JSX的写法"></a><strong>2.1</strong> 常用指令在JSX的写法</h3><ul><li><p>template常用指令：v-if、v-for、v-modal等指令在JSX无法使用。所以要注意一下写法：</p></li><li><ul><li><p>innerHTML <span style="color: #FFB700">=》</span>domProps</p></li><li><p>v-if <span style="color: #FFB700">=》</span>三目运算符或if判断</p></li><li><p>v-for <span style="color: #FFB700">=》</span>maps</p></li><li><p>v-modal <span style="color: #FFB700">=》</span>vue-cli4默认集成了 JSX 对 v-model 的支持，老项目可以安装插件<code>babel-plugin-jsx-v-model</code> </p></li><li><p>监听事件（click、change） <span style="color: #FFB700">=》</span>用bind或箭头函数传参</p></li><li><p>事件修饰符：</p></li><li><ul><li>.stop阻止事件冒泡 <span style="color: #FFB700">=》</span>event.stopPropagation()</li><li>.prevent阻止默认行为 <span style="color: #FFB700">=》</span>event.preventDefault()</li><li>.self当事件从侦听器绑定的元素本身触发时才触发回调 =》使用条件判断</li></ul></li><li><p>更多：<a href="https://juejin.cn/post/7018742119082754062#heading-3">https://juejin.cn/post/7018742119082754062#heading-3</a></p></li></ul></li></ul><p>一些示例：</p><pre><code>// v-html或v-text：render() &#123;    const &#123; htmlCode &#125; = this    return (        &lt;div&gt;            &lt;div domPropsInnerHTML=&#123;htmlCode&#125;&gt;&lt;/div&gt;        &lt;/div&gt;    );   &#125;// 点击事件：methods: &#123;    handleClick(val)&#123;        alert(val)    &#125;  &#125;,&lt;button type=&quot;button&quot; onClick=&#123;this.handleClick.bind(this, 11)&#125;&gt;点击bind&lt;/button&gt;&lt;button type=&quot;button&quot; onClick=&#123;() =&gt; this.handleClick(11)&#125;&gt;点击箭头函数&lt;/button&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JSX文档：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/introducing-jsx.html&quot;&gt;https://zh-hans.reactjs.org/docs/introducing-jsx.html&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="JSX" scheme="https://polariis.gitee.io/tags/JSX/"/>
    
  </entry>
  
  <entry>
    <title>JS获取视频任意进度</title>
    <link href="https://polariis.gitee.io/posts/5ced3654/"/>
    <id>https://polariis.gitee.io/posts/5ced3654/</id>
    <published>2022-09-15T16:00:00.000Z</published>
    <updated>2023-02-06T18:43:24.673Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>利用视频的<span style="color: #0091ff;background-color: #f2f4f5;"> duration </span>获取视频相关信息。</p></li><li><p>利用<span style="color: #0091ff;background-color: #f2f4f5;"> addEventListener </span>事件监听的相关事件👇🏻，可以获取各个播放进度&amp;在不同阶段操作数据。</p><ul><li><span style="color: #678f00">play</span>： 视频开始播放 。</li><li><span style="color: #678f00">playing</span>： 视频播放过程中 。</li><li><span style="color: #678f00">ended</span>： 视频结束播放 。</li><li><span style="color: #678f00">loadedmetadata </span>事件： 音频/视频的元数据已加载时（时长、尺寸（仅视频）以及文本轨道）。</li></ul></li><li><p>当 音频/视频 处于加载过程中时，会 依次发生 以下事件：</p></li><li><ol><li><span style="color: #3850b8">loadstart</span></li><li><span style="color: #3850b8">durationchange</span></li><li><span style="color: #3850b8">loadedmetadata</span></li><li><span style="color: #3850b8">loadeddata</span></li><li><span style="color: #3850b8">progress</span></li><li><span style="color: #3850b8">canplay</span></li><li><span style="color: #3850b8">canplaythrough</span></li></ol></li></ul><p><span style="color: #CC0000">1.</span> 在视频第6秒时显示一个按钮：</p><pre><code>    function videoInit() &#123;      let elevideo = document.getElementById(&#39;video2&#39;);      elevideo.addEventListener(&#39;loadedmetadata&#39;, () =&gt; &#123;        //视频的总长度        console.log(&#39;总长度:&#39;, elevideo.duration);        clearInterval(this.timer);      &#125;);            elevideo.addEventListener(&#39;play&#39;, () =&gt; &#123;        //播放开始执行的函数        console.log(&#39;开始播放&#39;);      &#125;);            elevideo.addEventListener(&#39;playing&#39;, () =&gt; &#123;        //播放中        console.log(&#39;播放中&#39;);        this.timer = setInterval(() =&gt; &#123;          console.log(&#39;播放进度:&#39; + parseFloat(elevideo.currentTime));          if (parseInt(elevideo.currentTime) === 6) &#123;            const btn = document.querySelector(&#39;.main-button&#39;)            btn.classList.remove(&#39;main-button-hide&#39;)          &#125;        &#125;, 100);      &#125;);            elevideo.addEventListener(&#39;ended&#39;, () =&gt; &#123;        //结束        console.log(&#39;播放结束&#39;);        clearInterval(this.timer);      &#125;,false);          &#125;;    videoInit();</code></pre><p><span style="color: #CC0000">2.</span> 改进：</p><pre><code>      eleVideo.addEventListener(&#39;playing&#39;, () =&gt; &#123;        //播放中        console.log(&#39;播放中&#39;);        const timer = setInterval(() =&gt; &#123;          console.log(&#39;播放进度:&#39; + parseFloat(eleVideo.currentTime));          if (Math.round(eleVideo.currentTime) === 6) &#123;            const btn = document.querySelector(&#39;.main-button&#39;)            btn.classList.remove(&#39;main-button-hide&#39;)          &#125;          if (eleVideo.currentTime &gt; 6) &#123;            console.log(&#39;结束监听&#39;);            clearInterval(timer);          &#125;        &#125;, 1000);      &#125;);</code></pre><p><span style="color: #CC0000">3.</span> 改进使用video的 currentTime 事件后：</p><pre><code>    function videoInit() &#123;      let eleVideo = document.getElementById(&#39;videoEl&#39;);      eleVideo.addEventListener(&#39;timeupdate&#39;, () =&gt; &#123;        console.log(&#39;播放中&#39;);        if (Math.round(eleVideo.currentTime) === 6) &#123;          console.log(&#39;第6秒了&#39;);          const btn = document.querySelector(&#39;.main-button&#39;)          btn.classList.remove(&#39;main-button-hide&#39;)        &#125;      &#125;)    &#125;;    videoInit();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用视频的&lt;span style=&quot;color: #0091ff;background-color: #f2f4f5;&quot;&gt; duration &lt;/span&gt;获取视频相关信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用&lt;span style=&quot;color: #</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS精度丢失&amp;解决</title>
    <link href="https://polariis.gitee.io/posts/7fcf66dd/"/>
    <id>https://polariis.gitee.io/posts/7fcf66dd/</id>
    <published>2022-09-06T12:01:50.000Z</published>
    <updated>2023-02-06T18:43:24.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>0.1 + 0.2 !== 0.3;</p></blockquote><p><span style="color: #0091ff"><strong>精度丢失的原因</strong></span>：</p><ul><li>计算机中所有的数据都是以<span style="color: #ff0001">二进制</span>存储的，所以在计算时计算机要把数据先转换成<span style="color: #ff0001">二进制</span>进行计算，然后在把计算结果转换成<span style="color: #ff0001">十进制</span>。</li><li><span style="color: #ff0001">二进制</span>计算发生了精度丢失，导致再转换成<span style="color: #ff0001">十进制</span>后和预计的结果不符。</li></ul><p><span style="color: #0091ff"><strong>解决</strong></span>：</p><p><span style="color: #0091ff">1.</span> 把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。</p><p>0.1 + 0.2；改为 (0.1<em>10 + 0.2</em>10) / 10 == 0.3；  // true</p><p><span style="color: #0091ff">2.</span> </p><p>。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;0.1 + 0.2 !== 0.3;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span style=&quot;color: #0091ff&quot;&gt;&lt;strong&gt;精度丢失的原因&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中所有的数据</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>重绘&amp;回流(重排)</title>
    <link href="https://polariis.gitee.io/posts/b4912e11/"/>
    <id>https://polariis.gitee.io/posts/b4912e11/</id>
    <published>2022-09-04T16:00:00.000Z</published>
    <updated>2023-02-06T18:43:24.709Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>重绘：repaint；</p><p>回流/重排：reflow。</p></blockquote><ul><li><span style="color: #0091ff">重绘</span>：不影响任何布局的style变化。<ul><li>color、text-align、a: hover、</li><li>重绘的速度会明显快于回流。</li></ul></li><li><span style="color: #0091ff">回流</span>：引起布局改变的style变化。<ul><li>长/宽/高、border、display、窗口大小、字体大小、margin/padding、动画、读取元素的属性（offsetLeft等）鼠标滑过/点击/scroll。</li><li>有些属性是避免不了会引起回流的，但有些可以优化掉。</li></ul></li></ul><p><strong>PS</strong>：</p><ul><li>回流必定引起重绘。因为布局改变 =》相应的样式也会重新渲染</li></ul><p><strong>减少重绘和回流的方式</strong>：</p><ol><li>不通过父级来改变子元素样式，最后直接设置子元素样式；</li><li>改变子元素样式尽量避免影响父元素&amp;兄弟元素的大小尺寸。</li><li>使用 transform 替代 top。</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局)。</li><li>防抖、节流。</li><li>尽量避免使用table布局。</li><li>避免一条一条的改变DOM样式</li><li>给动画的 HTML 元件使用 position: fixed 或 absoult，修改他们的CSS不会 reflow，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li><li>使用Flexbox布局模型比基于浮动的布局模型的性能更快</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;重绘：repaint；&lt;/p&gt;
&lt;p&gt;回流/重排：reflow。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color: #0091ff&quot;&gt;重绘&lt;/span&gt;：不影响任何布局的style变化。&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>Vue3语法变更总结</title>
    <link href="https://polariis.gitee.io/posts/97e721dd/"/>
    <id>https://polariis.gitee.io/posts/97e721dd/</id>
    <published>2022-08-24T07:55:35.000Z</published>
    <updated>2022-09-24T08:56:32.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生命周期的变更"><a href="#1-生命周期的变更" class="headerlink" title="1.生命周期的变更"></a>1.生命周期的变更</h2><ul><li><p>销毁的概念改为<strong>卸载</strong>，更名：</p><ul><li>beforeDestroy改名为<span style="background-color: #f2f4f5;color: darkblue;">beforeUnmounted</span>。</li><li>destroyed改名为<span style="background-color: #f2f4f5;color: darkblue;">unmounted</span>。</li></ul></li><li><p>vue2中的两次判断改为一次（如图）。</p><p><img src="https://s2.loli.net/2022/08/10/9kmtAb8YxeMSqQV.png" alt="image-20220810114820457"></p></li><li><p>Vue3提供的**<span style="color: #0089FB;">Composition API</span>**形式对比：</p><ul><li>beforeCreate     =&gt;     <span style="color: #E95200;">setup()</span></li><li>created     =&gt;     <span style="color: #E95200;">setup()</span></li><li>beforeMount     =&gt;     <span style="color: #E95200;">onBeforeMount</span></li><li>mounted         =&gt;     <span style="color: #E95200;">onMounted</span></li><li>beforeUpdate      =&gt;     <span style="color: #E95200;">onBeforeUpdate</span></li><li>updated         =&gt;     <span style="color: #E95200;">onUpdated</span></li><li>beforeUnmounted     =&gt;     <span style="color: #E95200;">onBeforeUnmounted</span></li><li>unmounted     =&gt;     <span style="color: #E95200;">onUnmounted</span></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p><ul><li>下图打印结果可以看到：setup中的<span style="color: #FFB700;">组合式API优先级更高</span>。</li></ul><img src="https://s2.loli.net/2022/08/10/c82bMyzlovfEU9j.png" style="zoom:80%;" /></li></ul><hr><h2 id="2-setup函数"><a href="#2-setup函数" class="headerlink" title="2. setup函数"></a>2. setup函数</h2><h3 id="2-1-setup的两个注意点："><a href="#2-1-setup的两个注意点：" class="headerlink" title="2.1 setup的两个注意点："></a>2.1 setup的两个注意点：</h3><ul><li><p><strong>setup执行时机</strong>：</p><ul><li>在beforeCreated之前执行一次，并且this是undefined。</li></ul></li><li><p><strong>setup接收两个参数</strong>：</p><ul><li><p>1.**<span style="color: #0089FB;">props</span>**：值为对象。包含：组件外部传递进来，且在组件内部声明接收了的属性。</p><ul><li>当子组件传了，父组件却没接收/接收少了，都会控制台警告。接收多了则会拿到undefined。</li></ul></li><li><ol start="2"><li><p>**<span style="color: #0089FB;">context</span>**：<span style="background-color: #E9E9E9;color: #0089FB;">上下文对象</span></p><ul><li><p>**<span style="color: #E95200;">attrs</span>**：值为对象。包含：组件外部传递过来但没有在props配置中生命的属性，相当于this.$attrs。</p></li><li><p>**<span style="color: #E95200;">slots</span>**：收到的插槽内容，相当于this.$slots。</p></li><li><p>**<span style="color: #E95200;">emit</span>**：分发自定义事件的函数，相当于this.$emit。</p></li></ul></li></ol></li></ul></li></ul><h3 id="2-2-setup语法糖"><a href="#2-2-setup语法糖" class="headerlink" title="2.2 setup语法糖"></a>2.2 setup语法糖</h3><ul><li> <span style="color: #E95200;"><code>&lt;script setup&gt;</code></span>是单文件组件使用组合式API（上面笔记代码中）的语法糖。里面的代码会被编译为setup函数的内容。</li><li>无需export default，里面也不用return。</li><li>官方文档描述：<a href="https://staging-cn.vuejs.org/guide/introduction.html#api-styles">https://staging-cn.vuejs.org/guide/introduction.html#api-styles</a></li></ul><p><strong>什么时候使用</strong><span style="color: #E95200;"><code>setup()</code></span>：</p><p><img src="https://s2.loli.net/2022/08/18/LVO2ayMNCs3rB5p.png" alt="image-20220818121239514"></p><hr><h3 id="2-3-其他补充"><a href="#2-3-其他补充" class="headerlink" title="2.3 其他补充"></a>2.3 其他补充</h3><h4 id="1-vue3中插槽的使用变更："><a href="#1-vue3中插槽的使用变更：" class="headerlink" title="1. vue3中插槽的使用变更："></a>1. vue3中插槽的使用变更：</h4><ul><li>在vue3中使用插槽尽量用<code>v-slot</code>。</li><li>vue2中template里使用插槽可以使用：1. <code>name=&quot;xxx&quot;</code>  2. <code>v-slot=&quot;xxx&quot;</code>  。但由于vue3的兼容问题，使用第一种方法依旧显示的是默认插槽，自定义插槽名会失效。</li></ul><h4 id="2-vue3中props接收数据："><a href="#2-vue3中props接收数据：" class="headerlink" title="2. vue3中props接收数据："></a>2. vue3中props接收数据：</h4><p><strong>vue2中props接收数据</strong>：</p><ul><li>如果不用props，在VC的实例对象中也能拿到，通过<code>this.$attrs</code>；但如果使用props后，attrs中的数据就会消失（attrs就像捡漏）。</li></ul><hr><h2 id="3-Ref"><a href="#3-Ref" class="headerlink" title="3. Ref"></a>3. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：<code>const xxx = ref(initValue)</code>  </p><ul><li>创建一个包含响应式数据的<span style="color: #ff0001;">引用对象（reference对象）</span>。</li><li>模板中使用引用对象不用后面加.value，而<span style="color: #CC0000;">setup中使用该值时需要加.value</span>。</li></ul></li><li><p><strong>接收的数据</strong>：</p><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">基本类型： 响应式</span></strong><span style="background-color: #f2f4f5;color: darkblue;">依旧使用是<strong>defineProperty</strong></span> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">对象类型</span></strong><span style="background-color: #f2f4f5;color: darkblue;">时使用<strong>proxy</strong>实现的</span>（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要<span style="color: #FFB700;"> .value</span> 是因为<span style="color: #FFB700;">Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化</span>。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p>**<span style="color: darkblue;">注意：</span><strong>如果要在setup中拿到DOM元素，声明的变量名<span style="color: #ff0001;">必须与元素中写的ref</span></strong><span style="color: #CC0000;">一致</span>**。</p><pre><code>&lt;template&gt;  &lt;div id=&quot;countBox&quot; ref=&quot;countupRef&quot;&gt;    &lt;span class=&quot;countSpan&quot;&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p>在**<span style="background-color: #f2f4f5;color: darkblue;">onMounted</span>**中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="4-reactive"><a href="#4-reactive" class="headerlink" title="4. reactive"></a>4. reactive</h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：<code>const 代理对象 = reactive(源对象);</code>  接收一个对象或数组，返回一个**<span style="color: #CC0000;">代理对象</span>**<span style="color: #ff0001;">（Proxy的实例对象，简称proxy对象）</span>。</p><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul><p><img src="https://s2.loli.net/2022/08/18/UschZL52Pi7kz81.png" alt="image.png"></p></li><li><p>reactive定义的响应式数据是”深层次的“。</p></li><li><p>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</p></li></ul><h2 id="5-ref对比reactive总结"><a href="#5-ref对比reactive总结" class="headerlink" title="5. ref对比reactive总结"></a><strong>5. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p><ul><li>ref定义：<span style="color: #ff0001;">基本类型数据</span>。</li><li>reactive定义：<span style="color: #ff0001;">对象/数组类型数据</span>。</li><li><span style="color: #0089FB;">注意</span>：ref也可以定义对象/数组类型数据，它内部会自动通过<code>reactive</code><span style="color: #ff0001;">转为代理对象</span>。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p><ul><li>ref：通过<span style="color: #CC0000;"><code>Object.defineProperty()</code></span>的<code>get</code>和<code>set</code>实现响应式（数据劫持）。</li><li>reactive：通过使用<span style="color: #CC0000;"><code>Proxy</code></span>实现响应式（数据劫持），并通过<span style="color: #CC0000;"><code>Reflect</code></span>操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p><ul><li>ref定义的数据：操作数据<span style="color: #CC0000;">需要</span>.value，读取数据时模板会直接读取<span style="color: #CC0000;">不用</span><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据<span style="color: #CC0000;">均不需要</span><code>.value</code>。</li></ul></li></ul><h2 id="6-Vue2-amp-Vue3响应式原理对比"><a href="#6-Vue2-amp-Vue3响应式原理对比" class="headerlink" title="6. Vue2&amp;Vue3响应式原理对比"></a><strong>6. Vue2&amp;Vue3响应式原理对比</strong></h2><h3 id="6-1-Vue2的响应式"><a href="#6-1-Vue2的响应式" class="headerlink" title="6.1 Vue2的响应式"></a>6.1 Vue2的响应式</h3><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</li><li><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。<ul><li>比如：调用push方法，其实调用的是vue2二次封装后的push。</li><li>这个push里做了两件事：<ul><li>1.帮助正常调用push方法。</li><li>2.帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre> <img src="https://s2.loli.net/2022/08/18/KywkVsvl6uzL3CS.png" alt="image.png" style="zoom: 67%;" /></li><li><p><strong>Object.defineProperty</strong>:</p><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="6-2-Vue3的响应式"><a href="#6-2-Vue3的响应式" class="headerlink" title="6.2 Vue3的响应式"></a><strong>6.2 Vue3的响应式</strong></h3><h4 id="6-2-1实现原理："><a href="#6-2-1实现原理：" class="headerlink" title="6.2.1实现原理："></a><strong>6.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p><ul><li><strong>Proxy</strong>： window上内置的，接收<strong>两个参数</strong>（<span style="color: #FFB700;">必填</span>）：<strong>1</strong>. target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的**<span style="color: #ff0001;">reflect</span>**。）</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><img src="https://s2.loli.net/2022/08/18/CiEjvBrpIYJAsm5.png" alt="image.png" style="zoom: 67%;" /><h4 id="6-2-2-响应式中Reflect的应用："><a href="#6-2-2-响应式中Reflect的应用：" class="headerlink" title="6.2.2. 响应式中Reflect的应用："></a>6.2.2. 响应式中<span style="color: #ff0001;">Reflect</span>的应用：</h4><ul><li><p><strong>ES6</strong>，**<span style="color: #0089FB;">Windows内置</span>**。</p></li><li><p>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</p></li><li><p>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</p></li></ul><p><strong>与Object.definProperty<span style="color: #CC0000;">对比</span>：</strong></p><ul><li><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></li><li><strong>模Vue3中实现响应式</strong>（使用<strong>reflect</strong><span style="color: #ff0001;">改进后</span>）：<ul><li>用到了proxy代理对象，及reflect反射对象。</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre><hr><h2 id="7-toRef-amp-toRefs"><a href="#7-toRef-amp-toRefs" class="headerlink" title="7. toRef &amp; toRefs"></a>7. toRef &amp; toRefs</h2><h3 id="1-toRef"><a href="#1-toRef" class="headerlink" title="1. toRef"></a>1. toRef</h3><ul><li><p><strong>作用</strong>：创建个ref对象，其value的值指向另一个对象的某个属性。</p></li><li><p><strong>应用</strong>：要将响应式对象中的某个</p></li><li><p><strong>参数</strong>：1.目标对象；2.属性名。</p><ul><li><strong>举例</strong>：</li></ul><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre></li><li><p>和ref的区别：</p></li></ul><p>​    <strong>对比</strong>：</p><pre><code>let person = reactive(&#123;    name: &#39;&#39;,    hobby: &#123;        food: &#39;&#39;        &#125;&#125;)// 这里拿到的只是一个属性值：const name = person.name;console.log(&#39;name&#39;, name)// 使用toRef：const name2 = toRef(person, &#39;name&#39;);// 此时name不再是一个值，而是包在ref对象里的属性。console.log(&#39;name2&#39;, name2)</code></pre><p>如果要在setup函数return中：</p><p><strong>注意</strong>：这里return中ref也可以但ref生成的是新的数据，但使用toRef数据依旧是保持联系的。这是<strong>两者的区别</strong>。</p><pre><code>return &#123;    name: toRef(person, &#39;name&#39;);    food: toRef(person.hobby, &#39;food&#39;)&#125;</code></pre><p>当setup中的数据，return一个对象类型数据后，模板中每次使用都需要对象.xxxx。当在return时就写好对象.xxxx的话，会出现一种情况：数据不再是响应式。</p><p><strong>举例验证一下原因</strong>：</p><p>相当于：最后一行name是另外新定义的，和<code>p.name</code>没任何关联，所以响应式会没了。</p><img src="https://s2.loli.net/2022/08/18/ifGqWZsKODSmjhy.png" alt="image.png" style="zoom: 67%;" /><h3 id="2-toRefs"><a href="#2-toRefs" class="headerlink" title="2. toRefs"></a>2. toRefs</h3><ul><li><strong>作用</strong>：需要使用<span style="color: #0089FB;">多个toRef</span>时，可以用toRefs简写。</li><li><strong>使用</strong>：只需给一个参数。无需重复给多个属性写toRef。</li><li><strong>语法</strong>：toRefs(obj)</li></ul><p><strong>注意</strong>：</p><ul><li>return的时候不能直接就用，return的是对象，而toRefs返回的也是对象，直接写会报错。</li><li>按照这种格式（<span style="color: #FFB700;"><strong>…obj</strong></span>）：</li></ul><pre><code>return &#123;    // 这样数据的格式才正确：    ...toRefs(person)&#125;</code></pre><hr><h2 id="8-computed、watch与watchEffect"><a href="#8-computed、watch与watchEffect" class="headerlink" title="8. computed、watch与watchEffect"></a>8. computed、watch与watchEffect</h2><h3 id="1-computed"><a href="#1-computed" class="headerlink" title="1. computed"></a>1. computed</h3><ul><li>与vue2中computed配置功能一致。</li><li>写法：</li></ul><pre><code>import &#123; computed &#125; from &#39;vue&#39;;...    // vue3中computed与vue2语法一样：    let personObj = computed(&#123;      name: &#39;a&#39;,      age: 22    &#125;);</code></pre><p>完整：</p><img src="https://s2.loli.net/2022/08/18/O5n2zmlfTRqIHN1.png" alt="image.png" style="zoom:50%;" /><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2. watch函数"></a>2. watch函数</h3><ul><li>与vue2中配置功能一致。</li><li>两个小坑：<ul><li>监视<code>reactive</code>定义的响应式数据时：<span style="color: #CC0000;">oldValue无法正确获取；强制开启了深度监视（deep配置失效）</span>。</li><li>监视<code>reactive</code>定义的响应式数据中的<strong>某个属性</strong>时：<span style="color: #CC0000;">deep配置有效</span>。</li></ul></li></ul><h4 id="2-1-vue3中watch的变化："><a href="#2-1-vue3中watch的变化：" class="headerlink" title="2.1 vue3中watch的变化："></a>2.1 vue3中watch的变化：</h4><ul><li><p>watch能传递<strong>3个参数</strong>：</p><ul><li>监视谁：字符串/数组。</li><li>监视的回调：函数。</li><li>配置项：对象。</li></ul></li><li><p>监视reactive所定义的数据时，默认开启deep深度监视。且修改无效。</p></li><li><p><strong>immediate配置项</strong>的使用：</p><ul><li>情况1&amp;2中，配置有效。</li></ul></li><li><p><strong>deep配置项</strong>的使用：</p><ul><li>当监视的数据由<code>reactive</code><strong>直接管理时</strong>，<strong>deep默认开启</strong>。</li><li>当嵌套层级较深，则需<strong>手动配置</strong>开启。</li></ul></li><li><p><strong>获取不到oldValue</strong>的情况：可以总结为当是复杂数据类型时就获取不到。</p></li></ul><h4 id="2-2-六种使用情况："><a href="#2-2-六种使用情况：" class="headerlink" title="2.2 六种使用情况："></a>2.2 六种使用情况：</h4><p><span style="color: #0089FB;">1. </span>监视<span style="color: #2742B2;">一个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">2. </span>监视<span style="color: #2742B2;">多个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">3. </span>监视<span style="color: #2742B2;">reactive定义的全部数据</span>                      <code>deep配置无效；oldValue无法获取</code></p><p><span style="color: #0089FB;">4. </span>监视<span style="color: #2742B2;">一个reactive</span>定义的数据中的属性         <code>监视的属性要写为函数形式；oldValue可获取</code></p><p><span style="color: #0089FB;">5. </span>监视<span style="color: #2742B2;">多个reactive</span>定义的数据中的属性             <code>监视的属性要写在数组里且每项都是函数；oldValue可获取</code></p><p><span style="color: #0089FB;">6. </span><strong>特殊的情况</strong>：监视<span style="color: #2742B2;">reactive定义的数据中的对象</span>属性     <code>对象嵌套对象所以deep配置有效；oldValue无法获取</code></p><p><strong>全部代码示例：</strong></p><pre><code>const num = ref(0);const msg = ref(&#39;hello&#39;);let obj = reactive(&#123;  name: &#39;&#39;,  age: 30,  hobby: &#123;    food: &#39;anything&#39;  &#125;&#125;);// 情况1. 当监视一个ref定义的数据时：watch(  num,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况2. 当监视多个ref定义的数据时：watch(  [num, msg],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况3. 当监视reactive定义的全部数据时：// 注意：//    1.此时无法拿到正确的oldValue。//    2.默认开启deep；且修改无效。watch(  obj.age,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况4. 当监视一个reactive定义的数据中的属性时：// 注意：当监视这种数据时，watch的第1个形参需要是一个函数，函数里要有返回值,监视谁就返回谁。// 这时oldValue正确。watch(  () =&gt; &#123;    return obj.age;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况5. 当监视多个reactive定义的数据中的属性时：// 注意：watch的第1个形参是一个数组，监视几个数据里面就包几个函数。// 这时oldValue正确。watch(  [    () =&gt; &#123;      return obj.name;    &#125;,    () =&gt; &#123;      return obj.age;    &#125;  ],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 特殊的情况6. 当监视reactive定义的数据中的对象属性时：// 注意：当监视这种数据时，watch的第1个形参是函数。// oldValue无法获取。watch(  () =&gt; &#123;    return obj.hobby;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);</code></pre><p><strong>注意：</strong></p><ul><li><p>使用watch监视基本数据类型时，别用<code>.value</code>，这样拿到的是一个属性真正的值而非属性。</p></li><li><p>但<span style="color: #E95200;">对象类型（ref定义时）</span>：要用<code>.value</code>才会被监测到。<strong>因为</strong><span style="color: #CC0000;">此时的value是由reactive函数生成的proxy实例对象</span>。</p><ul><li>除了上面的<code>.value</code>，还有一个办法：加配置项 <code>deep: true</code>; </li></ul></li></ul><hr><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3. watchEffect函数"></a>3. watchEffect函数</h3><ul><li><p>watchEffect也是一个监视函数，但它不用指明监视目标。<span style="color: #E95200;"><code>默认开启immediate: true</code></span>。</p></li><li><p><strong>参数</strong>：监视的回调</p></li><li><p><strong>作用</strong>：观察<span style="color: #E95200;">监视的回调中用到了谁</span>，智能的选择监视谁。<span style="color: #E95200;">可以监视深层级数据</span>。</p></li><li><p><strong>使用场景</strong>：不用再多次写watch函数然后按照不同数据的语法写。watchEffect会自动识别并监视。</p></li><li><p><code>watchEffect</code>有点像<code>computed</code>，具体**<span style="color: #CC0000;">区别</span>**：</p></li><li><p>1.**computed注重计算出来的<span style="color: #E95200;">值</span>**（回调函数的返回值），所以必须要有返回值。执行时机：初始化时；所依赖的数据发生变化时。</p></li><li><ol start="2"><li><strong>watchEffect要的是过程（使用了谁），不用返回值</strong>。watchEffect也是所依赖的数据发生变化时重新执行一次。</li></ol></li></ul><hr><h2 id="9-hook"><a href="#9-hook" class="headerlink" title="9. hook"></a>9. hook</h2><ul><li><p>本质是函数，把setup中使用的Composition API进行了封装。类似于vue2中的mixin。</p></li><li><p>自定义hook的优势：复用代码，让setup中的逻辑更清楚。</p></li><li><p>把该功能相关的数据、方法、生命周期钩子全都抽离出去。</p><ul><li>新建hook文件后，将以上内容都放在个函数里。</li></ul></li><li><p>ps：hook文件取名一般为useXxx。</p></li></ul><p><strong>使用示例</strong>：</p><ul><li><p>实现一个点击鼠标拿到坐标的功能：（完整代码在vue3-practice）</p><ul><li><strong>改为hook前</strong>：</li></ul><pre><code>&lt;script setup&gt;import &#123; reactive &#125; from &#39;@vue/reactivity&#39;;import &#123; onBeforeUnmount, onMounted &#125; from &#39;@vue/runtime-core&#39;;const position = reactive(&#123;  x: 0,  y: 0&#125;);// // 组件挂载后执行// onMounted(() =&gt; &#123;//   // 这种写法的问题：组件卸载前销毁该事件时无法操作：//   window.addEventListener(&#39;click&#39;, function (event) &#123;//     console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);//     // 数据为响应式：//     position.x = event.pageX;//     position.y = event.pageY;//   &#125;);// &#125;);// 基于以上问题，改为这样（将点击事件的回调拎出去）：onMounted(() =&gt; &#123;  // 事件回调写进来：  window.addEventListener(&#39;click&#39;, savePosition);&#125;);function savePosition(event) &#123;  console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);  // 数据为响应式：  position.x = event.pageX;  position.y = event.pageY;&#125;// 需要注意的是，当组件被卸载时该事件也该失效，所以要在卸载前另外处理下：onBeforeUnmount(() =&gt; &#123;  // 这里需要两个参数：1.移除的事件；2.移除的事件所对应的回调。  window.removeEventListener(&#39;click&#39;, savePosition);&#125;);&lt;/script&gt;</code></pre><ul><li><strong>hook写法</strong>：   以下代码全都可以抽出去</li></ul></li></ul><img src="https://s2.loli.net/2022/08/18/L9qoVb2UTGaZnHu.png" alt="image.png" style="zoom:80%;" /><p>usePosition文件中：</p><pre><code>import &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;;// 默认暴露可以不用起名，汇依据使用时起的名字。export default function () &#123;  const position = reactive(&#123;    x: 0,    y: 0  &#125;);  function savePosition(event) &#123;    position.x = event.pageX;    position.y = event.pageY;    console.log(&#39;FROM UseHook position: &#39;, position.x, position.y);  &#125;  onMounted(() =&gt; &#123;    window.addEventListener(&#39;click&#39;, savePosition);  &#125;);  onBeforeUnmount(() =&gt; &#123;    window.removeEventListener(&#39;click&#39;, savePosition);  &#125;);  // 是函数，所以需要给返回值：  // 将组件中需要的数据传出去：  return position;&#125;</code></pre><hr><h2 id="10-其它Composition-API"><a href="#10-其它Composition-API" class="headerlink" title="10. 其它Composition API"></a>10. 其它Composition API</h2><h3 id="1-shallowReactive和shallowRef"><a href="#1-shallowReactive和shallowRef" class="headerlink" title="1. shallowReactive和shallowRef"></a><strong>1.</strong> shallowReactive和shallowRef</h3><ul><li><p><strong>shallowReactive：</strong>只处理对象中第一层的响应式，里层的不管（浅响应式）。</p></li><li><p><strong>shallowRef：</strong></p><ul><li>只处理基本类型，和ref的使用效果无区别。</li><li>当用来处理对象类型时，不再去借助reactive处理，而是直接不管了。</li></ul></li><li><p><strong>使用时机</strong>：</p><ul><li>如果一个对象数据，嵌套层级多，但只是外层属性变化(为了提升性能)。   ==》<span style="color: #FFB700;">shallowReactive</span></li><li>如果一个对象类型数据，后续使用不会修改对象中的属性(修改会失效)，而是生成新的对象替换。   ==》<span style="color: #FFB700;">shallowRef</span></li><li><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4</a></li></ul></li></ul><h3 id="2-readOnly和shallowReadOnly"><a href="#2-readOnly和shallowReadOnly" class="headerlink" title="2. readOnly和shallowReadOnly"></a>2. readOnly和shallowReadOnly</h3><ul><li><strong>readOnly</strong>：让响应式数据变为只读状态（<span style="color: #FFB700;">深只读</span>）。</li><li><strong>shallowReadOnly</strong>：让响应式数据变为只读状态（浅只读，除第一层只读外，里层的还可以修改）。</li><li><strong>应用场景</strong>：让数据不被修改。</li></ul><h3 id="3-toRaw和markRaw"><a href="#3-toRaw和markRaw" class="headerlink" title="3. toRaw和markRaw"></a>3. toRaw和markRaw</h3><p>raw：原始的</p><ul><li><p><strong>toRaw</strong>：</p><ul><li><strong>作用</strong>：将<code>reactive</code>生成的响应式数据转为普通对象（ref不行）。</li><li><strong>使用场景</strong>：用于读取响应式对象对应的普通对象，使其所有操作都不会引起页面更新（数据会变但不响应式）。</li></ul></li><li><p><strong>markRaw</strong>：</p><ul><li><strong>作用</strong>：标记一个对象，使其之后不能再成为响应式对象。</li><li><strong>应用场景</strong>：（应用场景比<code>toRaw</code>广）<ul><li>1.不应该设为响应式的值，比如复杂的第三方类库等。</li><li>2.当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ul></li></ul></li></ul><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4. customRef"></a>4. customRef</h3><ul><li><strong>作用</strong>：创建一个自定义的ref，并跟踪其依赖项和更新触发进行显示控制。</li></ul><p><strong>使用示例</strong>：（完整代码在vue3-practice的useCustomRef中）</p><pre><code>import &#123; customRef &#125; from &#39;vue&#39;;// 使用customRef自定义一个ref：function myRef(initVal, delay) &#123;  // customRef接收两个参数：  return customRef((track, trigger) =&gt; &#123;    // 下面的返回是customRef规定的：    return &#123;      get() &#123;        console.log(&#39;正在读value：&#39;, initVal);        // 在return之前通知vue追踪数据        track();        return initVal;      &#125;,      set(newVal) &#123;        console.log(&#39;正在修改value：&#39;, newVal);        // // 只有把新值赋回给初始值的变量才能动态的变化起来：        // initVal = newVal;        // // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。        // trigger();        // 这离开了定时器会出现一个状况：当输入速度太快，等到了页面刷新时，部分被积压的输入被刷掉，页面上能看到输入在回退。        // 解决办法：先定义一个timer定时器，每次进来执行前先清除定时器。（参考js防抖的原理）        clearTimeout();        setTimeout(() =&gt; &#123;          // 只有把新值赋回给初始值的变量才能动态的变化起来：          initVal = newVal;          // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。          trigger();        &#125;, delay);      &#125;    &#125;;  &#125;);&#125;// 给myRef两个实参：1.initVal初始值；2.delay延迟执行的时间。let num = myRef(0, 500);console.log(&#39;myRef自定义的数据:&#39;, num);</code></pre><ul><li><p><strong>可以优化的地方</strong>：延迟执行的时间是写死的，可以写为动态改变的。（<strong>已改</strong>）</p><ul><li>实现：多传递一个变量（比如delay）。</li></ul></li><li><p>实参写在调用<code>myRef</code>时的<code>()</code>中。</p></li></ul><hr><h2 id="11-provide-amp-inject"><a href="#11-provide-amp-inject" class="headerlink" title="11. provide &amp; inject"></a>11. provide &amp; inject</h2><ul><li><p>provide和inject（注入）是一种组件间通信的方式。</p></li><li><p><strong>作用</strong>：实现祖孙组件间的通信。</p></li><li><p><strong>使用</strong>：父组件使用<span style="color: #FFB700;"><code>provide</code></span>提供数据，后代组件通过<span style="color: #FFB700;"><code>inject</code></span>接收使用数据。</p><ul><li>provide两个参数：1.给传递的数据起的名字；2.实参。</li><li>inject通过传递的参数名拿到真实数据。（如下代码块）</li></ul></li><li><p><strong>语法</strong>：</p></li></ul><pre><code>// 父组件中：let num = ref(0);provide(&#39;xxx&#39;, num)// 后代组件中接收：const xxx = inject(&#39;xxx&#39;);</code></pre><ul><li><strong>注意</strong>：所有后代组件都可以使用<code>inject</code>拿到数据，但一般用在祖孙之间传递。</li></ul><hr><h2 id="12-几个用于判断响应式数据的API"><a href="#12-几个用于判断响应式数据的API" class="headerlink" title="12. 几个用于判断响应式数据的API"></a>12. 几个用于判断响应式数据的API</h2><p><strong>几个常用的用来判断的API：</strong></p><ol><li><strong>isRef</strong>：检查一个值是否是一个<code>ref</code>对象。</li><li><strong>isReactive</strong>：检查一个对象是否是由<code>reactive</code>创建的响应式代理。</li><li><strong>isReadonly</strong>：检查一个对象是否由<code>readonly</code>创建的只读代理。</li><li><strong>isProxy</strong>：检查一个对象是否由<code>reactive或者readonly</code>方法创建的代理。</li></ol><p><strong>使用场景</strong>：判断一个数据是否经过某些api的修饰。</p><p><strong>需要注意的一点</strong>：</p><ul><li>当<code>isProxy</code>判断一个由~所定义的数据时，它也会返回true。</li><li>这是因为<code>readonly</code>属性不会改变原数据的形式。依旧是proxy代理，而非转为普通object对象。</li></ul><pre><code>let obj1 = reactive(&#123;    a: 1,    b: 2&#125;)let obj2 = readonly(obj)// 打印为true：console.log(isProxy(obj2));</code></pre><hr><h2 id="13-新的组件"><a href="#13-新的组件" class="headerlink" title="13. 新的组件"></a>13. 新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1. Fragment"></a>1. Fragment</h3><blockquote><p>Fragment：碎片</p></blockquote><ul><li>在<strong>vue2</strong>中：组件必须有个根标签。</li><li><strong>vue3</strong>中：无需根标签，内部已经将多个标签包在一个Fragment虚拟元素中。</li><li><strong>优势</strong>：减少标签层级嵌套，减小内存占用。</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2. Teleport"></a>2. Teleport</h3><blockquote><p>teleport：瞬间移动；传送；</p></blockquote><ul><li><strong>作用</strong>：将一段HTML结构移动到指定位置。</li><li>to属性用来指定位置。</li></ul><pre><code>&lt;teleport to=&quot;body/或任意其他位置&quot;&gt;    &lt;div&gt;&lt;/div&gt;&lt;teleport&gt;</code></pre><h3 id="3-Suspense-（试验阶段）"><a href="#3-Suspense-（试验阶段）" class="headerlink" title="3. Suspense （试验阶段）"></a>3. Suspense （试验阶段）</h3><blockquote><p>Suspense:悬念</p></blockquote><ul><li><p><strong>作用</strong>：异步引入组件。</p></li><li><p><span style="color: #FFB700;"><strong>静态</strong></span> <strong>&amp;</strong> <span style="color: #FFB700;"><strong>动态</strong></span><span style="color: #FFB700;">(异步)</span><strong>引入组件的对比</strong>：</p><ul><li><p>写法：</p><pre><code>// 静态引入：import child from &#39;./文件路径&#39;;</code></pre><pre><code>import &#123; defineAsnycComponent &#125; from &#39;vue&#39;;// 动态(异步)引入组件：// import在以前用作一个关键词，在这里用作一个函数。const child = defineAsnycComponent(()=&gt; import(&#39;./文件路径&#39;)))</code></pre></li><li><p><strong>静态引入</strong>：当网速慢的时候，造成几个组件都不显示都在等着。</p></li><li><p><strong>动态引入</strong>：</p></li></ul></li><li><p><strong>Suspense使用</strong>：Suspense组件标签中内置了两个插槽：</p><ul><li>1.要放入展示的组件；</li><li>2.组件未加载时loading状态的内容。</li><li><strong>注意</strong>：<span style="color: #FFB700;">插槽的名字不能换</span>。</li></ul></li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;  &lt;h3&gt;我是App组件&lt;/h3&gt;  &lt;Suspense&gt;    &lt;template v-slot:default&gt;      &lt;Child/&gt;    &lt;/template&gt;        &lt;template v-slot:fallback&gt;      &lt;h3&gt;加载中.....&lt;/h3&gt;    &lt;/template&gt;  &lt;/Suspense&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>PS</strong>：当组件用了异步引入时，setup可以是async函数。</p>   <img src="https://s2.loli.net/2022/08/18/gi8sOUXRAJlphVy.png" alt="image.png" style="zoom:67%;" /><hr><h2 id="14-vue3的其它调整"><a href="#14-vue3的其它调整" class="headerlink" title="14. vue3的其它调整"></a>14. vue3的其它调整</h2><h3 id="1-全局API的转移："><a href="#1-全局API的转移：" class="headerlink" title="1. 全局API的转移："></a>1. 全局API的转移：</h3><p><img src="https://s2.loli.net/2022/08/18/ksXfFxdm8Hr65nI.png" alt="image.png"></p><h3 id="2-其它："><a href="#2-其它：" class="headerlink" title="2. 其它："></a>2. 其它：</h3><ul><li>data始终应被声明为函数。</li><li>过渡类名的更改：</li></ul><p><img src="https://s2.loli.net/2022/08/18/arnC83f6p4hHLRN.png" alt="image.png"></p><ul><li><p>移除keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p>移除<code>v-on.native</code>修饰符</p></li><li><ul><li>父组件中绑定事件</li></ul></li></ul><pre><code> &lt;my-component   v-on:close=&quot;handleComponentEvent&quot;   v-on:click=&quot;handleNativeClickEvent&quot; /&gt;</code></pre><ul><li><ul><li>子组件中声明自定义事件</li></ul></li></ul><pre><code> &lt;script&gt;   export default &#123;     emits: [&#39;close&#39;]   &#125; &lt;/script&gt;</code></pre><ul><li>移除过滤器（filter）</li></ul><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote><ul><li><p>其余去看官方文档…</p></li><li><ul><li><a href="https://staging-cn.vuejs.org/api/application.html">https://staging-cn.vuejs.org/api/application.html</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-生命周期的变更&quot;&gt;&lt;a href=&quot;#1-生命周期的变更&quot; class=&quot;headerlink&quot; title=&quot;1.生命周期的变更&quot;&gt;&lt;/a&gt;1.生命周期的变更&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;销毁的概念改为&lt;strong&gt;卸载&lt;/strong&gt;，更名：&lt;/p</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>JS深拷贝</title>
    <link href="https://polariis.gitee.io/posts/3136a465/"/>
    <id>https://polariis.gitee.io/posts/3136a465/</id>
    <published>2022-08-17T13:27:54.000Z</published>
    <updated>2023-02-06T18:43:24.670Z</updated>
    
    <content type="html"><![CDATA[<p>拷贝的对象可能是多层级的，要确保深层嵌套也一样，可以使用递归，所以：</p><ul><li>如果是原始类型 =》 直接返回，无需继续拷贝。</li><li>如果是引用类型 =》 创建新对象，遍历要克隆的对象&amp;将对象属性深拷贝后依次放入新对象中。</li></ul><h5 id="完善过程：（最终版拉到最后）"><a href="#完善过程：（最终版拉到最后）" class="headerlink" title="完善过程：（最终版拉到最后）"></a>完善过程：（<span style="color: #3850b8">最终版拉到最后</span>）</h5><ol><li><strong>未考虑数组的情况下</strong>：</li></ol><pre><code>export function basicClone(target) &#123;  // 先判断是否为对象类型：  if (typeof target === &#39;object&#39;) &#123;    let cloneTarget = &#123;&#125;;    for (const key in target) &#123;      // 将原对象中每一项放入新对象：      cloneTarget[key] = basicClone(target[key]);    &#125;    // 返回新对象：    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><ol start="2"><li><strong>根据以上改进加入数组</strong>：</li></ol><pre><code>export function Clone(target) &#123;  if (typeof target === &#39;object&#39;) &#123;    // 关键：如果target是数组则定义个新数组而非对象。其余代码与上种无差别。    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;    for (const key in target) &#123;      cloneTarget[key] = Clone(target[key]);    &#125;    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><ol start="3"><li><p><strong>考虑栈溢出的情况</strong>：(当对象中的属性引用了自身，进入死循环会导致栈溢出。)</p></li><li><ol><li><p><span style="color: #0091ff;background-color: #f2f4f5;">解决循环引用</span>：开辟新的存储空间放置当前对象和拷贝对象的对应关系。</p></li><li><ol><li>当需要拷贝当前对象时先去存储空间找。有拷贝过这个对象 =》直接返回；</li><li>没有的话 =》继续拷贝。</li></ol></li><li><p>Map数据结构：<a href="https://juejin.cn/post/7064479924757168165%E3%80%82">https://juejin.cn/post/7064479924757168165。</a></p></li></ol></li></ol><pre><code>// 测试用例：const target = &#123;  field1: 1,  field2: undefined,  field3: &#123;      child: &#39;child&#39;  &#125;,  field4: [2, 4, 8]&#125;;target.target = target;  // 这里导致栈溢出。export function deepClone(target, map = new Map) &#123;  if (typeof target === &#39;object&#39;) &#123;    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;    // 判断map中有没有已经克隆过的对象：    if (map.get(target)) &#123;      // 有 =》直接返回：      return map.get(target);    &#125;    // 没有 =》将当前对象作为key，克隆对象作为value进行存储：    map.set(target, cloneTarget);    // 继续克隆：    for (const key in target) &#123;      cloneTarget[key] = deepClone(target[key], map);    &#125;    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><p>待完善，</p><p>关于WeakMap及其它拓展暂未学习。</p><p>参考：<a href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拷贝的对象可能是多层级的，要确保深层嵌套也一样，可以使用递归，所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是原始类型 =》 直接返回，无需继续拷贝。&lt;/li&gt;
&lt;li&gt;如果是引用类型 =》 创建新对象，遍历要克隆的对象&amp;amp;将对象属性深拷贝后依次放入新对象中。&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>Vue3生命周期的变更</title>
    <link href="https://polariis.gitee.io/posts/2606f5b3/"/>
    <id>https://polariis.gitee.io/posts/2606f5b3/</id>
    <published>2022-08-07T01:07:21.000Z</published>
    <updated>2023-05-20T02:13:43.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p>销毁的概念改为<strong>卸载</strong>（unmounted），更名：</p></li><li><ul><li>beforeDestroy 改名为 beforeUnmounted。</li><li>destroyed 改名为 unmounted。</li></ul></li><li><p>vue2 中的两次判断改为一次。</p></li></ul><p>​ <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810030613459.png" alt="image-20220810030613459"></p><ul><li><p>Vue3 提供的<strong>Composition API</strong>形式对比：</p></li><li><ul><li>beforeCreate =&gt; <strong>setup()</strong></li><li>created =&gt; <strong>setup()</strong></li><li>beforeMount =&gt; <strong>onBeforeMount</strong></li><li>mounted =&gt; <strong>onMounted</strong></li><li>beforeUpdate =&gt; <strong>onBeforeUpdate</strong></li><li>updated =&gt; <strong>onUpdated</strong></li><li>beforeUnmounted =&gt; <strong>onBeforeUnmounted</strong></li><li>unmounted =&gt; <strong>OnUnmounted</strong></li></ul></li><li><p>组合式 API 的 vue2 生命钩子的<strong>优先级：</strong></p></li><li><ul><li><p>下图打印结果可以看到：setup 中的组合式 API 优先级更高。</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810034139355-16600741018631.png" alt="image-20220810034139355"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;销毁的概念改为&lt;strong&gt;卸载&lt;/strong&gt;（unmounted），更名：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;befo</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>如何终止多层循环</title>
    <link href="https://polariis.gitee.io/posts/2b061dbf/"/>
    <id>https://polariis.gitee.io/posts/2b061dbf/</id>
    <published>2022-08-06T16:00:00.000Z</published>
    <updated>2023-02-06T18:43:24.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用for的情况下"><a href="#1-使用for的情况下" class="headerlink" title="1. 使用for的情况下"></a>1. 使用for的情况下</h3><ul><li>给外层和内层循环分别使用<strong>标签语句</strong>起个名字   (红宝书P167，3.6.7章节。)</li><li>通过 <strong>break 标签语句</strong>    的形式选择中止哪一层循环。</li></ul><p>具体代码示例：</p><p><img src="https://s2.loli.net/2022/10/05/PhIgrWbDdOkAlK7.png" alt="image-png"></p><p><strong>其他方法</strong>：外层循环条件表达式里加一个布尔值与运算，内存循环跳出，外层循环不允许再进入，这种方法用的还是比较多。</p><p><strong>备用方案</strong>：定义flag=false，当内循环找到之后就改为true，当flag=true就执行外层的break。</p><h3 id="2-使用foreach的情况下"><a href="#2-使用foreach的情况下" class="headerlink" title="2. 使用foreach的情况下"></a>2. 使用foreach的情况下</h3><ul><li>语法报错。提示：foreach的循环不能跳出外层循环。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-使用for的情况下&quot;&gt;&lt;a href=&quot;#1-使用for的情况下&quot; class=&quot;headerlink&quot; title=&quot;1. 使用for的情况下&quot;&gt;&lt;/a&gt;1. 使用for的情况下&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;给外层和内层循环分别使用&lt;strong&gt;标签语句&lt;/</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>reactive不能解构</title>
    <link href="https://polariis.gitee.io/posts/263d655f/"/>
    <id>https://polariis.gitee.io/posts/263d655f/</id>
    <published>2022-07-08T16:00:00.000Z</published>
    <updated>2023-02-06T18:43:24.689Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>当使用reactive定义一个对象，不能使用解构（<strong>数据不能修改成功</strong>）。</p><ul><li><p>举例：</p><pre><code>const obj = reactive(&#123;    a: &#39;polaris&#39;,    b: 20&#125;)obj.b = 13;console.log(obj.b); // b=20，未改成功。</code></pre></li></ul></li><li><ul><li><strong>解决</strong>： 使用toRefs。</li><li><strong>注意</strong>：使用了toRef或toRefs，取值要.value。</li></ul></li></ul><pre><code>// 修改后：const obj = reactive(&#123;    a: &#39;polaris&#39;,    b: 20&#125;)obj.b = 13;console.log(obj.b); // b=20，未改成功。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当使用reactive定义一个对象，不能使用解构（&lt;strong&gt;数据不能修改成功&lt;/strong&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj = reactive(&amp;#123;
    a: &amp;#39;</summary>
      
    
    
    
    <category term="Axios" scheme="https://polariis.gitee.io/categories/Axios/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>ref &amp; reactive &amp; 响应式差异</title>
    <link href="https://polariis.gitee.io/posts/9badfa3f/"/>
    <id>https://polariis.gitee.io/posts/9badfa3f/</id>
    <published>2022-07-05T08:55:53.000Z</published>
    <updated>2023-05-20T02:13:43.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：const xxx = ref(initValue)</p></li><li><ul><li>创建一个包含响应式数据的引用对象（reference 对象）。</li><li>模板中使用引用对象不用后面加.value，而 setup 中使用该值时需要加.value。</li></ul></li><li><p><strong>接收的数据</strong>：</p></li><li><ul><li>可以是：基本类型、对象类型。</li><li>ref 处理 <strong>基本类型： 响应式</strong>依旧使用是<strong>defineProperty</strong> ，以 set &amp; get 数据劫持的方式。</li><li>而处理 <strong>对象类型</strong>时使用<strong>proxy</strong>实现的（proxy 是封装在 reactive 函数中的，ref 内部会自动通过 reactive 转为代理对象）。</li><li>补充：使用 ref 数据要 .value 是因为 Object.defineProperty 本身无法作用于基本数据类型，所以通过对象做了一层转化。</li></ul></li><li><p><strong>使用 ref 获取节点</strong>：</p></li><li><p><strong>注意</strong>：如果要在 setup 中拿到 DOM 元素，声明的变量名必须与元素中写的 ref<strong>一致</strong>。</p></li></ul><p><template> <div id="countBox" ref="countupRef"> <span class="countSpan"></span> </div> </template></p><ul><li><p>在<strong>onMounted</strong>中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="2-reactive："><a href="#2-reactive：" class="headerlink" title="2. reactive："></a><strong>2. reactive：</strong></h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用 ref 函数）。</p></li><li><p><strong>语法</strong>：const 代理对象 = reactive(源对象); 接收一个对象或数组，返回一个<strong>代理对象</strong>（Proxy 的实例对象，简称 proxy 对象）。</p></li><li><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul></li></ul><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035136457-16600746990031.png" alt="image-20220810035136457"></p><ul><li>reactive 定义的响应式数据是”深层次的“。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部的数据。</li></ul><h2 id="3-ref-对比-reactive-总结"><a href="#3-ref-对比-reactive-总结" class="headerlink" title="3. ref 对比 reactive 总结"></a><strong>3. ref 对比 reactive 总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p></li><li><ul><li>ref 定义：基本类型数据。</li><li>reactive 定义：对象/数组类型数据。</li><li>注意：ref 也可以定义对象/数组类型数据，它内部会自动通过 reactive 转为代理对象。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p></li><li><ul><li>ref：通过 Object.defineProperty()的 get 和 set 实现响应式（数据劫持）。</li><li>reactive：通过使用 Proxy 实现响应式（数据劫持），并通过 Reflect 操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p></li><li><ul><li>ref 定义的数据：操作数据需要.value，读取数据时模板会直接读取不用.value。</li><li>reactive 定义的数据：操作数据与读取数据均不需要.value。</li></ul></li></ul><h2 id="4-响应式原理对比"><a href="#4-响应式原理对比" class="headerlink" title="4. 响应式原理对比"></a><strong>4. 响应式原理对比</strong></h2><h2 id="4-1-Vue2-的响应式"><a href="#4-1-Vue2-的响应式" class="headerlink" title="4.1 Vue2 的响应式"></a><strong>4.1 Vue2 的响应式</strong></h2><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><p><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</p></li><li><p><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。</p></li><li><ul><li><p>比如：调用 push 方法，其实调用的是 vue2 二次封装后的 push。</p></li><li><p>这个 push 里做了两件事：</p></li><li><ul><li>\1. 帮助正常调用 push 方法。</li><li>\2. 帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p></li><li><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul></li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035246493-16600747685122.png" alt="image-20220810035246493"></p><ul><li><p><strong>Object.defineProperty</strong>:</p></li><li><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用 delete 删除属性，默认值为 false。</li></ul></li></ul><h3 id="4-2-Vue3-的响应式"><a href="#4-2-Vue3-的响应式" class="headerlink" title="4.2 Vue3 的响应式"></a><strong>4.2 Vue3 的响应式</strong></h3><h4 id="4-2-1-实现原理："><a href="#4-2-1-实现原理：" class="headerlink" title="4.2.1 实现原理："></a><strong>4.2.1 实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN 文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p></li><li><ul><li><strong>Proxy</strong>：window 上内置的，接收<strong>两个参数</strong>（必填）：<strong>1</strong>.target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2 和 vue3 响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p></li><li><ul><li><strong>模拟 Vue3 中实现响应式</strong>：（不完整，看下面的<strong>reflect</strong>。）</li></ul></li></ul><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];    &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;    &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]    &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035353361-16600748348953.png" alt="image-20220810035353361"></p><h4 id="4-2-2-响应式中-Reflect-的应用："><a href="#4-2-2-响应式中-Reflect-的应用：" class="headerlink" title="4.2.2. 响应式中 Reflect 的应用："></a>4.2.2. 响应式中 Reflect 的应用：</h4><ul><li><strong>ES6</strong>，<strong>Windows 内置</strong>。</li><li>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</li><li>reflect 里也有 defineProperty 方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</li></ul><p><strong>与 Object.definProperty**<strong>对比*</strong>*：</strong></p><ul><li><p><strong>在做封装的时候，Object.definProperty 捕获错误只能通过 try catch。若使用 reflect 就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></p></li><li><p><strong>模拟 Vue3 中实现响应式</strong>（使用<strong>reflect</strong>改进后）：</p></li><li><ul><li><p>用到了 proxy 代理对象，及 reflect 反射对象。</p><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);    &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);    &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);    &#125;&#125;)</code></pre></li></ul></li></ul><hr><p><strong>toRef</strong></p><ul><li>toRef 可以创建一个 ref，其的 value 值可以指向令一个对象的属性。</li></ul><p><strong>举例</strong>：</p><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre><p><strong>toRefs</strong></p><p>指向多个</p><p><strong>toRefs</strong></p><p>指向多个属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Ref&quot;&gt;&lt;a href=&quot;#1-Ref&quot; class=&quot;headerlink&quot; title=&quot;1. Ref&quot;&gt;&lt;/a&gt;1. Ref&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：定义一个响应式的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/categories/Vue3/"/>
    
    
    <category term="Vue3" scheme="https://polariis.gitee.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>事件循环event loop</title>
    <link href="https://polariis.gitee.io/posts/61ebbe5a/"/>
    <id>https://polariis.gitee.io/posts/61ebbe5a/</id>
    <published>2022-05-05T16:00:00.000Z</published>
    <updated>2023-05-20T02:13:43.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理：<a href="https://segmentfault.com/a/1190000012925872#articleHeader17">https://segmentfault.com/a/1190000012925872#articleHeader17</a></li><li>参考自：晓舟的系列视频 <a href="https://www.bilibili.com/video/BV1gB4y1K7bD?share_source=copy_web&vd_source=72dc2b34128eeca7f0729ade125cd412">前端面试题：JavaScript 运行机制（一）单线程_哔哩哔哩_bilibili</a></li></ul></blockquote><hr><h2 id="1-event-loop-事件循环"><a href="#1-event-loop-事件循环" class="headerlink" title="1. event loop 事件循环"></a>1. event loop 事件循环</h2><ul><li>JavaScript 从一开始就是<span style="color: #0091ff">单线程</span>，<strong>原因</strong>：这与它的<span style="color: #0091ff">v</span>有关，JavaScript 作为一个浏览器脚本语言，<span style="color: #0091ff">偏向于用户侧的交互，为了降低复杂性</span>，这决定了它只能是单线程，否则会带来很复杂的同步问题。</li><li>HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。</li></ul><h3 id="1-1-同步-amp-异步"><a href="#1-1-同步-amp-异步" class="headerlink" title="1.1 同步 &amp; 异步"></a>1.1 同步 &amp; 异步</h3><p><span style="color: #3850b8"><strong>场景</strong></span>：当遇到一个非常耗时的任务，而这时又需要响应用户的操作。为了避免页面出现“假死”的状态，<strong>避免主线程的阻塞</strong>，JavaScript 有了 <strong>同步</strong> 和 <strong>异步</strong> 的概念。</p><p><span style="color: #0091ff"><strong>同步任务</strong></span>：在<span style="color: #ff0001"><strong>主线程</strong></span>上的<span style="color: #ff0001">依次执行</span>任务。</p><p><span style="color: #0091ff"><strong>异步任务</strong></span>：<span style="color: #ff0001">不进入主进程</span>，<span style="color: #ff0001"><strong>在任务队列</strong></span>（task queue）的任务。只有等待主线程空闲的时候（调用栈被清空），该任务才会进入主线程执行。</p><p>举例：</p><pre><code> console.log(0) setTimeout(function() &#123;     console.log(1) &#125;, 1000); console.log(2) // 打印顺序是 0 2 1</code></pre><p>这段代码中：</p><ul><li>主线程首先打印 0，看到 setTimeout 后处理为异步，1s 过后 setTimeout 的回调函数会进入任务队列。</li><li>主线程继续运行，打印 2。</li><li>在主线程的任务运行完成之后，会再轮询任务队列，打印出 1。</li></ul><h3 id="1-2-任务队列"><a href="#1-2-任务队列" class="headerlink" title="1.2 任务队列"></a>1.2 任务队列</h3><ul><li>单线程就意味着所有任务需要排队。如果前一个任务耗时很长，后一个任务就等着。</li><li>很多时候 CPU 是闲着的，因为 IO 设备很慢（<strong>比如</strong>Ajax 操作从网络读取数据），必须要等着结果出来，再往下执行。所以 JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</li><li>（ I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中硬件部件。）</li></ul><h3 id="1-3-执行流程-amp-图解"><a href="#1-3-执行流程-amp-图解" class="headerlink" title="1.3 执行流程 &amp; 图解"></a>1.3 执行流程 &amp; 图解</h3><ol><li>所有同步任务都在<span style="color: #3850b8">主线程</span>上执行，形成一个<span style="color: #3850b8"><strong>执行栈</strong></span>（execution context stack）。</li><li><span style="color: #3850b8">主线程</span>之外，还存在一个“<span style="color: #3850b8"><strong>任务队列</strong></span>”（task queue）。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li><li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><ul><li>主线程从任务队列中读取事件,这个过程是<strong>不断循环</strong>的,所以整个的运行机制称为<span style="color: #0091ff"><strong>event loop</strong></span>。</li><li>Node.js 的 Event Loop：略。</li></ul><p><strong>参照下图</strong>：</p><img src="https://s2.loli.net/2022/10/05/ETdfwMcaNrmpxCH.png" alt="image-20221005152751007" style="zoom: 50%;" /><h3 id="1-4-事件循环的三种类型"><a href="#1-4-事件循环的三种类型" class="headerlink" title="1.4 事件循环的三种类型"></a>1.4 事件循环的三种类型</h3><ol><li><p><span style="color: #3850b8">Window 事件循环</span></p></li><li><p><span style="color: #3850b8">Worker 事件循环</span></p></li><li><p><span style="color: #3850b8">Worklet 事件循环</span></p></li></ol><blockquote><p>多个同源窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。</p><p><strong>PS</strong>：</p><p>此处同源指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思。</p><p>“window” 指用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，<strong>同源窗口之间共享事件循环</strong>，例如：</p><ul><li>如果窗口是包含在 iframe 标签中，则它可能会和包含它的窗口共享一个事件循环。</li><li>在多进程浏览器中多个窗口碰巧共享了同一个进程。</li><li>具体细节可能因浏览器而异，取决于它们的实现方式。</li></ul></blockquote><h2 id="2-宏任务-amp-微任务"><a href="#2-宏任务-amp-微任务" class="headerlink" title="2. 宏任务 &amp; 微任务"></a>2. 宏任务 &amp; 微任务</h2><ul><li><span style="color: #3850b8"><strong>异步任务队列</strong></span>：<span style="color: #0091ff"><strong>宏任务</strong></span>(macro-task)和<span style="color: #0091ff"><strong>微任务</strong></span>(micro-task)。</li><li><strong>执行顺序</strong>：执行栈在<span style="color: #3850b8;background-color: #f2f4f5;">执行完同步任务后，查看执行栈是否为空，如果执行栈为空</span> =》执行宏任务。<span style="color: #3850b8">每次</span>宏任务执行完毕后，检查微任务队列是否为空，如果不为空 =》按照<span style="color: #3850b8">先入先出</span>的规则全部执行完微任务 =》设置微任务队列为 null =》再执行宏任务，如此循环。</li></ul><blockquote><p><span style="color: #CC0000"><strong>宏任务队列可以有多个，微任务队列只有一个。</strong></span></p></blockquote><p><strong>注意</strong>：<span style="color: #3850b8;background-color: #f2f4f5;">当<strong>宏任务</strong>出队时，任务是一个个执行</span>；而<span style="color: #3850b8;background-color: #f2f4f5;"><strong>微任务</strong>出队时，任务是一队一队执行</span>。因此处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p><p><strong>宏任务主要包含</strong>：<span style="color: #0091ff">script( 整体代码)、setTimeout、setInterval、 I/O、UI 交互事件</span>……</p><p><strong>微任务主要包含</strong>：<span style="color: #0091ff">Promise、process.nextTick</span>(Node.js 环境)……</p><p>如图：</p><img src="https://s2.loli.net/2022/10/05/pjJeRPY6vWdtKh2.png" alt="image.png" style="zoom:50%;" /><p><strong>例题</strong>：</p><pre><code> setTimeout(function() &#123;     console.log(&#39;1&#39;); &#125;) new Promise(function(resolve) &#123;     console.log(&#39;2&#39;); &#125;).then(function() &#123;     console.log(&#39;3&#39;); &#125;) console.log(&#39;4&#39;);</code></pre><ul><li><strong>打印顺序</strong>：2 4 3 1</li><li><strong>原因</strong>：<ul><li>1.</li><li>2.</li></ul></li></ul><h2 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h2><p>这部分内容主要在：<a href="note://E95A3D8DBC074A43AC8F6F9C15FFE2D5">Promise</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理：&lt;a href=&quot;https://segmentfault.com/a/1190000012925872#articleHeader17&quot;&gt;https://segmentf</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>Promise总结</title>
    <link href="https://polariis.gitee.io/posts/5b39b356/"/>
    <id>https://polariis.gitee.io/posts/5b39b356/</id>
    <published>2022-02-27T02:52:38.000Z</published>
    <updated>2023-02-06T18:43:24.676Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关联笔记</strong>：<a href="note://WEBcaea4312c824c3e5ed720687a4dde45f">Promise补充</a>    <a href="note://WEBb2bc4bcd1fe230dba73429e31b71de72">事件循环event loop</a></p><hr><h2 id="1-一些需要知道的前置内容"><a href="#1-一些需要知道的前置内容" class="headerlink" title="1. 一些需要知道的前置内容"></a>1. 一些需要知道的前置内容</h2><h3 id="1-1-实例对象与函数对象"><a href="#1-1-实例对象与函数对象" class="headerlink" title="1.1 实例对象与函数对象"></a>1.1 实例对象与函数对象</h3><ul><li><span style="color: #ff0001">实例对象</span>：new函数产生的对象，称为实例对象，简称对象。</li><li><span style="color: #ff0001">函数对象</span>：将函数作为对象使用时，简称函数对象。</li></ul><p>看以下对比：</p><pre><code> function Fn() &#123;&#125;            // Fn是函数             </code></pre><pre><code> const Fn = new Fn();        // Fn是构造函数；fn是实例对象。</code></pre><pre><code>console.log(Fn.prototype);  // Fn函数对象                 </code></pre><pre><code>Fn.call(&#123;&#125;)                 // Fn函数对象  </code></pre><pre><code>$(&#39;#test&#39;)                  // Jquery函数            </code></pre><pre><code>$.get(&#39;/test&#39;)              // Jquery函数对象</code></pre><p>​              </p><p>异步加载图片为例：</p><pre><code>// 声明一个函数&amp;传3个参数：function loadImg(src, res, reject) &#123;    // new一个对象    let img = new Image();    // 增加3个对象属性&amp;赋值：    img.src = src;    img.onload = res;    img.onerr = reject;&#125;// 调用loadImgloadImg(&#123;&#125;)</code></pre><p>​       通过回调，</p><h3 id="1-2-两种回调函数（同步-amp-异步）"><a href="#1-2-两种回调函数（同步-amp-异步）" class="headerlink" title="1.2 两种回调函数（同步&amp;异步）"></a>1.2 两种回调函数（同步&amp;异步）</h3><h4 id="1-2-1-同步回调函数："><a href="#1-2-1-同步回调函数：" class="headerlink" title="1.2.1 同步回调函数："></a>1.2.1 同步回调函数：</h4><ul><li><ol><li><strong>理解</strong>：<span style="color: #ff0001">立即执行，每一步完全执行完才结束</span>，不会放进回调队列中。</li></ol></li><li><ol start="2"><li><strong>例子</strong>：看下打印出来的顺序</li></ol></li></ul><pre><code>const arr =  [1, 2, 3];arr.forEach(item =&gt; &#123;       // 遍历回调；同步回调函数。不会放入队列，一上来就执行。    console.log(item);&#125;)console.log(&#39;forEach()后的打印&#39;);</code></pre><p>​            </p><ul><li>打印<strong>结果</strong>：arr中的每个item被打印，然后是第5行。</li><li><strong>说明</strong>：这段代码同步的。函数内每一步都执行完了才会进行下面的代码。</li></ul><h4 id="1-2-2-异步回调函数："><a href="#1-2-2-异步回调函数：" class="headerlink" title="1.2.2 异步回调函数："></a>1.2.2 异步回调函数：</h4><ul><li><ol><li><strong>理解</strong>：不会立即执行，而是<span style="color: #ff0001">放入回调队列等待执行</span>。</li></ol></li><li><ol start="2"><li><strong>例子</strong>：（比如：定时器回调、ajax回调、Promise的成功or失败回调。）</li></ol></li></ul><pre><code>// 异步回调函数，会放入队列在将来执行。setTimeout(() =&gt; &#123;    console.log(&#39;我是setTimeout中的回调~&#39;);&#125;, 0)console.log(&#39;我是setTimeout后的打印&#39;);       // 先打印</code></pre><p>​        </p><ul><li><p>打印<strong>结果&amp;说明</strong>：这段代码会先打印第4行，尽管定时器时间为0。因为是异步的，定时器里的需要等待后执行里面的打印；所以第4行直接先被打印。</p></li><li><ol><li>如果要判断一个函数是否是异步的，可以打印输出看顺序<strong>看是否需要等待</strong>输出来判断。</li></ol></li><li><ol start="2"><li>并不是所有回调都是异步。</li></ol></li></ul><h3 id="1-3-常见的内置错误"><a href="#1-3-常见的内置错误" class="headerlink" title="1.3 常见的内置错误"></a>1.3 常见的内置错误</h3><h4 id="1-3-1-错误的类型："><a href="#1-3-1-错误的类型：" class="headerlink" title="1.3.1 错误的类型："></a>1.3.1 错误的类型：</h4><ul><li><strong>Error:</strong> 是以下所有错误的<span style="background-color: #f2f4f5;">父类型</span>。<ul><li><strong>1.</strong> <span style="color: #CC0000"><strong>ReferenceError</strong></span>：<u>引用的变量不存在</u>；</li></ul></li></ul><pre><code>// 例：console.log(a);    // ReferenceError: a is not definedconsole.log(&#39;====&#39;);    // 未捕获错误，本行代码也不会执行。</code></pre><ul><li><ul><li><strong>2.</strong> <span style="color: #CC0000"><strong>TypeError</strong></span>： <u>数据类型不正确</u>；</li></ul></li></ul><pre><code>// 例：let b = undefined;b.xxx();             // Uncaught TypeError: b.xxx is not a function// 或：console.log(b.xxx);  // Uncaught TypeError: cannot read property &#39;xxx&#39; of undefined</code></pre><ul><li><ul><li><p><strong>3.</strong> <span style="color: #CC0000"><strong>RangeError</strong></span>： <u>数据值不在其所允许的范围内</u>；</p><pre><code>// 例：function fn () &#123;    // 在函数内部调用自己:（叫递归调用）    fn();&#125;// 加上这行就会报错：（最大调用栈溢出，也就是数据值不在其所允许的范围内）fn();              // RangeError: Maximum call stack size exceeded</code></pre><p>​    <strong>PS</strong>：<strong>这种形式不叫函数自调用，要区分开</strong>。函数自调用是：一次性函数。  <a href="https://www.cnblogs.com/liushisaonian/p/9425427.html">https://www.cnblogs.com/liushisaonian/p/9425427.html</a></p></li><li><p><strong>4.</strong>  <span style="color: #CC0000"><strong>SyntaxError</strong></span>： <u>语法错误</u>。</p><pre><code>// 例：// 本意：字符串里放入一个空字符串const c = &quot;&quot;&quot;&quot;;       // SyntaxError: Unexpected string     </code></pre></li></ul></li></ul><h4 id="1-3-2-错误处理："><a href="#1-3-2-错误处理：" class="headerlink" title="1.3.2 错误处理："></a>1.3.2 错误处理：</h4><p>不处理程序没法向下执行，有时需要在出现错误时加一些提示，所以会处理。</p><ul><li><strong>1.</strong> <span style="color: #CC0000"><strong>捕获处理</strong></span>：<strong>try  …  catch</strong><ul><li><strong>error里面默认有两个属性：<span style="color: #0091ff">1.</span> message 信息 ；<span style="color: #0091ff">2.</span> stack 调用栈</strong>    </li></ul></li></ul><pre><code>//try &#123;    let d;    console.log(d.xxx);&#125; catch (error) &#123;    console.log(error.message);   // 提示文本    console.log(error.stack);     // 相关信息文本&#125;// 只有上面处理了错误后，下面这行才可以正常执行：console.log(&#39;上面出错了&#39;);</code></pre><p>​             </p><ul><li><strong>2.</strong> <span style="color: #CC0000"><strong>抛出错误</strong></span>：<strong>throw error</strong>    <ul><li>当想让调用者自己处理，就可以使用抛出异常。若没有相关处理的需求也就没必要抛出异常了。</li><li>当自己抛异常时通常抛的是<strong>Error</strong>类型，而不是其下的别的类型错误。</li></ul></li></ul><pre><code>// 抛出错误： throwfunction fn() &#123;    // 判断当前时间是否为奇数:    if(Date.now()%2 === 1) &#123;        console.log(&#39;是奇数，可以执行任务&#39;);    &#125; else &#123;        // 抛出异常，由调用者来处理：        // new出来一个Error，它是对象类型。里面参数是错误信息        thorw new Error(&#39;当前为偶数，无法执行&#39;);    &#125;&#125;// 当调用时，要先捕获(否则不执行):try &#123;    fn();&#125; catch (err) &#123;    alert(err.message);   // 给个错误提示的效果&#125;</code></pre><p>​              </p><hr><h2 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h2><h3 id="2-1-Promise的理解"><a href="#2-1-Promise的理解" class="headerlink" title="2.1 Promise的理解"></a>2.1 Promise的理解</h3><ul><li>Promise是JS中进行异步编程的新的解决方案（旧方法：纯回调）。</li><li>具体来讲：<ul><li><strong>语法上</strong>：Promise是一个构造函数。</li><li><strong>功能上</strong>：Promise对象用来封装一个异步操作并可以获取其结果。</li></ul></li></ul><h3 id="2-2-promise的状态改变"><a href="#2-2-promise的状态改变" class="headerlink" title="2.2 promise的状态改变"></a>2.2 promise的状态改变</h3><ul><li>pending变为resolved；</li><li>pending变为rejected。</li></ul><p>PS：</p><ul><li><strong>只有这2种</strong>。且一个promise对象只能改变一次。</li><li>成功&amp;失败都会有一个结果数据。</li><li>成功的结果数据称为value，失败的结果数据称为reason。</li></ul><hr><p>未完待续…….</p><h3 id="2-3-promise的基本流"><a href="#2-3-promise的基本流" class="headerlink" title="2.3 promise的基本流"></a>2.3 promise的基本流</h3><h3 id="2-4-promise的基本使用"><a href="#2-4-promise的基本使用" class="headerlink" title="2.4 promise的基本使用"></a>2.4 promise的基本使用</h3><h3 id="2-5-为什么使用promise"><a href="#2-5-为什么使用promise" class="headerlink" title="2.5 为什么使用promise"></a>2.5 为什么使用promise</h3><h3 id="2-6-如何使用promise"><a href="#2-6-如何使用promise" class="headerlink" title="2.6 如何使用promise"></a>2.6 如何使用promise</h3><hr><h2 id="3-手写promise"><a href="#3-手写promise" class="headerlink" title="3. 手写promise"></a>3. 手写promise</h2><hr><h2 id="4-async-amp-await"><a href="#4-async-amp-await" class="headerlink" title="4. async &amp; await"></a>4. async &amp; await</h2><p>补充：<a href="https://zhuanlan.zhihu.com/p/26260061">https://zhuanlan.zhihu.com/p/26260061</a></p><hr><h2 id="5-JS异步——宏队列和微队列"><a href="#5-JS异步——宏队列和微队列" class="headerlink" title="5. JS异步——宏队列和微队列"></a>5. JS异步——宏队列和微队列</h2><p>完整笔记：<a href="note://WEBb2bc4bcd1fe230dba73429e31b71de72">事件循环event loop</a></p><hr><h2 id="6-promise练习题"><a href="#6-promise练习题" class="headerlink" title="6. promise练习题"></a>6. promise练习题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;关联笔记&lt;/strong&gt;：&lt;a href=&quot;note://WEBcaea4312c824c3e5ed720687a4dde45f&quot;&gt;Promise补充&lt;/a&gt;    &lt;a href=&quot;note://WEBb2bc4bcd1fe230dba73429e31b</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://polariis.gitee.io/tags/JavaScript/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>axios封装</title>
    <link href="https://polariis.gitee.io/posts/876a38c0/"/>
    <id>https://polariis.gitee.io/posts/876a38c0/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2023-02-06T18:43:24.682Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h2 id="1-axios全局配置"><a href="#1-axios全局配置" class="headerlink" title="1. axios全局配置"></a>1. axios全局配置</h2><ul><li>有些信息是重复的，比如：baseUrl、header、超时时间。</li></ul><pre><code>axios(&#123;    baseURL: &#39;http://xxx&#39;,    timeout: 5000,    url: &#39;/home/multidata&#39;&#125;)</code></pre><ul><li>所以这些重复的可以写为全局配置：</li></ul><pre><code>axios.defaults.baseURL= &#39;http://xxx&#39;axios.defaults.timeout= 5000axios(&#123;    url: &#39;/home/multidata&#39;&#125;)</code></pre><p>​          </p><p><strong>常见配置选项：</strong></p> <img src="https://s2.loli.net/2022/10/05/l5DkjCtx6df3uhL.png" alt="image-20221005170242319" style="zoom:67%;" /><h2 id="2-axios的实例和模块封装"><a href="#2-axios的实例和模块封装" class="headerlink" title="2. axios的实例和模块封装"></a>2. axios的实例和模块封装</h2><h3 id="2-1-创建实例"><a href="#2-1-创建实例" class="headerlink" title="2.1 创建实例"></a>2.1 创建实例</h3><p>当有多个服务器地址时，配置会不一样，所以每个都创建一个实例互不干扰。</p><p>例：</p><pre><code>// 创建实例：const instance1 = axios.create(&#123;    baseURL: &#39;http://xxx&#39;,    timeout: 5000&#125;)instance1(&#123;    url: &#39;&#39;,    params: &#123;        page: 1    &#125;&#125;)</code></pre><h3 id="2-2-axios模块封装（回调函数的方式，关于promise方式这里未记录）"><a href="#2-2-axios模块封装（回调函数的方式，关于promise方式这里未记录）" class="headerlink" title="2.2 axios模块封装（回调函数的方式，关于promise方式这里未记录）"></a>2.2 axios模块封装（回调函数的方式，关于promise方式这里未记录）</h3><p><strong>Step1</strong>. 创建network文件夹，新建request.js文件：</p><pre><code>// 引入axios:import axios from &#39;axios&#39;;// 多传递两个参数: success成功和failure失败，而它们刚好是函数：export function request(config, success, failure) &#123;    // 创建axios实例：    const instance = axios.create(&#123;        baseURL: &#39;&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    instance(config).then(res =&gt; &#123;        // 成功就调用success函数并传值：        success(res);    &#125;).catch(err =&gt; &#123;        failure(err);    &#125;)&#125;</code></pre><p><strong>Step2</strong>. 使用：（我先放在了main.js中）</p><pre><code>// 先引入方法：import &#123; request &#125;from &#39;@network/request&#39;;request(&#123;    // config配置：    url: &#39;/home/multidata&#39;     // 成功回调：&#125;, res =&gt; &#123;    // 这里拿到成功结果：    console.log(res);&#125;, err =&gt; &#123;    console.log(err);&#125;)</code></pre><h3 id="2-3-上段封装的代码简写"><a href="#2-3-上段封装的代码简写" class="headerlink" title="2.3 上段封装的代码简写"></a><strong>2.3 上段封装的代码简写</strong></h3><ul><li>相当于只有一个参数，之前的三个参数以对象属性的方式放进了这一个大的对象里。   </li></ul><pre><code>export function request(config) &#123;    // 1. 创建axios实例:    const instance = axios.create(&#123;        baseURL: &#39;http://123/207.32.32:8000&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    return instance(config);&#125;</code></pre><p>别的js文件引用后：</p><pre><code>request(&#123;    url: &#39;./home/multidata&#39;&#125;).then(res =&gt; &#123;    console.log(res);&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)</code></pre><p>下面这种暂时别看：</p><pre><code>export function request(config) &#123;    // 1. 创建axios实例:    const instance = axios.create(&#123;        baseURL: &#39;http://123/207.32.32:8000&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    instance(config.baseConfig).then(res =&gt; &#123;        config.success(res);    &#125;).catch(err =&gt; &#123;        config.failure(err);    &#125;);&#125;</code></pre><p>​           </p><pre><code>// 别的js文件调用：request(&#123;    baseConfig: &#123;            &#125;,    success: function(res) &#123;            &#125;,    failure: function(err) &#123;            &#125;&#125;)</code></pre><h3 id="2-4-关于封装的补充说明"><a href="#2-4-关于封装的补充说明" class="headerlink" title="2.4 关于封装的补充说明"></a>2.4 关于封装的补充说明</h3><ul><li>关于本篇笔记<strong>2.2小节</strong>两个步骤的代码块中回调的理解。</li></ul><p><strong>举个例子</strong>：</p><pre><code>// 这样写函数直接就执行完了，没有回调：function test() &#123;&#125;test();</code></pre><p>​           </p><ul><li>所以改成test函数的参数是函数的形式：</li></ul><pre><code>// 现在要拿到成功和失败的回调，所以需要函数在适当的时候被调用来触发操作（想象vue父子组件传值中的通过函数传递的方法，就是通过其参数也是函数的形式。）function test(aaa, bbb) &#123;    // 调用函数aaa，触发执行调用aaa函数体：        aaa();&#125;// 调用test函数test(function() &#123;     // 这里面就相当于aaa函数：&#125;, function() &#123;    // 这里面就相当于bbb函数：&#125;)</code></pre><p>​            </p><ul><li>加上打印后看下顺序：（33， 11， 44， 22）</li></ul><pre><code>    // 声明test，此时函数体里未执行：    function test(aaa, bbb) &#123;      // 第2个打印：      console.log(11);      aaa();      // 最后一个打印，因为被aaa的调用插了队。      console.log(22);    &#125;        // 第一个打印    console.log(33);                 // 看到有调用，就立马去执行test函数体里的代码。然后看到了调用aaa，同理立马去找aaa。    test(function () &#123;      // 这里是aaa函数，所以被上面test里调用后立马找到这里执行。第3个打印：      console.log(44);    &#125;, function () &#123;      // 55没被打印是因为没调用bbb:      console.log(55);    &#125;)</code></pre><ul><li>在上面的基础上，<strong>回归正题</strong>：</li></ul><pre><code>function test(aaa, bbb) &#123;    // 在这里回调的时候就把值传过去了：    aaa(&#39;我是res的实参&#39;);    bbb(&#39;我是err的实参&#39;)&#125;test(function(res) &#123;    // 这时就可以拿到aaa被调用时传过来的值：    console.log(res);           //  结果为： 我是res的实参&#125;, function(err) &#123;    console.log(err);&#125;)</code></pre><ul><li>所以基于以上，<strong>2.2小节</strong>中<strong>封装axios是一样的思想</strong>，<strong>只不过分开放在了两个js文件中&amp;增加了导入导出。</strong></li></ul><p>（视频讲解：<a href="https://www.bilibili.com/video/BV15741177Eh?p=147&amp;t=234.1%EF%BC%89">https://www.bilibili.com/video/BV15741177Eh?p=147&amp;t=234.1）</a></p><p>另外关于<strong>结合函数柯里化</strong>的封装方式：<a href="note://BF135A654F4D410C8D4522384737DFC2">JS函数柯里化</a></p><hr><p>整理后的版本：</p><ul><li>参考自：<a href="https://www.bilibili.com/video/BV1QA411b7TR?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f">https://www.bilibili.com/video/BV1QA411b7TR?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f</a></li></ul><p>​                              </p><p>1.</p><img src="https://s2.loli.net/2022/10/05/rl4mQRtgE2HyzFv.png" alt="image-20221005170856416" style="zoom: 80%;" /><p>2.</p>   <img src="https://s2.loli.net/2022/10/05/mOgRowl9udF1x7B.png" alt="image-20221005170948944" style="zoom:80%;" /><p>通过config，统一res，err。</p><p>3.通过promise</p><img src="https://s2.loli.net/2022/10/05/htNxGyLMcnoCzde.png" alt="image-png" style="zoom: 80%;" /><p>4.axios本事返回就是promise，所以直接把第三种简写为</p><img src="https://s2.loli.net/2022/10/05/D8JOdSoVflLmP6E.png" alt="image-png" style="zoom: 80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;/p&gt;
&lt;h2 id=&quot;1-axios全局配置&quot;&gt;&lt;a href=&quot;#1-axios全局配置&quot; class=&quot;headerlink&quot; title=&quot;1. axios全局配置&quot;&gt;&lt;/a&gt;1. axios全局配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有些信息是重复的，比如：b</summary>
      
    
    
    
    <category term="Axios" scheme="https://polariis.gitee.io/categories/Axios/"/>
    
    
    <category term="Axios" scheme="https://polariis.gitee.io/tags/Axios/"/>
    
    <category term="更新中" scheme="https://polariis.gitee.io/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    
  </entry>
  
</feed>
