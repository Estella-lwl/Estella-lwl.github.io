<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于TS中描述Object类型的两种方式（类型签名和Record）</title>
      <link href="posts/61dca9cf/"/>
      <url>posts/61dca9cf/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong> ：由于Object的范围很大，对象中属性可能是任意类型，而这时区分不出一个Object具体是什么类型。</p><p>所以一般不在TS中直接使用Object类型，而是以下两种方式描述对象：</p><ol><li><strong>class / constructor</strong>；</li><li><strong>type</strong>或<strong>interface</strong>，推荐用这种，更灵活。</li></ol><h2 id="方式一：类型签名"><a href="#方式一：类型签名" class="headerlink" title="方式一：类型签名"></a>方式一：类型签名</h2><p>举例1：</p><pre><code>type Obj = &#123;    [K: string]: number  //代表Obj中有一个字符串类型属性（具体属性名可以随便取只要是字符串就可），其属性值是数字。&#125;</code></pre><ul><li><ul><li>使用上有个共识，如果是泛型使用大写K；若非泛型，是用小写k。</li></ul></li></ul><p>上例基础上举例2：</p><pre><code>type Obj = &#123;    [K: string]: number &#125;const a: Obj = &#123;    name: 1    123： 6  //虽然使用type规定了属性名为string，而这里写了数字，但会编译通过。&#125;</code></pre><ul><li><ul><li>例子中属性名的命名为数字编译会通过，是因为在JS层面：所有属性名最终被都是字符串形式。</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="C:/Users/%E5%A4%B1%E9%A2%91%E6%9C%AC%E4%BA%BA/AppData/Roaming/Typora/typora-user-images/image-20230211093401215.png" alt="image-20230211093401215"></h2><p>由例2引申的例3：JS中<strong>一个矛盾的情况</strong>。 （👈🏻看下面的总结，number类型也可以）</p><pre><code>type Obj = &#123;    [K: number]: number   //注意看这里，给属性名规定为number类型。&#125;const a: Obj = &#123;    name: 1   //这里无法编译通过，因为JS中所有key都是字符串（string或symbol）。    123： 6   //奇怪的在这行，既然key只能字符串但这里number居然编译通过了！！！！！&#125;</code></pre><ul><li><ul><li><strong>PS</strong>：<strong>当symbol作为key</strong>，必须<strong>用中括号包</strong>一下。</li><li>这篇文章中提到了这个情况：<a href="https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html#typescript-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D">深入理解TS——签名索引</a></li></ul></li><li></li></ul><p>综上，<strong>总结</strong>：</p><ul><li><p>对象中key的类型可以不是string吗？</p></li><li><ul><li>还可以是symbol或number。</li></ul></li></ul><p><strong>方式二：Record</strong></p><p>其余待整理</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新中 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS获取视频任意进度</title>
      <link href="posts/5ced3654/"/>
      <url>posts/5ced3654/</url>
      
        <content type="html"><![CDATA[<ul><li><p>利用视频的<span style="color: #0091ff;background-color: #f2f4f5;"> duration </span>获取视频相关信息。</p></li><li><p>利用<span style="color: #0091ff;background-color: #f2f4f5;"> addEventListener </span>事件监听的相关事件👇🏻，可以获取各个播放进度&amp;在不同阶段操作数据。</p><ul><li><span style="color: #678f00">play</span>： 视频开始播放 。</li><li><span style="color: #678f00">playing</span>： 视频播放过程中 。</li><li><span style="color: #678f00">ended</span>： 视频结束播放 。</li><li><span style="color: #678f00">loadedmetadata </span>事件： 音频/视频的元数据已加载时（时长、尺寸（仅视频）以及文本轨道）。</li></ul></li><li><p>当 音频/视频 处于加载过程中时，会 依次发生 以下事件：</p></li><li><ol><li><span style="color: #3850b8">loadstart</span></li><li><span style="color: #3850b8">durationchange</span></li><li><span style="color: #3850b8">loadedmetadata</span></li><li><span style="color: #3850b8">loadeddata</span></li><li><span style="color: #3850b8">progress</span></li><li><span style="color: #3850b8">canplay</span></li><li><span style="color: #3850b8">canplaythrough</span></li></ol></li></ul><p><span style="color: #CC0000">1.</span> 在视频第6秒时显示一个按钮：</p><pre><code>    function videoInit() &#123;      let elevideo = document.getElementById(&#39;video2&#39;);      elevideo.addEventListener(&#39;loadedmetadata&#39;, () =&gt; &#123;        //视频的总长度        console.log(&#39;总长度:&#39;, elevideo.duration);        clearInterval(this.timer);      &#125;);            elevideo.addEventListener(&#39;play&#39;, () =&gt; &#123;        //播放开始执行的函数        console.log(&#39;开始播放&#39;);      &#125;);            elevideo.addEventListener(&#39;playing&#39;, () =&gt; &#123;        //播放中        console.log(&#39;播放中&#39;);        this.timer = setInterval(() =&gt; &#123;          console.log(&#39;播放进度:&#39; + parseFloat(elevideo.currentTime));          if (parseInt(elevideo.currentTime) === 6) &#123;            const btn = document.querySelector(&#39;.main-button&#39;)            btn.classList.remove(&#39;main-button-hide&#39;)          &#125;        &#125;, 100);      &#125;);            elevideo.addEventListener(&#39;ended&#39;, () =&gt; &#123;        //结束        console.log(&#39;播放结束&#39;);        clearInterval(this.timer);      &#125;,false);          &#125;;    videoInit();</code></pre><p><span style="color: #CC0000">2.</span> 改进：</p><pre><code>      eleVideo.addEventListener(&#39;playing&#39;, () =&gt; &#123;        //播放中        console.log(&#39;播放中&#39;);        const timer = setInterval(() =&gt; &#123;          console.log(&#39;播放进度:&#39; + parseFloat(eleVideo.currentTime));          if (Math.round(eleVideo.currentTime) === 6) &#123;            const btn = document.querySelector(&#39;.main-button&#39;)            btn.classList.remove(&#39;main-button-hide&#39;)          &#125;          if (eleVideo.currentTime &gt; 6) &#123;            console.log(&#39;结束监听&#39;);            clearInterval(timer);          &#125;        &#125;, 1000);      &#125;);</code></pre><p><span style="color: #CC0000">3.</span> 改进使用video的 currentTime 事件后：</p><pre><code>    function videoInit() &#123;      let eleVideo = document.getElementById(&#39;videoEl&#39;);      eleVideo.addEventListener(&#39;timeupdate&#39;, () =&gt; &#123;        console.log(&#39;播放中&#39;);        if (Math.round(eleVideo.currentTime) === 6) &#123;          console.log(&#39;第6秒了&#39;);          const btn = document.querySelector(&#39;.main-button&#39;)          btn.classList.remove(&#39;main-button-hide&#39;)        &#125;      &#125;)    &#125;;    videoInit();</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS精度丢失&amp;解决</title>
      <link href="posts/7fcf66dd/"/>
      <url>posts/7fcf66dd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>0.1 + 0.2 !== 0.3;</p></blockquote><p><span style="color: #0091ff"><strong>精度丢失的原因</strong></span>：</p><ul><li>计算机中所有的数据都是以<span style="color: #ff0001">二进制</span>存储的，所以在计算时计算机要把数据先转换成<span style="color: #ff0001">二进制</span>进行计算，然后在把计算结果转换成<span style="color: #ff0001">十进制</span>。</li><li><span style="color: #ff0001">二进制</span>计算发生了精度丢失，导致再转换成<span style="color: #ff0001">十进制</span>后和预计的结果不符。</li></ul><p><span style="color: #0091ff"><strong>解决</strong></span>：</p><p><span style="color: #0091ff">1.</span> 把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。</p><p>0.1 + 0.2；改为 (0.1<em>10 + 0.2</em>10) / 10 == 0.3；  // true</p><p><span style="color: #0091ff">2.</span> </p><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘&amp;回流(重排)</title>
      <link href="posts/b4912e11/"/>
      <url>posts/b4912e11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重绘：repaint；</p><p>回流/重排：reflow。</p></blockquote><ul><li><span style="color: #0091ff">重绘</span>：不影响任何布局的style变化。<ul><li>color、text-align、a: hover、</li><li>重绘的速度会明显快于回流。</li></ul></li><li><span style="color: #0091ff">回流</span>：引起布局改变的style变化。<ul><li>长/宽/高、border、display、窗口大小、字体大小、margin/padding、动画、读取元素的属性（offsetLeft等）鼠标滑过/点击/scroll。</li><li>有些属性是避免不了会引起回流的，但有些可以优化掉。</li></ul></li></ul><p><strong>PS</strong>：</p><ul><li>回流必定引起重绘。因为布局改变 =》相应的样式也会重新渲染</li></ul><p><strong>减少重绘和回流的方式</strong>：</p><ol><li>不通过父级来改变子元素样式，最后直接设置子元素样式；</li><li>改变子元素样式尽量避免影响父元素&amp;兄弟元素的大小尺寸。</li><li>使用 transform 替代 top。</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局)。</li><li>防抖、节流。</li><li>尽量避免使用table布局。</li><li>避免一条一条的改变DOM样式</li><li>给动画的 HTML 元件使用 position: fixed 或 absoult，修改他们的CSS不会 reflow，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li><li>使用Flexbox布局模型比基于浮动的布局模型的性能更快</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3语法变更总结</title>
      <link href="posts/97e721dd/"/>
      <url>posts/97e721dd/</url>
      
        <content type="html"><![CDATA[<h2 id="1-生命周期的变更"><a href="#1-生命周期的变更" class="headerlink" title="1.生命周期的变更"></a>1.生命周期的变更</h2><ul><li><p>销毁的概念改为<strong>卸载</strong>，更名：</p><ul><li>beforeDestroy改名为<span style="background-color: #f2f4f5;color: darkblue;">beforeUnmounted</span>。</li><li>destroyed改名为<span style="background-color: #f2f4f5;color: darkblue;">unmounted</span>。</li></ul></li><li><p>vue2中的两次判断改为一次（如图）。</p><p><img src="https://s2.loli.net/2022/08/10/9kmtAb8YxeMSqQV.png" alt="image-20220810114820457"></p></li><li><p>Vue3提供的**<span style="color: #0089FB;">Composition API</span>**形式对比：</p><ul><li>beforeCreate     =&gt;     <span style="color: #E95200;">setup()</span></li><li>created     =&gt;     <span style="color: #E95200;">setup()</span></li><li>beforeMount     =&gt;     <span style="color: #E95200;">onBeforeMount</span></li><li>mounted         =&gt;     <span style="color: #E95200;">onMounted</span></li><li>beforeUpdate      =&gt;     <span style="color: #E95200;">onBeforeUpdate</span></li><li>updated         =&gt;     <span style="color: #E95200;">onUpdated</span></li><li>beforeUnmounted     =&gt;     <span style="color: #E95200;">onBeforeUnmounted</span></li><li>unmounted     =&gt;     <span style="color: #E95200;">onUnmounted</span></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p><ul><li>下图打印结果可以看到：setup中的<span style="color: #FFB700;">组合式API优先级更高</span>。</li></ul><img src="https://s2.loli.net/2022/08/10/c82bMyzlovfEU9j.png" style="zoom:80%;" /></li></ul><hr><h2 id="2-setup函数"><a href="#2-setup函数" class="headerlink" title="2. setup函数"></a>2. setup函数</h2><h3 id="2-1-setup的两个注意点："><a href="#2-1-setup的两个注意点：" class="headerlink" title="2.1 setup的两个注意点："></a>2.1 setup的两个注意点：</h3><ul><li><p><strong>setup执行时机</strong>：</p><ul><li>在beforeCreated之前执行一次，并且this是undefined。</li></ul></li><li><p><strong>setup接收两个参数</strong>：</p><ul><li><p>1.**<span style="color: #0089FB;">props</span>**：值为对象。包含：组件外部传递进来，且在组件内部声明接收了的属性。</p><ul><li>当子组件传了，父组件却没接收/接收少了，都会控制台警告。接收多了则会拿到undefined。</li></ul></li><li><ol start="2"><li><p>**<span style="color: #0089FB;">context</span>**：<span style="background-color: #E9E9E9;color: #0089FB;">上下文对象</span></p><ul><li><p>**<span style="color: #E95200;">attrs</span>**：值为对象。包含：组件外部传递过来但没有在props配置中生命的属性，相当于this.$attrs。</p></li><li><p>**<span style="color: #E95200;">slots</span>**：收到的插槽内容，相当于this.$slots。</p></li><li><p>**<span style="color: #E95200;">emit</span>**：分发自定义事件的函数，相当于this.$emit。</p></li></ul></li></ol></li></ul></li></ul><h3 id="2-2-setup语法糖"><a href="#2-2-setup语法糖" class="headerlink" title="2.2 setup语法糖"></a>2.2 setup语法糖</h3><ul><li> <span style="color: #E95200;"><code>&lt;script setup&gt;</code></span>是单文件组件使用组合式API（上面笔记代码中）的语法糖。里面的代码会被编译为setup函数的内容。</li><li>无需export default，里面也不用return。</li><li>官方文档描述：<a href="https://staging-cn.vuejs.org/guide/introduction.html#api-styles">https://staging-cn.vuejs.org/guide/introduction.html#api-styles</a></li></ul><p><strong>什么时候使用</strong><span style="color: #E95200;"><code>setup()</code></span>：</p><p><img src="https://s2.loli.net/2022/08/18/LVO2ayMNCs3rB5p.png" alt="image-20220818121239514"></p><hr><h3 id="2-3-其他补充"><a href="#2-3-其他补充" class="headerlink" title="2.3 其他补充"></a>2.3 其他补充</h3><h4 id="1-vue3中插槽的使用变更："><a href="#1-vue3中插槽的使用变更：" class="headerlink" title="1. vue3中插槽的使用变更："></a>1. vue3中插槽的使用变更：</h4><ul><li>在vue3中使用插槽尽量用<code>v-slot</code>。</li><li>vue2中template里使用插槽可以使用：1. <code>name=&quot;xxx&quot;</code>  2. <code>v-slot=&quot;xxx&quot;</code>  。但由于vue3的兼容问题，使用第一种方法依旧显示的是默认插槽，自定义插槽名会失效。</li></ul><h4 id="2-vue3中props接收数据："><a href="#2-vue3中props接收数据：" class="headerlink" title="2. vue3中props接收数据："></a>2. vue3中props接收数据：</h4><p><strong>vue2中props接收数据</strong>：</p><ul><li>如果不用props，在VC的实例对象中也能拿到，通过<code>this.$attrs</code>；但如果使用props后，attrs中的数据就会消失（attrs就像捡漏）。</li></ul><hr><h2 id="3-Ref"><a href="#3-Ref" class="headerlink" title="3. Ref"></a>3. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：<code>const xxx = ref(initValue)</code>  </p><ul><li>创建一个包含响应式数据的<span style="color: #ff0001;">引用对象（reference对象）</span>。</li><li>模板中使用引用对象不用后面加.value，而<span style="color: #CC0000;">setup中使用该值时需要加.value</span>。</li></ul></li><li><p><strong>接收的数据</strong>：</p><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">基本类型： 响应式</span></strong><span style="background-color: #f2f4f5;color: darkblue;">依旧使用是<strong>defineProperty</strong></span> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong><span style="background-color: #f2f4f5;color: darkblue;">对象类型</span></strong><span style="background-color: #f2f4f5;color: darkblue;">时使用<strong>proxy</strong>实现的</span>（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要<span style="color: #FFB700;"> .value</span> 是因为<span style="color: #FFB700;">Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化</span>。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p>**<span style="color: darkblue;">注意：</span><strong>如果要在setup中拿到DOM元素，声明的变量名<span style="color: #ff0001;">必须与元素中写的ref</span></strong><span style="color: #CC0000;">一致</span>**。</p><pre><code>&lt;template&gt;  &lt;div id=&quot;countBox&quot; ref=&quot;countupRef&quot;&gt;    &lt;span class=&quot;countSpan&quot;&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p>在**<span style="background-color: #f2f4f5;color: darkblue;">onMounted</span>**中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="4-reactive"><a href="#4-reactive" class="headerlink" title="4. reactive"></a>4. reactive</h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：<code>const 代理对象 = reactive(源对象);</code>  接收一个对象或数组，返回一个**<span style="color: #CC0000;">代理对象</span>**<span style="color: #ff0001;">（Proxy的实例对象，简称proxy对象）</span>。</p><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul><p><img src="https://s2.loli.net/2022/08/18/UschZL52Pi7kz81.png" alt="image.png"></p></li><li><p>reactive定义的响应式数据是”深层次的“。</p></li><li><p>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</p></li></ul><h2 id="5-ref对比reactive总结"><a href="#5-ref对比reactive总结" class="headerlink" title="5. ref对比reactive总结"></a><strong>5. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p><ul><li>ref定义：<span style="color: #ff0001;">基本类型数据</span>。</li><li>reactive定义：<span style="color: #ff0001;">对象/数组类型数据</span>。</li><li><span style="color: #0089FB;">注意</span>：ref也可以定义对象/数组类型数据，它内部会自动通过<code>reactive</code><span style="color: #ff0001;">转为代理对象</span>。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p><ul><li>ref：通过<span style="color: #CC0000;"><code>Object.defineProperty()</code></span>的<code>get</code>和<code>set</code>实现响应式（数据劫持）。</li><li>reactive：通过使用<span style="color: #CC0000;"><code>Proxy</code></span>实现响应式（数据劫持），并通过<span style="color: #CC0000;"><code>Reflect</code></span>操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p><ul><li>ref定义的数据：操作数据<span style="color: #CC0000;">需要</span>.value，读取数据时模板会直接读取<span style="color: #CC0000;">不用</span><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据<span style="color: #CC0000;">均不需要</span><code>.value</code>。</li></ul></li></ul><h2 id="6-Vue2-amp-Vue3响应式原理对比"><a href="#6-Vue2-amp-Vue3响应式原理对比" class="headerlink" title="6. Vue2&amp;Vue3响应式原理对比"></a><strong>6. Vue2&amp;Vue3响应式原理对比</strong></h2><h3 id="6-1-Vue2的响应式"><a href="#6-1-Vue2的响应式" class="headerlink" title="6.1 Vue2的响应式"></a>6.1 Vue2的响应式</h3><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</li><li><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。<ul><li>比如：调用push方法，其实调用的是vue2二次封装后的push。</li><li>这个push里做了两件事：<ul><li>1.帮助正常调用push方法。</li><li>2.帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre> <img src="https://s2.loli.net/2022/08/18/KywkVsvl6uzL3CS.png" alt="image.png" style="zoom: 67%;" /></li><li><p><strong>Object.defineProperty</strong>:</p><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="6-2-Vue3的响应式"><a href="#6-2-Vue3的响应式" class="headerlink" title="6.2 Vue3的响应式"></a><strong>6.2 Vue3的响应式</strong></h3><h4 id="6-2-1实现原理："><a href="#6-2-1实现原理：" class="headerlink" title="6.2.1实现原理："></a><strong>6.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p><ul><li><strong>Proxy</strong>： window上内置的，接收<strong>两个参数</strong>（<span style="color: #FFB700;">必填</span>）：<strong>1</strong>. target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的**<span style="color: #ff0001;">reflect</span>**。）</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><img src="https://s2.loli.net/2022/08/18/CiEjvBrpIYJAsm5.png" alt="image.png" style="zoom: 67%;" /><h4 id="6-2-2-响应式中Reflect的应用："><a href="#6-2-2-响应式中Reflect的应用：" class="headerlink" title="6.2.2. 响应式中Reflect的应用："></a>6.2.2. 响应式中<span style="color: #ff0001;">Reflect</span>的应用：</h4><ul><li><p><strong>ES6</strong>，**<span style="color: #0089FB;">Windows内置</span>**。</p></li><li><p>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</p></li><li><p>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</p></li></ul><p><strong>与Object.definProperty<span style="color: #CC0000;">对比</span>：</strong></p><ul><li><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></li><li><strong>模Vue3中实现响应式</strong>（使用<strong>reflect</strong><span style="color: #ff0001;">改进后</span>）：<ul><li>用到了proxy代理对象，及reflect反射对象。</li></ul></li></ul><pre><code>// 模拟Vue3中实现响应式：const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre><hr><h2 id="7-toRef-amp-toRefs"><a href="#7-toRef-amp-toRefs" class="headerlink" title="7. toRef &amp; toRefs"></a>7. toRef &amp; toRefs</h2><h3 id="1-toRef"><a href="#1-toRef" class="headerlink" title="1. toRef"></a>1. toRef</h3><ul><li><p><strong>作用</strong>：创建个ref对象，其value的值指向另一个对象的某个属性。</p></li><li><p><strong>应用</strong>：要将响应式对象中的某个</p></li><li><p><strong>参数</strong>：1.目标对象；2.属性名。</p><ul><li><strong>举例</strong>：</li></ul><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre></li><li><p>和ref的区别：</p></li></ul><p>​    <strong>对比</strong>：</p><pre><code>let person = reactive(&#123;    name: &#39;&#39;,    hobby: &#123;        food: &#39;&#39;        &#125;&#125;)// 这里拿到的只是一个属性值：const name = person.name;console.log(&#39;name&#39;, name)// 使用toRef：const name2 = toRef(person, &#39;name&#39;);// 此时name不再是一个值，而是包在ref对象里的属性。console.log(&#39;name2&#39;, name2)</code></pre><p>如果要在setup函数return中：</p><p><strong>注意</strong>：这里return中ref也可以但ref生成的是新的数据，但使用toRef数据依旧是保持联系的。这是<strong>两者的区别</strong>。</p><pre><code>return &#123;    name: toRef(person, &#39;name&#39;);    food: toRef(person.hobby, &#39;food&#39;)&#125;</code></pre><p>当setup中的数据，return一个对象类型数据后，模板中每次使用都需要对象.xxxx。当在return时就写好对象.xxxx的话，会出现一种情况：数据不再是响应式。</p><p><strong>举例验证一下原因</strong>：</p><p>相当于：最后一行name是另外新定义的，和<code>p.name</code>没任何关联，所以响应式会没了。</p><img src="https://s2.loli.net/2022/08/18/ifGqWZsKODSmjhy.png" alt="image.png" style="zoom: 67%;" /><h3 id="2-toRefs"><a href="#2-toRefs" class="headerlink" title="2. toRefs"></a>2. toRefs</h3><ul><li><strong>作用</strong>：需要使用<span style="color: #0089FB;">多个toRef</span>时，可以用toRefs简写。</li><li><strong>使用</strong>：只需给一个参数。无需重复给多个属性写toRef。</li><li><strong>语法</strong>：toRefs(obj)</li></ul><p><strong>注意</strong>：</p><ul><li>return的时候不能直接就用，return的是对象，而toRefs返回的也是对象，直接写会报错。</li><li>按照这种格式（<span style="color: #FFB700;"><strong>…obj</strong></span>）：</li></ul><pre><code>return &#123;    // 这样数据的格式才正确：    ...toRefs(person)&#125;</code></pre><hr><h2 id="8-computed、watch与watchEffect"><a href="#8-computed、watch与watchEffect" class="headerlink" title="8. computed、watch与watchEffect"></a>8. computed、watch与watchEffect</h2><h3 id="1-computed"><a href="#1-computed" class="headerlink" title="1. computed"></a>1. computed</h3><ul><li>与vue2中computed配置功能一致。</li><li>写法：</li></ul><pre><code>import &#123; computed &#125; from &#39;vue&#39;;...    // vue3中computed与vue2语法一样：    let personObj = computed(&#123;      name: &#39;a&#39;,      age: 22    &#125;);</code></pre><p>完整：</p><img src="https://s2.loli.net/2022/08/18/O5n2zmlfTRqIHN1.png" alt="image.png" style="zoom:50%;" /><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2. watch函数"></a>2. watch函数</h3><ul><li>与vue2中配置功能一致。</li><li>两个小坑：<ul><li>监视<code>reactive</code>定义的响应式数据时：<span style="color: #CC0000;">oldValue无法正确获取；强制开启了深度监视（deep配置失效）</span>。</li><li>监视<code>reactive</code>定义的响应式数据中的<strong>某个属性</strong>时：<span style="color: #CC0000;">deep配置有效</span>。</li></ul></li></ul><h4 id="2-1-vue3中watch的变化："><a href="#2-1-vue3中watch的变化：" class="headerlink" title="2.1 vue3中watch的变化："></a>2.1 vue3中watch的变化：</h4><ul><li><p>watch能传递<strong>3个参数</strong>：</p><ul><li>监视谁：字符串/数组。</li><li>监视的回调：函数。</li><li>配置项：对象。</li></ul></li><li><p>监视reactive所定义的数据时，默认开启deep深度监视。且修改无效。</p></li><li><p><strong>immediate配置项</strong>的使用：</p><ul><li>情况1&amp;2中，配置有效。</li></ul></li><li><p><strong>deep配置项</strong>的使用：</p><ul><li>当监视的数据由<code>reactive</code><strong>直接管理时</strong>，<strong>deep默认开启</strong>。</li><li>当嵌套层级较深，则需<strong>手动配置</strong>开启。</li></ul></li><li><p><strong>获取不到oldValue</strong>的情况：可以总结为当是复杂数据类型时就获取不到。</p></li></ul><h4 id="2-2-六种使用情况："><a href="#2-2-六种使用情况：" class="headerlink" title="2.2 六种使用情况："></a>2.2 六种使用情况：</h4><p><span style="color: #0089FB;">1. </span>监视<span style="color: #2742B2;">一个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">2. </span>监视<span style="color: #2742B2;">多个ref</span>定义的数据                    <code>基本数据类型。immediate可用；deep无需配置</code></p><p><span style="color: #0089FB;">3. </span>监视<span style="color: #2742B2;">reactive定义的全部数据</span>                      <code>deep配置无效；oldValue无法获取</code></p><p><span style="color: #0089FB;">4. </span>监视<span style="color: #2742B2;">一个reactive</span>定义的数据中的属性         <code>监视的属性要写为函数形式；oldValue可获取</code></p><p><span style="color: #0089FB;">5. </span>监视<span style="color: #2742B2;">多个reactive</span>定义的数据中的属性             <code>监视的属性要写在数组里且每项都是函数；oldValue可获取</code></p><p><span style="color: #0089FB;">6. </span><strong>特殊的情况</strong>：监视<span style="color: #2742B2;">reactive定义的数据中的对象</span>属性     <code>对象嵌套对象所以deep配置有效；oldValue无法获取</code></p><p><strong>全部代码示例：</strong></p><pre><code>const num = ref(0);const msg = ref(&#39;hello&#39;);let obj = reactive(&#123;  name: &#39;&#39;,  age: 30,  hobby: &#123;    food: &#39;anything&#39;  &#125;&#125;);// 情况1. 当监视一个ref定义的数据时：watch(  num,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况2. 当监视多个ref定义的数据时：watch(  [num, msg],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; immediate: false &#125;);// 情况3. 当监视reactive定义的全部数据时：// 注意：//    1.此时无法拿到正确的oldValue。//    2.默认开启deep；且修改无效。watch(  obj.age,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况4. 当监视一个reactive定义的数据中的属性时：// 注意：当监视这种数据时，watch的第1个形参需要是一个函数，函数里要有返回值,监视谁就返回谁。// 这时oldValue正确。watch(  () =&gt; &#123;    return obj.age;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 情况5. 当监视多个reactive定义的数据中的属性时：// 注意：watch的第1个形参是一个数组，监视几个数据里面就包几个函数。// 这时oldValue正确。watch(  [    () =&gt; &#123;      return obj.name;    &#125;,    () =&gt; &#123;      return obj.age;    &#125;  ],  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);// 特殊的情况6. 当监视reactive定义的数据中的对象属性时：// 注意：当监视这种数据时，watch的第1个形参是函数。// oldValue无法获取。watch(  () =&gt; &#123;    return obj.hobby;  &#125;,  (newVal, oldVal) =&gt; &#123;    console.log(&#39;&#39;, newVal, oldVal);  &#125;,  &#123; deep: false &#125;);</code></pre><p><strong>注意：</strong></p><ul><li><p>使用watch监视基本数据类型时，别用<code>.value</code>，这样拿到的是一个属性真正的值而非属性。</p></li><li><p>但<span style="color: #E95200;">对象类型（ref定义时）</span>：要用<code>.value</code>才会被监测到。<strong>因为</strong><span style="color: #CC0000;">此时的value是由reactive函数生成的proxy实例对象</span>。</p><ul><li>除了上面的<code>.value</code>，还有一个办法：加配置项 <code>deep: true</code>; </li></ul></li></ul><hr><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3. watchEffect函数"></a>3. watchEffect函数</h3><ul><li><p>watchEffect也是一个监视函数，但它不用指明监视目标。<span style="color: #E95200;"><code>默认开启immediate: true</code></span>。</p></li><li><p><strong>参数</strong>：监视的回调</p></li><li><p><strong>作用</strong>：观察<span style="color: #E95200;">监视的回调中用到了谁</span>，智能的选择监视谁。<span style="color: #E95200;">可以监视深层级数据</span>。</p></li><li><p><strong>使用场景</strong>：不用再多次写watch函数然后按照不同数据的语法写。watchEffect会自动识别并监视。</p></li><li><p><code>watchEffect</code>有点像<code>computed</code>，具体**<span style="color: #CC0000;">区别</span>**：</p></li><li><p>1.**computed注重计算出来的<span style="color: #E95200;">值</span>**（回调函数的返回值），所以必须要有返回值。执行时机：初始化时；所依赖的数据发生变化时。</p></li><li><ol start="2"><li><strong>watchEffect要的是过程（使用了谁），不用返回值</strong>。watchEffect也是所依赖的数据发生变化时重新执行一次。</li></ol></li></ul><hr><h2 id="9-hook"><a href="#9-hook" class="headerlink" title="9. hook"></a>9. hook</h2><ul><li><p>本质是函数，把setup中使用的Composition API进行了封装。类似于vue2中的mixin。</p></li><li><p>自定义hook的优势：复用代码，让setup中的逻辑更清楚。</p></li><li><p>把该功能相关的数据、方法、生命周期钩子全都抽离出去。</p><ul><li>新建hook文件后，将以上内容都放在个函数里。</li></ul></li><li><p>ps：hook文件取名一般为useXxx。</p></li></ul><p><strong>使用示例</strong>：</p><ul><li><p>实现一个点击鼠标拿到坐标的功能：（完整代码在vue3-practice）</p><ul><li><strong>改为hook前</strong>：</li></ul><pre><code>&lt;script setup&gt;import &#123; reactive &#125; from &#39;@vue/reactivity&#39;;import &#123; onBeforeUnmount, onMounted &#125; from &#39;@vue/runtime-core&#39;;const position = reactive(&#123;  x: 0,  y: 0&#125;);// // 组件挂载后执行// onMounted(() =&gt; &#123;//   // 这种写法的问题：组件卸载前销毁该事件时无法操作：//   window.addEventListener(&#39;click&#39;, function (event) &#123;//     console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);//     // 数据为响应式：//     position.x = event.pageX;//     position.y = event.pageY;//   &#125;);// &#125;);// 基于以上问题，改为这样（将点击事件的回调拎出去）：onMounted(() =&gt; &#123;  // 事件回调写进来：  window.addEventListener(&#39;click&#39;, savePosition);&#125;);function savePosition(event) &#123;  console.log(&#39;FROM UseHook position: &#39;, event.pageX, event.pageY);  // 数据为响应式：  position.x = event.pageX;  position.y = event.pageY;&#125;// 需要注意的是，当组件被卸载时该事件也该失效，所以要在卸载前另外处理下：onBeforeUnmount(() =&gt; &#123;  // 这里需要两个参数：1.移除的事件；2.移除的事件所对应的回调。  window.removeEventListener(&#39;click&#39;, savePosition);&#125;);&lt;/script&gt;</code></pre><ul><li><strong>hook写法</strong>：   以下代码全都可以抽出去</li></ul></li></ul><img src="https://s2.loli.net/2022/08/18/L9qoVb2UTGaZnHu.png" alt="image.png" style="zoom:80%;" /><p>usePosition文件中：</p><pre><code>import &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;;// 默认暴露可以不用起名，汇依据使用时起的名字。export default function () &#123;  const position = reactive(&#123;    x: 0,    y: 0  &#125;);  function savePosition(event) &#123;    position.x = event.pageX;    position.y = event.pageY;    console.log(&#39;FROM UseHook position: &#39;, position.x, position.y);  &#125;  onMounted(() =&gt; &#123;    window.addEventListener(&#39;click&#39;, savePosition);  &#125;);  onBeforeUnmount(() =&gt; &#123;    window.removeEventListener(&#39;click&#39;, savePosition);  &#125;);  // 是函数，所以需要给返回值：  // 将组件中需要的数据传出去：  return position;&#125;</code></pre><hr><h2 id="10-其它Composition-API"><a href="#10-其它Composition-API" class="headerlink" title="10. 其它Composition API"></a>10. 其它Composition API</h2><h3 id="1-shallowReactive和shallowRef"><a href="#1-shallowReactive和shallowRef" class="headerlink" title="1. shallowReactive和shallowRef"></a><strong>1.</strong> shallowReactive和shallowRef</h3><ul><li><p><strong>shallowReactive：</strong>只处理对象中第一层的响应式，里层的不管（浅响应式）。</p></li><li><p><strong>shallowRef：</strong></p><ul><li>只处理基本类型，和ref的使用效果无区别。</li><li>当用来处理对象类型时，不再去借助reactive处理，而是直接不管了。</li></ul></li><li><p><strong>使用时机</strong>：</p><ul><li>如果一个对象数据，嵌套层级多，但只是外层属性变化(为了提升性能)。   ==》<span style="color: #FFB700;">shallowReactive</span></li><li>如果一个对象类型数据，后续使用不会修改对象中的属性(修改会失效)，而是生成新的对象替换。   ==》<span style="color: #FFB700;">shallowRef</span></li><li><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=158&amp;spm_id_from=pageDriver&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=636.4</a></li></ul></li></ul><h3 id="2-readOnly和shallowReadOnly"><a href="#2-readOnly和shallowReadOnly" class="headerlink" title="2. readOnly和shallowReadOnly"></a>2. readOnly和shallowReadOnly</h3><ul><li><strong>readOnly</strong>：让响应式数据变为只读状态（<span style="color: #FFB700;">深只读</span>）。</li><li><strong>shallowReadOnly</strong>：让响应式数据变为只读状态（浅只读，除第一层只读外，里层的还可以修改）。</li><li><strong>应用场景</strong>：让数据不被修改。</li></ul><h3 id="3-toRaw和markRaw"><a href="#3-toRaw和markRaw" class="headerlink" title="3. toRaw和markRaw"></a>3. toRaw和markRaw</h3><p>raw：原始的</p><ul><li><p><strong>toRaw</strong>：</p><ul><li><strong>作用</strong>：将<code>reactive</code>生成的响应式数据转为普通对象（ref不行）。</li><li><strong>使用场景</strong>：用于读取响应式对象对应的普通对象，使其所有操作都不会引起页面更新（数据会变但不响应式）。</li></ul></li><li><p><strong>markRaw</strong>：</p><ul><li><strong>作用</strong>：标记一个对象，使其之后不能再成为响应式对象。</li><li><strong>应用场景</strong>：（应用场景比<code>toRaw</code>广）<ul><li>1.不应该设为响应式的值，比如复杂的第三方类库等。</li><li>2.当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ul></li></ul></li></ul><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4. customRef"></a>4. customRef</h3><ul><li><strong>作用</strong>：创建一个自定义的ref，并跟踪其依赖项和更新触发进行显示控制。</li></ul><p><strong>使用示例</strong>：（完整代码在vue3-practice的useCustomRef中）</p><pre><code>import &#123; customRef &#125; from &#39;vue&#39;;// 使用customRef自定义一个ref：function myRef(initVal, delay) &#123;  // customRef接收两个参数：  return customRef((track, trigger) =&gt; &#123;    // 下面的返回是customRef规定的：    return &#123;      get() &#123;        console.log(&#39;正在读value：&#39;, initVal);        // 在return之前通知vue追踪数据        track();        return initVal;      &#125;,      set(newVal) &#123;        console.log(&#39;正在修改value：&#39;, newVal);        // // 只有把新值赋回给初始值的变量才能动态的变化起来：        // initVal = newVal;        // // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。        // trigger();        // 这离开了定时器会出现一个状况：当输入速度太快，等到了页面刷新时，部分被积压的输入被刷掉，页面上能看到输入在回退。        // 解决办法：先定义一个timer定时器，每次进来执行前先清除定时器。（参考js防抖的原理）        clearTimeout();        setTimeout(() =&gt; &#123;          // 只有把新值赋回给初始值的变量才能动态的变化起来：          initVal = newVal;          // 通知vue重新解析模板：所以这里可以自定义的使用值。比如规定3秒后再执行。          trigger();        &#125;, delay);      &#125;    &#125;;  &#125;);&#125;// 给myRef两个实参：1.initVal初始值；2.delay延迟执行的时间。let num = myRef(0, 500);console.log(&#39;myRef自定义的数据:&#39;, num);</code></pre><ul><li><p><strong>可以优化的地方</strong>：延迟执行的时间是写死的，可以写为动态改变的。（<strong>已改</strong>）</p><ul><li>实现：多传递一个变量（比如delay）。</li></ul></li><li><p>实参写在调用<code>myRef</code>时的<code>()</code>中。</p></li></ul><hr><h2 id="11-provide-amp-inject"><a href="#11-provide-amp-inject" class="headerlink" title="11. provide &amp; inject"></a>11. provide &amp; inject</h2><ul><li><p>provide和inject（注入）是一种组件间通信的方式。</p></li><li><p><strong>作用</strong>：实现祖孙组件间的通信。</p></li><li><p><strong>使用</strong>：父组件使用<span style="color: #FFB700;"><code>provide</code></span>提供数据，后代组件通过<span style="color: #FFB700;"><code>inject</code></span>接收使用数据。</p><ul><li>provide两个参数：1.给传递的数据起的名字；2.实参。</li><li>inject通过传递的参数名拿到真实数据。（如下代码块）</li></ul></li><li><p><strong>语法</strong>：</p></li></ul><pre><code>// 父组件中：let num = ref(0);provide(&#39;xxx&#39;, num)// 后代组件中接收：const xxx = inject(&#39;xxx&#39;);</code></pre><ul><li><strong>注意</strong>：所有后代组件都可以使用<code>inject</code>拿到数据，但一般用在祖孙之间传递。</li></ul><hr><h2 id="12-几个用于判断响应式数据的API"><a href="#12-几个用于判断响应式数据的API" class="headerlink" title="12. 几个用于判断响应式数据的API"></a>12. 几个用于判断响应式数据的API</h2><p><strong>几个常用的用来判断的API：</strong></p><ol><li><strong>isRef</strong>：检查一个值是否是一个<code>ref</code>对象。</li><li><strong>isReactive</strong>：检查一个对象是否是由<code>reactive</code>创建的响应式代理。</li><li><strong>isReadonly</strong>：检查一个对象是否由<code>readonly</code>创建的只读代理。</li><li><strong>isProxy</strong>：检查一个对象是否由<code>reactive或者readonly</code>方法创建的代理。</li></ol><p><strong>使用场景</strong>：判断一个数据是否经过某些api的修饰。</p><p><strong>需要注意的一点</strong>：</p><ul><li>当<code>isProxy</code>判断一个由~所定义的数据时，它也会返回true。</li><li>这是因为<code>readonly</code>属性不会改变原数据的形式。依旧是proxy代理，而非转为普通object对象。</li></ul><pre><code>let obj1 = reactive(&#123;    a: 1,    b: 2&#125;)let obj2 = readonly(obj)// 打印为true：console.log(isProxy(obj2));</code></pre><hr><h2 id="13-新的组件"><a href="#13-新的组件" class="headerlink" title="13. 新的组件"></a>13. 新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1. Fragment"></a>1. Fragment</h3><blockquote><p>Fragment：碎片</p></blockquote><ul><li>在<strong>vue2</strong>中：组件必须有个根标签。</li><li><strong>vue3</strong>中：无需根标签，内部已经将多个标签包在一个Fragment虚拟元素中。</li><li><strong>优势</strong>：减少标签层级嵌套，减小内存占用。</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2. Teleport"></a>2. Teleport</h3><blockquote><p>teleport：瞬间移动；传送；</p></blockquote><ul><li><strong>作用</strong>：将一段HTML结构移动到指定位置。</li><li>to属性用来指定位置。</li></ul><pre><code>&lt;teleport to=&quot;body/或任意其他位置&quot;&gt;    &lt;div&gt;&lt;/div&gt;&lt;teleport&gt;</code></pre><h3 id="3-Suspense-（试验阶段）"><a href="#3-Suspense-（试验阶段）" class="headerlink" title="3. Suspense （试验阶段）"></a>3. Suspense （试验阶段）</h3><blockquote><p>Suspense:悬念</p></blockquote><ul><li><p><strong>作用</strong>：异步引入组件。</p></li><li><p><span style="color: #FFB700;"><strong>静态</strong></span> <strong>&amp;</strong> <span style="color: #FFB700;"><strong>动态</strong></span><span style="color: #FFB700;">(异步)</span><strong>引入组件的对比</strong>：</p><ul><li><p>写法：</p><pre><code>// 静态引入：import child from &#39;./文件路径&#39;;</code></pre><pre><code>import &#123; defineAsnycComponent &#125; from &#39;vue&#39;;// 动态(异步)引入组件：// import在以前用作一个关键词，在这里用作一个函数。const child = defineAsnycComponent(()=&gt; import(&#39;./文件路径&#39;)))</code></pre></li><li><p><strong>静态引入</strong>：当网速慢的时候，造成几个组件都不显示都在等着。</p></li><li><p><strong>动态引入</strong>：</p></li></ul></li><li><p><strong>Suspense使用</strong>：Suspense组件标签中内置了两个插槽：</p><ul><li>1.要放入展示的组件；</li><li>2.组件未加载时loading状态的内容。</li><li><strong>注意</strong>：<span style="color: #FFB700;">插槽的名字不能换</span>。</li></ul></li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;  &lt;h3&gt;我是App组件&lt;/h3&gt;  &lt;Suspense&gt;    &lt;template v-slot:default&gt;      &lt;Child/&gt;    &lt;/template&gt;        &lt;template v-slot:fallback&gt;      &lt;h3&gt;加载中.....&lt;/h3&gt;    &lt;/template&gt;  &lt;/Suspense&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>PS</strong>：当组件用了异步引入时，setup可以是async函数。</p>   <img src="https://s2.loli.net/2022/08/18/gi8sOUXRAJlphVy.png" alt="image.png" style="zoom:67%;" /><hr><h2 id="14-vue3的其它调整"><a href="#14-vue3的其它调整" class="headerlink" title="14. vue3的其它调整"></a>14. vue3的其它调整</h2><h3 id="1-全局API的转移："><a href="#1-全局API的转移：" class="headerlink" title="1. 全局API的转移："></a>1. 全局API的转移：</h3><p><img src="https://s2.loli.net/2022/08/18/ksXfFxdm8Hr65nI.png" alt="image.png"></p><h3 id="2-其它："><a href="#2-其它：" class="headerlink" title="2. 其它："></a>2. 其它：</h3><ul><li>data始终应被声明为函数。</li><li>过渡类名的更改：</li></ul><p><img src="https://s2.loli.net/2022/08/18/arnC83f6p4hHLRN.png" alt="image.png"></p><ul><li><p>移除keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p>移除<code>v-on.native</code>修饰符</p></li><li><ul><li>父组件中绑定事件</li></ul></li></ul><pre><code> &lt;my-component   v-on:close=&quot;handleComponentEvent&quot;   v-on:click=&quot;handleNativeClickEvent&quot; /&gt;</code></pre><ul><li><ul><li>子组件中声明自定义事件</li></ul></li></ul><pre><code> &lt;script&gt;   export default &#123;     emits: [&#39;close&#39;]   &#125; &lt;/script&gt;</code></pre><ul><li>移除过滤器（filter）</li></ul><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote><ul><li><p>其余去看官方文档…</p></li><li><ul><li><a href="https://staging-cn.vuejs.org/api/application.html">https://staging-cn.vuejs.org/api/application.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS深拷贝</title>
      <link href="posts/3136a465/"/>
      <url>posts/3136a465/</url>
      
        <content type="html"><![CDATA[<p>拷贝的对象可能是多层级的，要确保深层嵌套也一样，可以使用递归，所以：</p><ul><li>如果是原始类型 =》 直接返回，无需继续拷贝。</li><li>如果是引用类型 =》 创建新对象，遍历要克隆的对象&amp;将对象属性深拷贝后依次放入新对象中。</li></ul><h5 id="完善过程：（最终版拉到最后）"><a href="#完善过程：（最终版拉到最后）" class="headerlink" title="完善过程：（最终版拉到最后）"></a>完善过程：（<span style="color: #3850b8">最终版拉到最后</span>）</h5><ol><li><strong>未考虑数组的情况下</strong>：</li></ol><pre><code>export function basicClone(target) &#123;  // 先判断是否为对象类型：  if (typeof target === &#39;object&#39;) &#123;    let cloneTarget = &#123;&#125;;    for (const key in target) &#123;      // 将原对象中每一项放入新对象：      cloneTarget[key] = basicClone(target[key]);    &#125;    // 返回新对象：    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><ol start="2"><li><strong>根据以上改进加入数组</strong>：</li></ol><pre><code>export function Clone(target) &#123;  if (typeof target === &#39;object&#39;) &#123;    // 关键：如果target是数组则定义个新数组而非对象。其余代码与上种无差别。    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;    for (const key in target) &#123;      cloneTarget[key] = Clone(target[key]);    &#125;    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><ol start="3"><li><p><strong>考虑栈溢出的情况</strong>：(当对象中的属性引用了自身，进入死循环会导致栈溢出。)</p></li><li><ol><li><p><span style="color: #0091ff;background-color: #f2f4f5;">解决循环引用</span>：开辟新的存储空间放置当前对象和拷贝对象的对应关系。</p></li><li><ol><li>当需要拷贝当前对象时先去存储空间找。有拷贝过这个对象 =》直接返回；</li><li>没有的话 =》继续拷贝。</li></ol></li><li><p>Map数据结构：<a href="https://juejin.cn/post/7064479924757168165%E3%80%82">https://juejin.cn/post/7064479924757168165。</a></p></li></ol></li></ol><pre><code>// 测试用例：const target = &#123;  field1: 1,  field2: undefined,  field3: &#123;      child: &#39;child&#39;  &#125;,  field4: [2, 4, 8]&#125;;target.target = target;  // 这里导致栈溢出。export function deepClone(target, map = new Map) &#123;  if (typeof target === &#39;object&#39;) &#123;    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;    // 判断map中有没有已经克隆过的对象：    if (map.get(target)) &#123;      // 有 =》直接返回：      return map.get(target);    &#125;    // 没有 =》将当前对象作为key，克隆对象作为value进行存储：    map.set(target, cloneTarget);    // 继续克隆：    for (const key in target) &#123;      cloneTarget[key] = deepClone(target[key], map);    &#125;    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;</code></pre><p>待完善，</p><p>关于WeakMap及其它拓展暂未学习。</p><p>参考：<a href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ref &amp; reactive &amp; 响应式差异</title>
      <link href="posts/9badfa3f/"/>
      <url>posts/9badfa3f/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：const xxx = ref(initValue)  </p></li><li><ul><li>创建一个包含响应式数据的引用对象（reference对象）。</li><li>模板中使用引用对象不用后面加.value，而setup中使用该值时需要加.value。</li></ul></li><li><p><strong>接收的数据</strong>：</p></li><li><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong>基本类型： 响应式</strong>依旧使用是<strong>defineProperty</strong> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong>对象类型</strong>时使用<strong>proxy</strong>实现的（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要 .value 是因为Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p><strong>注意</strong>：如果要在setup中拿到DOM元素，声明的变量名必须与元素中写的ref<strong>一致</strong>。</p></li></ul><p><template>  <div id="countBox" ref="countupRef">    <span class="countSpan"></span>  </div> </template></p><ul><li><p>在<strong>onMounted</strong>中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="2-reactive："><a href="#2-reactive：" class="headerlink" title="2. reactive："></a><strong>2. reactive：</strong></h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：const 代理对象 = reactive(源对象);  接收一个对象或数组，返回一个<strong>代理对象</strong>（Proxy的实例对象，简称proxy对象）。</p></li><li><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul></li></ul><p> <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035136457-16600746990031.png" alt="image-20220810035136457"></p><ul><li>reactive定义的响应式数据是”深层次的“。</li><li>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</li></ul><h2 id="3-ref对比reactive总结"><a href="#3-ref对比reactive总结" class="headerlink" title="3. ref对比reactive总结"></a><strong>3. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p></li><li><ul><li>ref定义：基本类型数据。</li><li>reactive定义：对象/数组类型数据。</li><li>注意：ref也可以定义对象/数组类型数据，它内部会自动通过reactive转为代理对象。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p></li><li><ul><li>ref：通过Object.defineProperty()的get和set实现响应式（数据劫持）。</li><li>reactive：通过使用Proxy实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p></li><li><ul><li>ref定义的数据：操作数据需要.value，读取数据时模板会直接读取不用.value。</li><li>reactive定义的数据：操作数据与读取数据均不需要.value。</li></ul></li></ul><h2 id="4-响应式原理对比"><a href="#4-响应式原理对比" class="headerlink" title="4. 响应式原理对比"></a><strong>4. 响应式原理对比</strong></h2><h2 id="4-1-Vue2的响应式"><a href="#4-1-Vue2的响应式" class="headerlink" title="4.1 Vue2的响应式"></a><strong>4.1 Vue2的响应式</strong></h2><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><p><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</p></li><li><p><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。</p></li><li><ul><li><p>比如：调用push方法，其实调用的是vue2二次封装后的push。</p></li><li><p>这个push里做了两件事：</p></li><li><ul><li>\1. 帮助正常调用push方法。</li><li>\2. 帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p></li><li><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul></li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035246493-16600747685122.png" alt="image-20220810035246493"></p><ul><li><p><strong>Object.defineProperty</strong>:</p></li><li><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="4-2-Vue3的响应式"><a href="#4-2-Vue3的响应式" class="headerlink" title="4.2 Vue3的响应式"></a><strong>4.2 Vue3的响应式</strong></h3><h4 id="4-2-1实现原理："><a href="#4-2-1实现原理：" class="headerlink" title="4.2.1实现原理："></a><strong>4.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p></li><li><ul><li><strong>Proxy</strong>：window上内置的，接收<strong>两个参数</strong>（必填）：<strong>1</strong>.target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p></li><li><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的<strong>reflect</strong>。）</li></ul></li></ul><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035353361-16600748348953.png" alt="image-20220810035353361"></p><h4 id="4-2-2-响应式中Reflect的应用："><a href="#4-2-2-响应式中Reflect的应用：" class="headerlink" title="4.2.2. 响应式中Reflect的应用："></a>4.2.2. 响应式中Reflect的应用：</h4><ul><li><strong>ES6</strong>，<strong>Windows内置</strong>。</li><li>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</li><li>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</li></ul><p><strong>与Object.definProperty<strong><strong>对比</strong></strong>：</strong></p><ul><li><p><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></p></li><li><p> <strong>模拟Vue3中实现响应式</strong>（使用<strong>reflect</strong>改进后）：</p></li><li><ul><li><p>用到了proxy代理对象，及reflect反射对象。</p><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre></li></ul></li></ul><hr><p><strong>toRef</strong></p><ul><li>toRef可以创建一个ref，其的value值可以指向令一个对象的属性。</li></ul><p><strong>举例</strong>：</p><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre><p><strong>toRefs</strong></p><p>指向多个</p><p><strong>toRefs</strong></p><p>指向多个属性</p>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3生命周期的变更</title>
      <link href="posts/2606f5b3/"/>
      <url>posts/2606f5b3/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p>销毁的概念改为<strong>卸载</strong>（unmounted），更名：</p></li><li><ul><li>beforeDestroy改名为beforeUnmounted。</li><li>destroyed改名为unmounted。</li></ul></li><li><p>vue2中的两次判断改为一次。</p></li></ul><p>​    <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810030613459.png" alt="image-20220810030613459"></p><ul><li><p>Vue3提供的<strong>Composition API</strong>形式对比：</p></li><li><ul><li>beforeCreate     =&gt;     <strong>setup()</strong></li><li>created     =&gt;     <strong>setup()</strong></li><li>beforeMount     =&gt;     <strong>onBeforeMount</strong></li><li>mounted         =&gt;     <strong>onMounted</strong></li><li>beforeUpdate      =&gt;     <strong>onBeforeUpdate</strong></li><li>updated         =&gt;     <strong>onUpdated</strong></li><li>beforeUnmounted     =&gt;     <strong>onBeforeUnmounted</strong></li><li>unmounted     =&gt;     <strong>OnUnmounted</strong></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p></li><li><ul><li><p>下图打印结果可以看到：setup中的组合式API优先级更高。</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810034139355-16600741018631.png" alt="image-20220810034139355"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何终止多层循环</title>
      <link href="posts/2b061dbf/"/>
      <url>posts/2b061dbf/</url>
      
        <content type="html"><![CDATA[<h3 id="1-使用for的情况下"><a href="#1-使用for的情况下" class="headerlink" title="1. 使用for的情况下"></a>1. 使用for的情况下</h3><ul><li>给外层和内层循环分别使用<strong>标签语句</strong>起个名字   (红宝书P167，3.6.7章节。)</li><li>通过 <strong>break 标签语句</strong>    的形式选择中止哪一层循环。</li></ul><p>具体代码示例：</p><p><img src="https://s2.loli.net/2022/10/05/PhIgrWbDdOkAlK7.png" alt="image-png"></p><p><strong>其他方法</strong>：外层循环条件表达式里加一个布尔值与运算，内存循环跳出，外层循环不允许再进入，这种方法用的还是比较多。</p><p><strong>备用方案</strong>：定义flag=false，当内循环找到之后就改为true，当flag=true就执行外层的break。</p><h3 id="2-使用foreach的情况下"><a href="#2-使用foreach的情况下" class="headerlink" title="2. 使用foreach的情况下"></a>2. 使用foreach的情况下</h3><ul><li>语法报错。提示：foreach的循环不能跳出外层循环。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactive不能解构</title>
      <link href="posts/263d655f/"/>
      <url>posts/263d655f/</url>
      
        <content type="html"><![CDATA[<ul><li><p>当使用reactive定义一个对象，不能使用解构（<strong>数据不能修改成功</strong>）。</p><ul><li><p>举例：</p><pre><code>const obj = reactive(&#123;    a: &#39;polaris&#39;,    b: 20&#125;)obj.b = 13;console.log(obj.b); // b=20，未改成功。</code></pre></li></ul></li><li><ul><li><strong>解决</strong>： 使用toRefs。</li><li><strong>注意</strong>：使用了toRef或toRefs，取值要.value。</li></ul></li></ul><pre><code>// 修改后：const obj = reactive(&#123;    a: &#39;polaris&#39;,    b: 20&#125;)obj.b = 13;console.log(obj.b); // b=20，未改成功。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环event loop</title>
      <link href="posts/61ebbe5a/"/>
      <url>posts/61ebbe5a/</url>
      
        <content type="html"><![CDATA[<ul><li>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理：<a href="https://segmentfault.com/a/1190000012925872#articleHeader17">https://segmentfault.com/a/1190000012925872#articleHeader17</a></li><li>参考自：晓舟的系列视频 <a href="https://www.bilibili.com/video/BV1gB4y1K7bD?share_source=copy_web&vd_source=72dc2b34128eeca7f0729ade125cd412">前端面试题：JavaScript运行机制（一）单线程_哔哩哔哩_bilibili</a></li></ul><hr><h2 id="1-event-loop事件循环"><a href="#1-event-loop事件循环" class="headerlink" title="1. event loop事件循环"></a>1. event loop事件循环</h2><ul><li>JavaScript从一开始就是<span style="color: #0091ff">单线程</span>，<strong>原因</strong>：这与它的<span style="color: #0091ff">v</span>有关，JavaScript作为一个浏览器脚本语言，<span style="color: #0091ff">偏向于用户侧的交互，为了降低复杂性</span>，这决定了它只能是单线程，否则会带来很复杂的同步问题。</li><li>HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。</li></ul><h3 id="1-1-同步-amp-异步："><a href="#1-1-同步-amp-异步：" class="headerlink" title="1.1 同步 &amp; 异步："></a>1.1 同步 &amp; 异步：</h3><p><span style="color: #3850b8"><strong>场景</strong></span>：当遇到一个非常耗时的任务，而这时又需要响应用户的操作。为了避免页面出现“假死”的状态，<strong>避免主线程的阻塞</strong>，JavaScript 有了 <strong>同步</strong> 和 <strong>异步</strong> 的概念。</p><p><span style="color: #0091ff"><strong>同步任务</strong></span>：在<span style="color: #ff0001"><strong>主线程</strong></span>上的<span style="color: #ff0001">依次执行</span>任务。</p><p><span style="color: #0091ff"><strong>异步任务</strong></span>：<span style="color: #ff0001">不进入主进程</span>，<span style="color: #ff0001"><strong>在任务队列</strong></span>（task queue）的任务。只有等待主线程空闲的时候（调用栈被清空），该任务才会进入主线程执行。</p><p>举例：</p><pre><code> console.log(0) setTimeout(function() &#123;     console.log(1) &#125;, 1000); console.log(2) // 打印顺序是 0 2 1</code></pre><p>这段代码中：</p><ul><li>主线程首先打印0，看到setTimeout后处理为异步，1s过后setTimeout的回调函数会进入任务队列。</li><li>主线程继续运行，打印2。</li><li>在主线程的任务运行完成之后，会再轮询任务队列，打印出1。</li></ul><h3 id="1-2-任务队列："><a href="#1-2-任务队列：" class="headerlink" title="1.2 任务队列："></a>1.2 任务队列：</h3><ul><li>单线程就意味着所有任务需要排队。如果前一个任务耗时很长，后一个任务就等着。</li><li>很多时候CPU是闲着的，因为IO设备很慢（<strong>比如</strong>Ajax操作从网络读取数据），必须要等着结果出来，再往下执行。所以JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</li><li>（ I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中硬件部件。）</li></ul><h3 id="1-3-执行流程-amp-图解："><a href="#1-3-执行流程-amp-图解：" class="headerlink" title="1.3 执行流程 &amp; 图解："></a>1.3 执行流程 &amp; 图解：</h3><ol><li>所有同步任务都在<span style="color: #3850b8">主线程</span>上执行，形成一个<span style="color: #3850b8"><strong>执行栈</strong></span>（execution context stack）。</li><li><span style="color: #3850b8">主线程</span>之外，还存在一个“<span style="color: #3850b8"><strong>任务队列</strong></span>”（task queue）。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li><li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><ul><li>主线程从任务队列中读取事件,这个过程是<strong>不断循环</strong>的,所以整个的运行机制称为<span style="color: #0091ff"><strong>event loop</strong></span>。</li><li>Node.js的Event Loop：略。</li></ul><p><strong>参照下图</strong>：</p><img src="https://s2.loli.net/2022/10/05/ETdfwMcaNrmpxCH.png" alt="image-20221005152751007" style="zoom: 50%;" /><h3 id="1-4-事件循环的三种类型："><a href="#1-4-事件循环的三种类型：" class="headerlink" title="1.4 事件循环的三种类型："></a>1.4 事件循环的三种类型：</h3><ol><li><p><span style="color: #3850b8">Window 事件循环</span></p></li><li><p><span style="color: #3850b8">Worker 事件循环</span></p></li><li><p><span style="color: #3850b8">Worklet 事件循环</span></p></li></ol><blockquote><p>多个同源窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。</p><p><strong>PS</strong>：</p><p>此处同源指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思。</p><p>“window” 指用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，<strong>同源窗口之间共享事件循环</strong>，例如：</p><ul><li>如果窗口是包含在iframe标签中，则它可能会和包含它的窗口共享一个事件循环。</li><li>在多进程浏览器中多个窗口碰巧共享了同一个进程。</li><li>具体细节可能因浏览器而异，取决于它们的实现方式。</li></ul></blockquote><h2 id="2-宏任务-amp-微任务："><a href="#2-宏任务-amp-微任务：" class="headerlink" title="2. 宏任务 &amp; 微任务："></a><strong>2. 宏任务 &amp;</strong> 微任务：</h2><ul><li><span style="color: #3850b8"><strong>异步任务队列</strong></span>：<span style="color: #0091ff"><strong>宏任务</strong></span>(macro-task)和<span style="color: #0091ff"><strong>微任务</strong></span>(micro-task)。</li><li><strong>执行顺序</strong>：执行栈在<span style="color: #3850b8;background-color: #f2f4f5;">执行完同步任务后，查看执行栈是否为空，如果执行栈为空</span> =》执行宏任务。<span style="color: #3850b8">每次</span>宏任务执行完毕后，检查微任务队列是否为空，如果不为空 =》按照<span style="color: #3850b8">先入先出</span>的规则全部执行完微任务 =》设置微任务队列为null =》再执行宏任务，如此循环。</li></ul><blockquote><p><span style="color: #CC0000"><strong>宏任务队列可以有多个，微任务队列只有一个。</strong></span></p></blockquote><p><strong>注意</strong>：<span style="color: #3850b8;background-color: #f2f4f5;">当<strong>宏任务</strong>出队时，任务是一个个执行</span>；而<span style="color: #3850b8;background-color: #f2f4f5;"><strong>微任务</strong>出队时，任务是一队一队执行</span>。因此处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p><p><strong>宏任务主要包含</strong>：<span style="color: #0091ff">script( 整体代码)、setTimeout、setInterval、 I/O、UI 交互事件</span>……</p><p><strong>微任务主要包含</strong>：<span style="color: #0091ff">Promise、process.nextTick</span>(Node.js 环境)……</p><p>如图：</p><img src="https://s2.loli.net/2022/10/05/pjJeRPY6vWdtKh2.png" alt="image.png" style="zoom:50%;" /><p><strong>例题</strong>：</p><pre><code> setTimeout(function() &#123;     console.log(&#39;1&#39;); &#125;) new Promise(function(resolve) &#123;     console.log(&#39;2&#39;); &#125;).then(function() &#123;     console.log(&#39;3&#39;); &#125;)  console.log(&#39;4&#39;);</code></pre><ul><li><p><strong>打印顺序</strong>：2 4 3 1</p></li><li><p><strong>原因</strong>：</p></li><li><ul><li>1.</li><li>2.</li></ul></li></ul><h2 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h2><p>这部分内容主要在：<a href="note://E95A3D8DBC074A43AC8F6F9C15FFE2D5">Promise</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise总结</title>
      <link href="posts/5b39b356/"/>
      <url>posts/5b39b356/</url>
      
        <content type="html"><![CDATA[<p><strong>关联笔记</strong>：<a href="note://WEBcaea4312c824c3e5ed720687a4dde45f">Promise补充</a>    <a href="note://WEBb2bc4bcd1fe230dba73429e31b71de72">事件循环event loop</a></p><hr><h2 id="1-一些需要知道的前置内容"><a href="#1-一些需要知道的前置内容" class="headerlink" title="1. 一些需要知道的前置内容"></a>1. 一些需要知道的前置内容</h2><h3 id="1-1-实例对象与函数对象"><a href="#1-1-实例对象与函数对象" class="headerlink" title="1.1 实例对象与函数对象"></a>1.1 实例对象与函数对象</h3><ul><li><span style="color: #ff0001">实例对象</span>：new函数产生的对象，称为实例对象，简称对象。</li><li><span style="color: #ff0001">函数对象</span>：将函数作为对象使用时，简称函数对象。</li></ul><p>看以下对比：</p><pre><code> function Fn() &#123;&#125;            // Fn是函数             </code></pre><pre><code> const Fn = new Fn();        // Fn是构造函数；fn是实例对象。</code></pre><pre><code>console.log(Fn.prototype);  // Fn函数对象                 </code></pre><pre><code>Fn.call(&#123;&#125;)                 // Fn函数对象  </code></pre><pre><code>$(&#39;#test&#39;)                  // Jquery函数            </code></pre><pre><code>$.get(&#39;/test&#39;)              // Jquery函数对象</code></pre><p>​              </p><p>异步加载图片为例：</p><pre><code>// 声明一个函数&amp;传3个参数：function loadImg(src, res, reject) &#123;    // new一个对象    let img = new Image();    // 增加3个对象属性&amp;赋值：    img.src = src;    img.onload = res;    img.onerr = reject;&#125;// 调用loadImgloadImg(&#123;&#125;)</code></pre><p>​       通过回调，</p><h3 id="1-2-两种回调函数（同步-amp-异步）"><a href="#1-2-两种回调函数（同步-amp-异步）" class="headerlink" title="1.2 两种回调函数（同步&amp;异步）"></a>1.2 两种回调函数（同步&amp;异步）</h3><h4 id="1-2-1-同步回调函数："><a href="#1-2-1-同步回调函数：" class="headerlink" title="1.2.1 同步回调函数："></a>1.2.1 同步回调函数：</h4><ul><li><ol><li><strong>理解</strong>：<span style="color: #ff0001">立即执行，每一步完全执行完才结束</span>，不会放进回调队列中。</li></ol></li><li><ol start="2"><li><strong>例子</strong>：看下打印出来的顺序</li></ol></li></ul><pre><code>const arr =  [1, 2, 3];arr.forEach(item =&gt; &#123;       // 遍历回调；同步回调函数。不会放入队列，一上来就执行。    console.log(item);&#125;)console.log(&#39;forEach()后的打印&#39;);</code></pre><p>​            </p><ul><li>打印<strong>结果</strong>：arr中的每个item被打印，然后是第5行。</li><li><strong>说明</strong>：这段代码同步的。函数内每一步都执行完了才会进行下面的代码。</li></ul><h4 id="1-2-2-异步回调函数："><a href="#1-2-2-异步回调函数：" class="headerlink" title="1.2.2 异步回调函数："></a>1.2.2 异步回调函数：</h4><ul><li><ol><li><strong>理解</strong>：不会立即执行，而是<span style="color: #ff0001">放入回调队列等待执行</span>。</li></ol></li><li><ol start="2"><li><strong>例子</strong>：（比如：定时器回调、ajax回调、Promise的成功or失败回调。）</li></ol></li></ul><pre><code>// 异步回调函数，会放入队列在将来执行。setTimeout(() =&gt; &#123;    console.log(&#39;我是setTimeout中的回调~&#39;);&#125;, 0)console.log(&#39;我是setTimeout后的打印&#39;);       // 先打印</code></pre><p>​        </p><ul><li><p>打印<strong>结果&amp;说明</strong>：这段代码会先打印第4行，尽管定时器时间为0。因为是异步的，定时器里的需要等待后执行里面的打印；所以第4行直接先被打印。</p></li><li><ol><li>如果要判断一个函数是否是异步的，可以打印输出看顺序<strong>看是否需要等待</strong>输出来判断。</li></ol></li><li><ol start="2"><li>并不是所有回调都是异步。</li></ol></li></ul><h3 id="1-3-常见的内置错误"><a href="#1-3-常见的内置错误" class="headerlink" title="1.3 常见的内置错误"></a>1.3 常见的内置错误</h3><h4 id="1-3-1-错误的类型："><a href="#1-3-1-错误的类型：" class="headerlink" title="1.3.1 错误的类型："></a>1.3.1 错误的类型：</h4><ul><li><strong>Error:</strong> 是以下所有错误的<span style="background-color: #f2f4f5;">父类型</span>。<ul><li><strong>1.</strong> <span style="color: #CC0000"><strong>ReferenceError</strong></span>：<u>引用的变量不存在</u>；</li></ul></li></ul><pre><code>// 例：console.log(a);    // ReferenceError: a is not definedconsole.log(&#39;====&#39;);    // 未捕获错误，本行代码也不会执行。</code></pre><ul><li><ul><li><strong>2.</strong> <span style="color: #CC0000"><strong>TypeError</strong></span>： <u>数据类型不正确</u>；</li></ul></li></ul><pre><code>// 例：let b = undefined;b.xxx();             // Uncaught TypeError: b.xxx is not a function// 或：console.log(b.xxx);  // Uncaught TypeError: cannot read property &#39;xxx&#39; of undefined</code></pre><ul><li><ul><li><p><strong>3.</strong> <span style="color: #CC0000"><strong>RangeError</strong></span>： <u>数据值不在其所允许的范围内</u>；</p><pre><code>// 例：function fn () &#123;    // 在函数内部调用自己:（叫递归调用）    fn();&#125;// 加上这行就会报错：（最大调用栈溢出，也就是数据值不在其所允许的范围内）fn();              // RangeError: Maximum call stack size exceeded</code></pre><p>​    <strong>PS</strong>：<strong>这种形式不叫函数自调用，要区分开</strong>。函数自调用是：一次性函数。  <a href="https://www.cnblogs.com/liushisaonian/p/9425427.html">https://www.cnblogs.com/liushisaonian/p/9425427.html</a></p></li><li><p><strong>4.</strong>  <span style="color: #CC0000"><strong>SyntaxError</strong></span>： <u>语法错误</u>。</p><pre><code>// 例：// 本意：字符串里放入一个空字符串const c = &quot;&quot;&quot;&quot;;       // SyntaxError: Unexpected string     </code></pre></li></ul></li></ul><h4 id="1-3-2-错误处理："><a href="#1-3-2-错误处理：" class="headerlink" title="1.3.2 错误处理："></a>1.3.2 错误处理：</h4><p>不处理程序没法向下执行，有时需要在出现错误时加一些提示，所以会处理。</p><ul><li><strong>1.</strong> <span style="color: #CC0000"><strong>捕获处理</strong></span>：<strong>try  …  catch</strong><ul><li><strong>error里面默认有两个属性：<span style="color: #0091ff">1.</span> message 信息 ；<span style="color: #0091ff">2.</span> stack 调用栈</strong>    </li></ul></li></ul><pre><code>//try &#123;    let d;    console.log(d.xxx);&#125; catch (error) &#123;    console.log(error.message);   // 提示文本    console.log(error.stack);     // 相关信息文本&#125;// 只有上面处理了错误后，下面这行才可以正常执行：console.log(&#39;上面出错了&#39;);</code></pre><p>​             </p><ul><li><strong>2.</strong> <span style="color: #CC0000"><strong>抛出错误</strong></span>：<strong>throw error</strong>    <ul><li>当想让调用者自己处理，就可以使用抛出异常。若没有相关处理的需求也就没必要抛出异常了。</li><li>当自己抛异常时通常抛的是<strong>Error</strong>类型，而不是其下的别的类型错误。</li></ul></li></ul><pre><code>// 抛出错误： throwfunction fn() &#123;    // 判断当前时间是否为奇数:    if(Date.now()%2 === 1) &#123;        console.log(&#39;是奇数，可以执行任务&#39;);    &#125; else &#123;        // 抛出异常，由调用者来处理：        // new出来一个Error，它是对象类型。里面参数是错误信息        thorw new Error(&#39;当前为偶数，无法执行&#39;);    &#125;&#125;// 当调用时，要先捕获(否则不执行):try &#123;    fn();&#125; catch (err) &#123;    alert(err.message);   // 给个错误提示的效果&#125;</code></pre><p>​              </p><hr><h2 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h2><h3 id="2-1-Promise的理解"><a href="#2-1-Promise的理解" class="headerlink" title="2.1 Promise的理解"></a>2.1 Promise的理解</h3><ul><li>Promise是JS中进行异步编程的新的解决方案（旧方法：纯回调）。</li><li>具体来讲：<ul><li><strong>语法上</strong>：Promise是一个构造函数。</li><li><strong>功能上</strong>：Promise对象用来封装一个异步操作并可以获取其结果。</li></ul></li></ul><h3 id="2-2-promise的状态改变"><a href="#2-2-promise的状态改变" class="headerlink" title="2.2 promise的状态改变"></a>2.2 promise的状态改变</h3><ul><li>pending变为resolved；</li><li>pending变为rejected。</li></ul><p>PS：</p><ul><li><strong>只有这2种</strong>。且一个promise对象只能改变一次。</li><li>成功&amp;失败都会有一个结果数据。</li><li>成功的结果数据称为value，失败的结果数据称为reason。</li></ul><hr><p>未完待续…….</p><h3 id="2-3-promise的基本流"><a href="#2-3-promise的基本流" class="headerlink" title="2.3 promise的基本流"></a>2.3 promise的基本流</h3><h3 id="2-4-promise的基本使用"><a href="#2-4-promise的基本使用" class="headerlink" title="2.4 promise的基本使用"></a>2.4 promise的基本使用</h3><h3 id="2-5-为什么使用promise"><a href="#2-5-为什么使用promise" class="headerlink" title="2.5 为什么使用promise"></a>2.5 为什么使用promise</h3><h3 id="2-6-如何使用promise"><a href="#2-6-如何使用promise" class="headerlink" title="2.6 如何使用promise"></a>2.6 如何使用promise</h3><hr><h2 id="3-手写promise"><a href="#3-手写promise" class="headerlink" title="3. 手写promise"></a>3. 手写promise</h2><hr><h2 id="4-async-amp-await"><a href="#4-async-amp-await" class="headerlink" title="4. async &amp; await"></a>4. async &amp; await</h2><p>补充：<a href="https://zhuanlan.zhihu.com/p/26260061">https://zhuanlan.zhihu.com/p/26260061</a></p><hr><h2 id="5-JS异步——宏队列和微队列"><a href="#5-JS异步——宏队列和微队列" class="headerlink" title="5. JS异步——宏队列和微队列"></a>5. JS异步——宏队列和微队列</h2><p>完整笔记：<a href="note://WEBb2bc4bcd1fe230dba73429e31b71de72">事件循环event loop</a></p><hr><h2 id="6-promise练习题"><a href="#6-promise练习题" class="headerlink" title="6. promise练习题"></a>6. promise练习题</h2>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios封装</title>
      <link href="posts/876a38c0/"/>
      <url>posts/876a38c0/</url>
      
        <content type="html"><![CDATA[<p>​    </p><h2 id="1-axios全局配置"><a href="#1-axios全局配置" class="headerlink" title="1. axios全局配置"></a>1. axios全局配置</h2><ul><li>有些信息是重复的，比如：baseUrl、header、超时时间。</li></ul><pre><code>axios(&#123;    baseURL: &#39;http://xxx&#39;,    timeout: 5000,    url: &#39;/home/multidata&#39;&#125;)</code></pre><ul><li>所以这些重复的可以写为全局配置：</li></ul><pre><code>axios.defaults.baseURL= &#39;http://xxx&#39;axios.defaults.timeout= 5000axios(&#123;    url: &#39;/home/multidata&#39;&#125;)</code></pre><p>​          </p><p><strong>常见配置选项：</strong></p> <img src="https://s2.loli.net/2022/10/05/l5DkjCtx6df3uhL.png" alt="image-20221005170242319" style="zoom:67%;" /><h2 id="2-axios的实例和模块封装"><a href="#2-axios的实例和模块封装" class="headerlink" title="2. axios的实例和模块封装"></a>2. axios的实例和模块封装</h2><h3 id="2-1-创建实例"><a href="#2-1-创建实例" class="headerlink" title="2.1 创建实例"></a>2.1 创建实例</h3><p>当有多个服务器地址时，配置会不一样，所以每个都创建一个实例互不干扰。</p><p>例：</p><pre><code>// 创建实例：const instance1 = axios.create(&#123;    baseURL: &#39;http://xxx&#39;,    timeout: 5000&#125;)instance1(&#123;    url: &#39;&#39;,    params: &#123;        page: 1    &#125;&#125;)</code></pre><h3 id="2-2-axios模块封装（回调函数的方式，关于promise方式这里未记录）"><a href="#2-2-axios模块封装（回调函数的方式，关于promise方式这里未记录）" class="headerlink" title="2.2 axios模块封装（回调函数的方式，关于promise方式这里未记录）"></a>2.2 axios模块封装（回调函数的方式，关于promise方式这里未记录）</h3><p><strong>Step1</strong>. 创建network文件夹，新建request.js文件：</p><pre><code>// 引入axios:import axios from &#39;axios&#39;;// 多传递两个参数: success成功和failure失败，而它们刚好是函数：export function request(config, success, failure) &#123;    // 创建axios实例：    const instance = axios.create(&#123;        baseURL: &#39;&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    instance(config).then(res =&gt; &#123;        // 成功就调用success函数并传值：        success(res);    &#125;).catch(err =&gt; &#123;        failure(err);    &#125;)&#125;</code></pre><p><strong>Step2</strong>. 使用：（我先放在了main.js中）</p><pre><code>// 先引入方法：import &#123; request &#125;from &#39;@network/request&#39;;request(&#123;    // config配置：    url: &#39;/home/multidata&#39;     // 成功回调：&#125;, res =&gt; &#123;    // 这里拿到成功结果：    console.log(res);&#125;, err =&gt; &#123;    console.log(err);&#125;)</code></pre><h3 id="2-3-上段封装的代码简写"><a href="#2-3-上段封装的代码简写" class="headerlink" title="2.3 上段封装的代码简写"></a><strong>2.3 上段封装的代码简写</strong></h3><ul><li>相当于只有一个参数，之前的三个参数以对象属性的方式放进了这一个大的对象里。   </li></ul><pre><code>export function request(config) &#123;    // 1. 创建axios实例:    const instance = axios.create(&#123;        baseURL: &#39;http://123/207.32.32:8000&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    return instance(config);&#125;</code></pre><p>别的js文件引用后：</p><pre><code>request(&#123;    url: &#39;./home/multidata&#39;&#125;).then(res =&gt; &#123;    console.log(res);&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)</code></pre><p>下面这种暂时别看：</p><pre><code>export function request(config) &#123;    // 1. 创建axios实例:    const instance = axios.create(&#123;        baseURL: &#39;http://123/207.32.32:8000&#39;,        timout: 5000    &#125;)        // 发送真正的网络请求：    instance(config.baseConfig).then(res =&gt; &#123;        config.success(res);    &#125;).catch(err =&gt; &#123;        config.failure(err);    &#125;);&#125;</code></pre><p>​           </p><pre><code>// 别的js文件调用：request(&#123;    baseConfig: &#123;            &#125;,    success: function(res) &#123;            &#125;,    failure: function(err) &#123;            &#125;&#125;)</code></pre><h3 id="2-4-关于封装的补充说明"><a href="#2-4-关于封装的补充说明" class="headerlink" title="2.4 关于封装的补充说明"></a>2.4 关于封装的补充说明</h3><ul><li>关于本篇笔记<strong>2.2小节</strong>两个步骤的代码块中回调的理解。</li></ul><p><strong>举个例子</strong>：</p><pre><code>// 这样写函数直接就执行完了，没有回调：function test() &#123;&#125;test();</code></pre><p>​           </p><ul><li>所以改成test函数的参数是函数的形式：</li></ul><pre><code>// 现在要拿到成功和失败的回调，所以需要函数在适当的时候被调用来触发操作（想象vue父子组件传值中的通过函数传递的方法，就是通过其参数也是函数的形式。）function test(aaa, bbb) &#123;    // 调用函数aaa，触发执行调用aaa函数体：        aaa();&#125;// 调用test函数test(function() &#123;     // 这里面就相当于aaa函数：&#125;, function() &#123;    // 这里面就相当于bbb函数：&#125;)</code></pre><p>​            </p><ul><li>加上打印后看下顺序：（33， 11， 44， 22）</li></ul><pre><code>    // 声明test，此时函数体里未执行：    function test(aaa, bbb) &#123;      // 第2个打印：      console.log(11);      aaa();      // 最后一个打印，因为被aaa的调用插了队。      console.log(22);    &#125;        // 第一个打印    console.log(33);                 // 看到有调用，就立马去执行test函数体里的代码。然后看到了调用aaa，同理立马去找aaa。    test(function () &#123;      // 这里是aaa函数，所以被上面test里调用后立马找到这里执行。第3个打印：      console.log(44);    &#125;, function () &#123;      // 55没被打印是因为没调用bbb:      console.log(55);    &#125;)</code></pre><ul><li>在上面的基础上，<strong>回归正题</strong>：</li></ul><pre><code>function test(aaa, bbb) &#123;    // 在这里回调的时候就把值传过去了：    aaa(&#39;我是res的实参&#39;);    bbb(&#39;我是err的实参&#39;)&#125;test(function(res) &#123;    // 这时就可以拿到aaa被调用时传过来的值：    console.log(res);           //  结果为： 我是res的实参&#125;, function(err) &#123;    console.log(err);&#125;)</code></pre><ul><li>所以基于以上，<strong>2.2小节</strong>中<strong>封装axios是一样的思想</strong>，<strong>只不过分开放在了两个js文件中&amp;增加了导入导出。</strong></li></ul><p>（视频讲解：<a href="https://www.bilibili.com/video/BV15741177Eh?p=147&amp;t=234.1%EF%BC%89">https://www.bilibili.com/video/BV15741177Eh?p=147&amp;t=234.1）</a></p><p>另外关于<strong>结合函数柯里化</strong>的封装方式：<a href="note://BF135A654F4D410C8D4522384737DFC2">JS函数柯里化</a></p><hr><p>整理后的版本：</p><ul><li>参考自：<a href="https://www.bilibili.com/video/BV1QA411b7TR?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f">https://www.bilibili.com/video/BV1QA411b7TR?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f</a></li></ul><p>​                              </p><p>1.</p><img src="https://s2.loli.net/2022/10/05/rl4mQRtgE2HyzFv.png" alt="image-20221005170856416" style="zoom: 80%;" /><p>2.</p>   <img src="https://s2.loli.net/2022/10/05/mOgRowl9udF1x7B.png" alt="image-20221005170948944" style="zoom:80%;" /><p>通过config，统一res，err。</p><p>3.通过promise</p><img src="https://s2.loli.net/2022/10/05/htNxGyLMcnoCzde.png" alt="image-png" style="zoom: 80%;" /><p>4.axios本事返回就是promise，所以直接把第三种简写为</p><img src="https://s2.loli.net/2022/10/05/D8JOdSoVflLmP6E.png" alt="image-png" style="zoom: 80%;" />]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axios </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue条件渲染&amp;列表渲染&amp;列表过滤排序&amp;监测原理</title>
      <link href="posts/9a3c70e/"/>
      <url>posts/9a3c70e/</url>
      
        <content type="html"><![CDATA[<h2 id="1-条件渲染v-if、v-show"><a href="#1-条件渲染v-if、v-show" class="headerlink" title="1. 条件渲染v-if、v-show"></a>1. 条件渲染v-if、v-show</h2><ul><li>v-show控制display显示隐藏，v-if控制节点是否存在。</li><li>当变化很频繁建议使用v-show，防止v-if反复删除添加节点。</li><li>当使用v-if和v-else-if或v-else时，所在的模板代码精致被打断，必须这几行写一起。</li><li>template不会破坏结构，但是只能和v-if配合使用，v-show不行。</li></ul><h2 id="2-列表渲染v-for"><a href="#2-列表渲染v-for" class="headerlink" title="2. 列表渲染v-for"></a>2. 列表渲染v-for</h2><ul><li>使用v-for一定要搭配 :key，它相当于遍历每一项当中的唯一标识。</li><li>除了可以遍历数组类型，还可以遍历对象、遍历字符串（很少）、遍历指定次数（更少）。</li></ul><h2 id="3-key的作用与原理"><a href="#3-key的作用与原理" class="headerlink" title="3. key的作用与原理"></a>3. key的作用与原理</h2><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=30&amp;t=620.3">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=30&amp;t=620.3</a></p><p>当遍历中的index作为key，流程图解：</p><p>  <img src="https://s2.loli.net/2022/10/05/QFhjls4NwgUJpES.png" alt="image-index作为key"></p><p><strong>两者流程对比对比：</strong></p><p>当节点自己的id作为key，流程图解：</p><p><img src="https://s2.loli.net/2022/10/05/TCNvDWuXU63A8Kp.png" alt="image-对比id作为key"></p><p>注：绿色框里的是复用过来的，红色框是diff算法对比后发现没有新生成的。</p><p><strong>１、虚拟DOM中key的作用：</strong></p><p>key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据<strong>新数据生成新的虚拟DOM</strong>，随后Vue进行<strong>新虚拟DOM与旧虚拟DOM的差异比较</strong>，比较规则如下：</p><p><strong>2. 对比规则：</strong></p><ul><li>旧虚拟DOM中找到了与旧虚拟DOM相同的key:<ul><li>若虚拟DOM中内容没变，直接复用之前的真实DOM；</li><li>若虚拟DOM中内容变了，则生成心的真实DOM，然后替换页面中之前的真实DOM。</li></ul></li><li>旧虚拟DOM中未找到与新虚拟DOM相同的key：<ul><li>创建新的真是DOM，然后渲染到页面。</li></ul></li></ul><p><strong>3. 用index作为key可能会引发的问题：</strong></p><ol><li>若对数据进行：逆序添加、逆序删除等破坏了顺序的操作：<ol><li>会产生没必要的真实DOM更新 =》界面效果没问题，但效率低。</li></ol></li><li>若结构中还包含输入类的DOM（input框）：<ol><li>会产生错误的DOM更新 =》界面有问题。</li></ol></li></ol><p><strong>4. 开发中怎么选择key：</strong></p><ol><li>最好使用每条数据的唯一表示作为key，比如id、手机号、身份证号、学号等唯一值。</li><li>若不存在对数据的逆序添加/删除等破坏顺序的操作，仅用于渲染列表，使用index作为key没有问题。</li></ol><h2 id="4-列表过滤"><a href="#4-列表过滤" class="headerlink" title="4. 列表过滤"></a>4. 列表过滤</h2><h3 id="4-1-用watch实现"><a href="#4-1-用watch实现" class="headerlink" title="4.1 用watch实现"></a>4.1 用watch实现</h3><p>分析：</p><ul><li>step1.获取用户输入；step2. 给列表过滤。</li><li>可以用v-model。</li><li>当数据发生改变时就再次过滤，怎么知道数据改变？用watch。</li></ul><p>模板代码：</p><pre><code>    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;    &lt;ul&gt;      &lt;!-- 这里相应的也要改成filPersonList： --&gt;      &lt;li v-for=&quot;(p, index) in filPersonList&quot; :key=&quot;index&quot;&gt;        &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; - &#123;&#123;p.sex&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;</code></pre><p>​            </p><p>script：</p><pre><code>      data: &#123;        keyWord: &#39;&#39;,        personList: [          &#123; id: &#39;001&#39;, name: &#39;沈眉庄&#39;, age: 19, sex: &#39;女&#39; &#125;,          &#123; id: &#39;001&#39;, name: &#39;安小鸟&#39;, age: 18, sex: &#39;女&#39; &#125;,          &#123; id: &#39;001&#39;, name: &#39;温子仁&#39;, age: 25, sex: &#39;男&#39; &#125;,          &#123; id: &#39;001&#39;, name: &#39;果郡王&#39;, age: 22, sex: &#39;男&#39; &#125;,        ],        // 过滤出来的东西放在这里 以防数据被过滤丢失：        filPersonList: []      &#125;,            watch: &#123;        // 传过来的newValue和oldVlue,这里只需要newValue。        keyWord: &#123;          immediate: true,          handler(val) &#123;            // filter不会改变原数组，会返回一个新的数组。所以这个新的数组应该被用上。            // 而且这时会出现个问题：过滤之后旧的数据被丢了，越搜索越少。            this.filPersonList = this.personList.filter((p) =&gt; &#123;              // 判断一个字符串里是否包含指定的字符：若包含：返回-1；不包含返回它在第几位。              return p.name.indexOf(val) !== -1;            &#125;)          &#125;        &#125;      &#125;</code></pre><p>​           </p><p><strong>一个关键点：</strong></p><ul><li>用indexOf判断一个字符串里是否包含一个空字符串，它会返回0，0代表它在字符串中第一位。</li><li>所以一开始为空输入然后删掉后会出现每一项，因为删掉后输入框还存在个空串，一旦空串被过滤，列表里每一项都被展示出来。</li><li>所以handler前加个immediate为true，这样一开始没等输入就执行匹配的是空串，每一项会在一开始被展示出来！</li><li>（一个矛盾点：若一开始为空会有空串那为啥输入再删掉和不输入有区别？？ </li><li>懂了：一开始未输入就没有空串。一开始未输入就什么都没匹配，自然什么都不展示。而删掉后输入框就有了变动且有了空串导致每一项被展示。）</li></ul><h3 id="4-2-用computed实现"><a href="#4-2-用computed实现" class="headerlink" title="4.2 用computed实现"></a>4.2 用computed实现</h3><pre><code>computed: &#123;  filPersonList() &#123;      // 这里return是计算属性规定的：      return this.personList.filter((p) =&gt; &#123;      // 里面的逻辑和watch中的一样，但这里不能用watch返回的新旧value了，所以改为keyWord。      // 这里return是filter规定的，要给它返回去。      return p.name.indexOf(this.keyWord) !== -1;     &#125;)  &#125;&#125;</code></pre><p>​           </p><p><strong>对比：</strong></p><ul><li>computed是通过keyWord变化后重新计算一遍，watch是监听有没有变化。在这里用computed写代码更精简些。</li></ul><h2 id="5-列表排序"><a href="#5-列表排序" class="headerlink" title="5. 列表排序"></a>5. 列表排序</h2><p><strong>需求</strong>：给三个按钮按钮，分别实现列表的：升序、降序、原顺序。</p><p><strong>分析</strong>：</p><ol><li>排序是在过滤后的基础上排。</li><li>要区分开用户点的是哪种排序：新增一个属性来存储。</li><li>展示出来的列表依赖于filPersonList，所以只要维护好filPersonList就可以过滤好，想要排序就维护好filPersonList过滤好的。</li><li>所以过滤好的先别让它返回。给个数组来接收到过滤好的列表，然后判断一下是否需要排序，进行排序相关操作后返回。</li></ol><pre><code>&lt;button @click=&quot;sortType === 2&quot;&gt;年龄升序&lt;/button&gt;&lt;button @click=&quot;sortType === 1&quot;&gt;年龄降序&lt;/button&gt;&lt;button @click=&quot;sortType === 0&quot;&gt;原顺序&lt;/button&gt;</code></pre><p>​    </p><pre><code>// 新增字段来存储，默认为原顺序：sortType: 0,   // 0原顺序；1降序；2升序。</code></pre><p>​           </p><p>放在<strong>computed</strong>里：</p><pre><code>computed: &#123;  filPersonList() &#123;    // 这里return是给计算属性的：    const arr = this.personList.filter((p) =&gt; &#123;      // 里面的逻辑和watch中的一样：      // 但这里不能用watch返回的新旧value了，所以改为keyWord。      return p.name.indexOf(this.keyWord) !== -1; // 这里return是给filter规的，要给它返回去。    &#125;)    // 判断一下是否需要排序: 读sortType就可以了。    // 并且不用先判断sortType的值，直接让它为真的时候（值不是0时）才进入判断：    if(this.sortType) &#123;      // 拿到过滤好的数据再来用数组api排序：      // sort方法会给两个参数（前一项&amp;后一项）：      arr.sort((p1, p2) =&gt; &#123;        // 三元表达式判断需要哪种排序，然后使用不同的数组排序方式：        // 若降序则p2-p1使其降序，否则p1-p2使其升序：        // （注意：这里的p1、p2是一个对象，所以.age：）        return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age;      &#125;)    &#125;    // 最后一定要将返回给arr数组的返回值在返回给函数filPersonList，否则filPersonList还是拿不到结果：    return arr;  &#125;&#125;</code></pre><p>​            </p><p>PS：复习一下数组的<strong>sort</strong>方法：（<strong>两个参数</strong>：前一项、后一项。）</p><p><img src="https://s2.loli.net/2022/10/05/1ki4ae8CMbwyR7D.png" alt="image-数组的sort方法"></p><pre><code>    // sort是改变原数组的。    let arr = [1,3,5,6,2,7,8];    // 当想让数组升序：前-后；反之降序：后-前。    arr.sort((a, b) =&gt; &#123;      return a-b;    &#125;);    console.log(arr);</code></pre><h2 id="6-Vue监测数据改变的原理"><a href="#6-Vue监测数据改变的原理" class="headerlink" title="6. Vue监测数据改变的原理"></a>6. Vue监测数据改变的原理</h2><p><strong>总结：</strong></p><ol><li><p>Vue会监视data中所有层次的数据。</p></li><li><p>如何监测<strong>对象</strong>中的数据：</p><p>通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><ul><li><ol><li>对象中后追加的属性，Vue默认不做响应式处理。</li><li>如需给后添加属性做响应式，使用以下API：<ol><li>Vue.set(target, propertyName/index, value)，或</li><li>vm.$set(target, propertyName/index, value)</li></ol></li></ol></li></ul></li><li><p>如何监测<strong>数组</strong>中的数据：</p></li></ol><p>​     通过包裹数组更新元素的方法实现，本质上做了两件事：</p><ul><li><ol><li>调用原生对应的方法对数组进行更新。</li><li>重新解析模板，进而更新页面。</li></ol></li></ul><p>​     在Vue修改数组中的某个元素一定要用以下方法：</p><ul><li><ol><li>使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()。</li><li>Vue.set() 或 vm.$set。</li></ol></li></ul><ol start="4"><li><strong>注意</strong>：<strong>Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象添加属性！！！</strong></li></ol><h3 id="6-1-Vue监测数据改变的原理——对象"><a href="#6-1-Vue监测数据改变的原理——对象" class="headerlink" title="6.1 Vue监测数据改变的原理——对象"></a>6.1 Vue监测数据改变的原理——对象</h3><ul><li>Vue中会有默认的监视，当data中数据发生变化，它就会去找用到的地方去更新。至于watch，是Vue提供出来被配置使用的。而两者的原理是一样的。</li></ul><p><strong>PS：</strong>列表排序是一种破坏顺序的行为，v-for遍历时绑定的key应该改为列表每一项中自己的id。</p><h4 id="1-一种情况："><a href="#1-一种情况：" class="headerlink" title="1. 一种情况："></a>1. 一种情况：</h4><p>在点击事件的函数里这样修改列表中的数据：（是无效的，Vue监测不到变化。）</p><pre><code>this.personList[0] = &#123;id:&#39;001&#39;, name:&#39;罗老师&#39;, age:&#39;40&#39;, sex:&#39;男&#39;&#125;</code></pre><p><strong>原因</strong>：直接操作了数组的索引值通过赋值的方式改，而这数组中的某一项是个对象，没有给它的                 getter、setter。</p><p><strong>正确方式：</strong></p><pre><code>this.persons.splice(0, 1, &#39;&#123;id:&#39;001&#39;, name:&#39;罗老师&#39;, age:&#39;40&#39;, sex:&#39;男&#39;&#125;&#39;);</code></pre><p>​      </p><ul><li>红色框里的被Vue管理了，所以就不再是正常原型对象上的push了。Vue里的push做了两件事：1. 调了正常数组上的方法；2. 重新解析模板 生成虚拟DOM等一系列操作。</li><li>也就是说<strong>Vue对数组的监测靠的是包装数组上常用的修改数组的方法实现的</strong>。</li></ul><p>​    <img src="https://s2.loli.net/2022/10/05/lXZHMDQ7ULdaNjY.png" alt="image-png"></p><h4 id="2-复习一下数据代理："><a href="#2-复习一下数据代理：" class="headerlink" title="2. 复习一下数据代理："></a>2. 复习一下数据代理：</h4><p>​    <img src="https://s2.loli.net/2022/10/05/n2SJtCkAuXZlMjz.png" alt="image-数据代理"></p><p>第一步中加工data是为了实现响应式，也就能实现对对象里的属性的监视。改了data中的就会引起setter的调用来重新解析模板。</p><h4 id="3-Vue监测原理："><a href="#3-Vue监测原理：" class="headerlink" title="3. Vue监测原理："></a>3. Vue监测原理：</h4><h5 id="3-1-先举个反例-amp-引出原理："><a href="#3-1-先举个反例-amp-引出原理：" class="headerlink" title="3.1 先举个反例&amp;引出原理："></a>3.1 先举个反例&amp;引出原理：</h5><p>​    <img src="https://s2.loli.net/2022/10/05/f8DoHKvxUjhYAEq.png" alt="image-反例"></p><p>这种代码会一直递归导致栈溢出。原因是读取数据就调getter执行红色框，接着执行到绿色框读到data.name就又跑去调getter，这样不停调不停读是个死循环。同理，setter也是。一旦data.name被修改就去调setter，执行赋值就又出发了setter。</p><h5 id="3-2-模拟一个数据监测："><a href="#3-2-模拟一个数据监测：" class="headerlink" title="3.2 模拟一个数据监测："></a>3.2 模拟一个数据监测：</h5><p><del>它里面写了个构造函数，</del></p><pre><code>    let data = &#123;      name: &#39;天天&#39;,      address: &#39;软件园二期&#39;    &#125;    // Observer是构造函数得用new去调用，然后让obs接收到Observer实例对象。    // 创建一个监视的实例对象，用于监视data中属性的变化：    const obs = new Observer(data);    // 准备一个vm实例对象：    let vm = &#123;&#125;;    // 写好的obs给data，再给_data：    vm._data = data = obs;    // Observer构造函数可以：创建一个监视的实例对象。它能收到一个对象作为参数。    function Observer(obj) &#123;      // STEP1. 拿到这个对象后：汇总对象中所有的属性形成一个数组。      const keys = Object.keys(obj) // 可以利用这个api形成数组。      console.log(keys); // 会发现name，address都在。      // 遍历：      //遍历拿到的每一个可以用k来当形参：      keys.forEach((k) =&gt; &#123;        // 这里用到的技巧，它不会直接去动data，而是加在this上，而this是Observer的实例对象并不是data。然后读取k的值。        Object.defineProperty(this,k, &#123;          get() &#123;            return obj[k];          &#125;,          // 会收到修改的值：          set(val) &#123;            // 然后写个模板字符串打印下：            console.log(`$&#123;k&#125;被改了`);            // 然后把传入的对象里的k给改了：            obj[k] = val;          &#125;        &#125;)      &#125;)    &#125;</code></pre><p>​       </p><p>这里只是个大概，Vue中写的很完善，无论嵌套了几层对象它都可以找到而且数组中的对象也可以。</p><h3 id="6-2-Vue-set的使用"><a href="#6-2-Vue-set的使用" class="headerlink" title="6.2 Vue.set的使用"></a>6.2 Vue.set的使用</h3><ul><li>Vue.set() 给传<strong>三个参数</strong>：target（往谁身上追加属性）、key（追加什么属性）、value（属性值）。</li><li>它<strong>只能给data里追加，不能再在某个嵌套里</strong>。也就是说第一个参数不允许是vm或vm里的数据对象data。</li></ul><p>官方文档中：</p><p><img src="https://s2.loli.net/2022/10/05/XBKle7aSyRZtCsT.png" alt="image-官方文档中"></p><p><strong>与$set的区别：</strong></p><ul><li>用法一模一样。</li><li>但它不在Vue身上，它在vm上。</li></ul><p>例：</p><pre><code>  methods: &#123;    addSex() &#123;      // 写法1.      Vue.set(this.student, &#39;sex&#39;, &#39;男&#39;);      // 写法2.      this.$set(this.student, &#39;sex&#39;, &#39;男&#39;);    &#125;  &#125;</code></pre><h3 id="6-3-Vue监测数据改变的原理——数组"><a href="#6-3-Vue监测数据改变的原理——数组" class="headerlink" title="6.3 Vue监测数据改变的原理——数组"></a>6.3 Vue监测数据改变的原理——数组</h3><ol><li>使用数组API；</li><li>用Vue.set() ，用的不多。</li></ol><p>可以直接去看上面的总结 &amp; 代码笔记的 7.1-7.3。（这里没记全）</p><p><strong>补充</strong>：</p><p><img src="https://s2.loli.net/2022/10/05/xqEC7orFsuULh8g.png" alt="image-官方文档中"></p><p>另外关于数据劫持：</p><p>若有人改了data中某个数值，setter就像劫持一样马上出面然后拿着这些数据去做两件事：</p><ol><li><p>拿着接收到的数据去改数据；</p></li><li><p>重新解析模板。</p></li></ol><p><strong>PS：它和数据代理都离不开Object.defineProperty。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 排版待优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web服务器</title>
      <link href="posts/80ca1d96/"/>
      <url>posts/80ca1d96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是Web服务器"><a href="#1-什么是Web服务器" class="headerlink" title="1. 什么是Web服务器"></a>1. 什么是Web服务器</h3><ul><li>服务器（也会称之为主机）是提供计算服务的设备，它也是一台计算机。在网络环境下，根据服务器提供的服务类型不同，服务器又分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</li><li>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件让全世界浏览；可以放置数据文件让全世界下载。</li></ul><p><strong>以下服务器主要指的是Web服务器。</strong></p><p>根据服务器在网络中所在位置不同，又可分为本地服务器和远程服务器。</p><h3 id="2-本地服务器"><a href="#2-本地服务器" class="headerlink" title="2. 本地服务器"></a>2. 本地服务器</h3><p>可以把自己的电脑设置为本地服务器，这样同一个局域网内的人就可以访问你的网站了。</p><p>关于如何配置，和ajax有关。</p><h3 id="3-远程服务器"><a href="#3-远程服务器" class="headerlink" title="3.远程服务器"></a>3.远程服务器</h3><p>本地服务器主要是在局域网中访问，可以把网站上传到远程服务器。</p><p>远程服务器通常是别的公司提供的主机，只要把项目上传，就可以通过域名访问网站。</p><hr><p>待更新…</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEO优化</title>
      <link href="posts/7f8d26b3/"/>
      <url>posts/7f8d26b3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SEO"><a href="#1-SEO" class="headerlink" title="1. SEO"></a>1. SEO</h2><p><strong>1. SEO：Search Engine Optimization，译为 搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。</strong></p><ul><li><p>SEO的<strong>目的</strong>是：对网站进行深度优化，从而帮助网站获取免费的流量，进而在搜索引擎上提高网站的排名。</p></li><li><p>页面必须有三个标签用来符合SEO优化。</p></li><li><ul><li><p><strong>title 网站标题</strong></p></li><li><ul><li>title具有不可代替性，是内页的第一个重要标签，是搜索引擎了解王爷的入口和对网页主题归属的最佳判断点。</li><li>建议写法：<span style="color: red">网站名（产品名）-网站的介绍</span>（尽量不要超过30个汉字）</li></ul></li><li><p><strong>description 网站说明</strong></p></li><li><ul><li><span style="color: red">简要说明网站是干什么的。 </span></li><li>例：京东JD.COM-专业的综合网上购物商城，销售家电、数码通讯、电脑、家居百货…….为您提供愉悦的购物体验。</li></ul></li><li><p><strong>keyword 关键字</strong></p></li><li><ul><li>页面关键字，是搜索引擎的关注度之一。</li><li>最好限制在6-8个关键字，关键字之间用英文逗号隔开。</li></ul></li><li><p>例：</p></li></ul></li><li><pre><code>&lt;meta name=&quot;description&quot; content=&quot;......&quot;/&gt;</code></pre></li><li></li></ul><h2 id="2-LOGO的SEO-优化："><a href="#2-LOGO的SEO-优化：" class="headerlink" title="2. LOGO的SEO 优化："></a>2. LOGO的SEO 优化：</h2><p>具体步骤：</p><p><strong>1. logo里面首先放一个h1标签，目的是为了提权，告诉搜索引擎这个地方很重要。</strong></p><p><strong>2. h1里面再放一个链接(a)，可以返回首页的，把logo的背景图片给链接即可。</strong></p><p><strong>3. 为了搜索引擎的收录，链接里要放文字（网站名称），但是文字不能显示出来。</strong></p><ul><li>方法一：<span style="color: red">text-indent </span>移到盒子外面（<span style="color: red">text-indent: -9999px; </span>），然后<span style="color: red">over-flow: hidden;</span>   （淘宝的做法）</li><li>方法二：直接给<span style="color: red">font-size: 0;  </span>就看不到文字了（京东的做法）。</li></ul><p><strong>4. 最后给链接一个<span style="color: red">title</span>属性，这样鼠标放到logo上就可以看到提示文字。</strong></p><p>示例： </p><pre><code>  &lt;header class=&quot;header&quot;&gt;    &lt;div class=&quot;logo&quot;&gt;      &lt;h1&gt;        &lt;a href=&quot;index.html&quot; title=&quot;这是一个网站名称&quot;&gt;这是一个网站名&lt;/a&gt;      &lt;/h1&gt;    &lt;/div&gt;  &lt;/header&gt;</code></pre><p>css部分省略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git代码写错分支了怎么办</title>
      <link href="posts/e1ab1244/"/>
      <url>posts/e1ab1244/</url>
      
        <content type="html"><![CDATA[<p>2021/12/14 11:07</p><p><strong>场景</strong>：代码写在了主分支，在提交时显示”推送被拒“。</p><p><strong>步骤：</strong> </p><h3 id="1-当未提交代码："><a href="#1-当未提交代码：" class="headerlink" title="1.当未提交代码："></a><strong>1.当未提交代码</strong>：</h3><pre><code>// 第一步，将修改的代码暂存到stashgit stash// 第二步，切换到正确的分支git checkout targetbranch // 第三步，从stash中取出暂存的代码修改。git stash pop</code></pre><p>​             </p><p>继续提交的话就是</p><pre><code>git add .git commit -m xx  </code></pre><h3 id="2-当已经提交了："><a href="#2-当已经提交了：" class="headerlink" title="2. 当已经提交了："></a><strong>2. 当已经提交了：</strong></h3><p>撤回即可</p><pre><code>git reset HEAD^              </code></pre><p>然后继续执行 没提交时的操作。</p><h3 id="3-已经push了："><a href="#3-已经push了：" class="headerlink" title="3. 已经push了："></a><strong>3.</strong> <strong>已经push了：</strong></h3><p>同已经提交了的步骤。 先撤回，然后再push下撤回后的。不过会有记录</p><p><strong>PS： 期间还有别的报错：</strong> </p><ul><li>本地与远程冲突：git pull</li><li>error: The following untracked working tree files would be overwritten by ch： 大概也是因为未拉取。</li><li>Branch ‘dev-test2’ set up to track remote branch ‘dev-test2’ from ‘origin’.：<ul><li>1.可以使用：git status 查看什么情况，</li><li>2.原因可能是这些变化没有提交，根据git status 的提醒，可以提交，然后就可以切换分支了。</li><li>3.git checkout 要切换的分支。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于移动端CSS</title>
      <link href="posts/7a4077d8/"/>
      <url>posts/7a4077d8/</url>
      
        <content type="html"><![CDATA[<p><strong>总结</strong>： 兼容移动端主流浏览器，处理Webkit内核浏览器即可。</p><p>查看设备网站：<a href="https://material.io/devices/">https://material.io/devices/</a></p><h2 id="1-移动端调试方法"><a href="#1-移动端调试方法" class="headerlink" title="1. 移动端调试方法"></a>1. 移动端调试方法</h2><ul><li>chrome浏览器的模拟手机；</li><li>搭建本地服务器，手机和服务器在一个局域网内，通过手机访问服务器；</li><li>使用外网服务器，直接IP或域名访问。</li></ul><h2 id="2-二倍图"><a href="#2-二倍图" class="headerlink" title="2. 二倍图"></a>2. 二倍图</h2><h3 id="2-1-物理像素-amp-物理像素比"><a href="#2-1-物理像素-amp-物理像素比" class="headerlink" title="2.1 物理像素&amp;物理像素比"></a>2.1 物理像素&amp;物理像素比</h3><ul><li>PC端和古早的普通手机屏幕：1css像素=1物理像素。</li><li>Retina（视网膜屏幕）是一种显示技术，可以将更多物理像素点压缩至一块屏幕里，从而达到更高分辨率，并提高屏幕显示的细腻程度。</li></ul><p>所以：当一个50 * 50px的图片，直接放到iPhone8里就会被放大2倍至100 * 100导致模糊。</p><p><strong>解决</strong>：采取使用100 * 100的图片，然后手动设为50 * 50的css像素。</p><p><strong>总结</strong>：准备的图片比实际需要的大2倍，这种方式就是2倍图。</p><h2 id="3-CSS初始化-normalize-css"><a href="#3-CSS初始化-normalize-css" class="headerlink" title="3. CSS初始化 normalize.css"></a>3. CSS初始化 normalize.css</h2><ul><li>保护了有价值的默认值</li><li>修复了浏览器的bug</li><li>是模块化的</li><li>有详细的文档。</li></ul><p><strong>官网地址</strong>： <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p><h2 id="4-移动端特殊样式"><a href="#4-移动端特殊样式" class="headerlink" title="4.移动端特殊样式"></a>4.移动端特殊样式</h2><ul><li>给a标签去掉高亮（移动端可能会有这种情况）：</li></ul><pre><code>  -webkit-tap-highlight-color: transparent;</code></pre><p>​     </p><ul><li>在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式：</li></ul><pre><code>-webkit-appearance: none;</code></pre><ul><li>禁止长按页面时的弹出菜单：</li></ul><pre><code>img, a &#123;  -webkit-touch-callout: none;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小总结</title>
      <link href="posts/ac58b7ea/"/>
      <url>posts/ac58b7ea/</url>
      
        <content type="html"><![CDATA[<h2 id="1-函数："><a href="#1-函数：" class="headerlink" title="1. 函数："></a><strong>1. 函数：</strong></h2><ul><li>在实际开发中，经常会使用一个变量来接收函数返回的结果。</li><li>return 有终止函数的作用，return后的语句不会被执行。</li><li>return只能返回一个值。（有多个时返回最后一个）</li><li>所以当要return返回多个时，可以使用数组：</li></ul><p>return [num1+num2,num1*num2]</p><ul><li><p>函数都有返回值。若有，则返回return后的值；若没有，则返回undefined。</p></li><li><ul><li><strong>arguments的使用：</strong> ( 注意：只有函数才有arguments)</li><li>当不确定有多少个参数传递的时候，可以用arguments来获取。在JS中，arguments实际上是当前函数的一个内置对象。<strong>所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</strong></li></ul></li><li><p>arguments的展示形式是一个伪数组，因此可以进行遍历。</p></li><li><p>伪数组的特点：     （伪数组并不是真正意义上的数组）</p></li><li><ul><li>具有length属性；</li><li>按索引方式存储数据；</li><li>不具有数组的push，pop等方法。</li></ul></li><li><p>代码从上往下执行。当执行到调用某函数时，会去找执行部分的代码，如下面的 函数中调用另一个函数：</p></li></ul><pre><code>function fn1() &#123;    console.log(111)         /* 第1个执行 */    fn2()    console.log(&#39;fn1&#39;)       /* 第4个执行 */  &#125;  function fn2() &#123;    console.log(222)         /* 第2个执行 */    console.log(&#39;fn2&#39;)       /* 第3个执行 */  &#125;  fn1();                     /* 先找到这里 */   // 执行顺序： // 从上往下，fn1和fn2的代码块都未调用，所以这两个代码块都先不管。 // 所以1.先走到fn1(); =&gt;找到fn1代码块=&gt;执行并输出111。 // 2.又走到fn2()=&gt;所以去找fn2代码块=&gt;执行并输出222，fn2。 // 3.回去接着执行并输出fn1。</code></pre><h2 id="2-JS作用域："><a href="#2-JS作用域：" class="headerlink" title="2. JS作用域："></a><strong>2. JS作用域：</strong></h2><ul><li><p>就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突。</p></li><li><p>在ES6之前：全局作用域，局部作用域（也叫函数作用域）。两者就算名字一样也互不影响。</p></li><li><p>注意：函数的形参也可以看作局部变量。</p></li><li><p>从执行效率来说，</p></li><li><ul><li>全局变量：只有在浏览亲关闭的时候才会销毁。比较占内存资源。</li><li>局部变量：当程序执行完之后就会销毁。比较节约内存资源。</li></ul></li><li><p>块级作用域：ES6新增的，原本JS中没有块级作用域。</p></li><li><p><strong>作用域链：</strong>     （<strong>就近原则</strong>）</p></li><li><ul><li>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值。这种结构就叫作用域链。</li></ul></li></ul><h2 id="3-JS预解析："><a href="#3-JS预解析：" class="headerlink" title="3. JS预解析："></a><strong>3. JS预解析：</strong></h2><ul><li><p>JS引擎运行JS分为两步：预解析、代码执行。</p></li><li><p>预解析：JS引擎会把JS里所有的var和function提升到当前作用域的最前面。</p></li><li><ul><li>变量预解析（变量提升）：就是把所有的变量声明提升到<strong>当前</strong>作用域的最前面，<strong>不提升赋值操作</strong>。</li><li>函数预解析（函数提升）：就是把所有函数声明提升到当前作用域的最前面，不调用函数。<strong>只有函数声明形式才有函数提升。</strong></li><li><strong>函数提升优先级高于变量提升。</strong></li></ul></li></ul><pre><code>// 1.下面的输出结果是什么：  console.log(num);  var num = 10;  // 其实相当于下面的代码：  var num;  console.log(num);                   /* 所以undefined */  num = 10;</code></pre><pre><code> // 2.下面的输出结果是什么：  fun();  var fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)  &#125;  // 其实相当于下面的代码：  var fun;  fun();  fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)                 /* 所以报错 */  &#125;</code></pre><pre><code>// 3.为什么调用写在最前面也可以：  fn();  function fn() &#123;    console.log(11);         /* 因为函数提升，把函数声明提升到当前作用域的最前面。 */  &#125;// 例子1 ：  var num= 10  fun();  function fun() &#123;    console.log(num);    var num = 20;  &#125;  // 相当于执行下面的代码：  var num;                         /* 外层的变量提升 */  function fun() &#123;                 /* 外层的函数提升 */    var num;                       /* 里层的变量提升 */    console.log(num);               /* undefined，因为就近原则 */    num = 20;  &#125;  num = 10;  fun();</code></pre><pre><code>// 例子2 ：  var num = 10;  function fn() &#123;    console.log(num);    var num = 20;    console.log(num);  &#125;  fn();​  // 相当于执行下面的代码：  var num;  function fn() &#123;    var num;    console.log(num);                   /* undefined，就近原则 */    num = 20;    console.log(num);                   /* 20 */  &#125;  num = 10;  fn();</code></pre><pre><code>// 例子3 ：  var a = 18;  f1();  function f1() &#123;    var b = 9;    console.log(a);    console.log(b);    var a = &#39;123&#39;;  &#125;  // 相当于执行下面的代码：  var a;  function f1() &#123;    var b;    b = 9;    var a;    console.log(a);                     /* undefined */    console.log(b);                     /* 9 */    a = &#39;123&#39;;  &#125;  a = 18;  f1();</code></pre><pre><code>// 例子4 ：     这道题需要注意  f1();  console.log(c);  console.log(b);  console.log(a);  function f1() &#123;    // 这句相当于var a =9； b = 9；c = 9; 而不是var a;var b;var c;    // 所以b、c并没有声明!!! 要当全局看    var a = b = c = 9;                  console.log(a);    console.log(b);    console.log(c);  &#125;  // 相当于执行下面的代码：  function f1() &#123;    var a;      a = b = c = 9;      // var b;     不是这样，写错了。。。    // var c;    // a = 9;    // b = 9;    // c = 9;    var a;    console.log(a);                   /* 9 */    console.log(b);                   /* 9 */    console.log(c);                   /* 9 */  &#125;  f1();  console.log(c);                     /* 9 */  console.log(b);                     /* 9 */  console.log(a);                     /* undefined,局部变量 */</code></pre><ul><li>代码执行：按照代码顺序从上往下执行。</li></ul><h2 id="对象："><a href="#对象：" class="headerlink" title="对象："></a><strong>对象：</strong></h2><ul><li><p>在JS中，对象是一组无序的相关属性和方法的集合，所有事物都是对象，如数组、字符串、函数、数值。</p></li><li><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的。</p></li><li><p>属性：是事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示。（常用名词）</p></li><li><p>方法：是事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示。（常用动词）</p></li><li><p>为什么需要对象：</p></li><li><ul><li>保存一个值时，可以使用变量，保存多个值时，可以使用数组，如果要保存一个人的完整信息嘞~    </li></ul></li><li><p>现阶段可以用三种方式创建对象：</p></li><li><ul><li>字面量创建；</li><li>new Object创建对象；</li><li>利用构造函数创建对象。</li></ul></li></ul><h2 id="类class："><a href="#类class：" class="headerlink" title="类class："></a><strong>类class：</strong></h2><ul><li>在ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。</li><li><strong>类</strong>抽象了对象的公共部分，它泛指某一大类(class)。</li><li><strong>对象</strong>特指某一个，通过类实例化一个具体的对象。</li></ul><h3 id="1-创建类："><a href="#1-创建类：" class="headerlink" title="1.创建类："></a><strong>1.创建类：</strong></h3><p>语法：</p><pre><code>class name &#123;    //class body&#125;</code></pre><p>创建实例：</p><pre><code>var xx =  new name();</code></pre><p>注意：类必须使用new实例化对象。</p><h3 id="2-类-constructor-构造函数"><a href="#2-类-constructor-构造函数" class="headerlink" title="2.类 constructor 构造函数"></a><strong>2.类 constructor 构造函数</strong></h3><ul><li><strong>constructor()</strong> 方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显式定义，类的内部会自动创建一个constructor()。</li><li>有了它就不用return。</li></ul><p>例：</p><pre><code>// 1.创建类class，创建一个Star类。class name &#123;    constructor(uname) &#123;        // this指向创建的实例：        this.uname = uname;      /* 将uname指向创建的实例，这样就接收了这个参数 */        this.age = age;    &#125;    sing(song) &#123;        console.log(&#39;略略略&#39;);        console.log(this.name + song);    &#125;&#125;// 2.利用类创建对象 newvar zs = new Star(&#39;张三&#39;,18);   /* 只要加了new，就自动调用constructor。 */var ls = new Star(&#39;李四&#39;,20); console.log(zs);           /* 输出张三 */console.log(ls);zs.sing(&#39;lost river&#39;);zs.sing(&#39;///////&#39;);</code></pre><p><strong>注意点：</strong></p><ol><li>通过class关键字创建类，类名要大写。</li><li>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象。</li><li>constructor函数只要new生成实例时，就会自动调用这个函数，如果不写这个函数，类也会自动生成这个函数。</li><li>生成实例，new不能省略。</li><li>最后注意语法规范，<strong>创建类</strong>，类名后面不要加小括号，<strong>生成实例</strong>，类名后面要加小括号，构造函数不需要加function。</li></ol><p>另外：</p><ul><li>类里面所有的函数都不用写function来声明。</li><li>类里面，所有函数/方法之间不能加逗号分割。</li><li></li></ul><h3 id="3-类的继承："><a href="#3-类的继承：" class="headerlink" title="3. 类的继承："></a><strong>3. 类的继承：</strong></h3><p>下次更新写。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础回顾 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/3eeb/"/>
      <url>posts/3eeb/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS三角的制作</title>
      <link href="posts/433aec41/"/>
      <url>posts/433aec41/</url>
      
        <content type="html"><![CDATA[<h2 id="1-等腰三角形"><a href="#1-等腰三角形" class="headerlink" title="1. 等腰三角形"></a>1. 等腰三角形</h2><p>使用场景：悬停到导航栏的某个li</p><p>原理：</p><pre><code>// 宽高必须是0 ！！！.box1 &#123;    width: 0;    height: 0;    border: 10px solid transparent;    // 只改某一边的颜色：    border-top-color: blue；    // 兼容低版本浏览器：    line-height: 0;    font-size: 0;&#125;</code></pre><p>transparent: 透明的。</p><h2 id="2-直角三角形"><a href="#2-直角三角形" class="headerlink" title="2. 直角三角形"></a>2. 直角三角形</h2><p>使用场景：制作梯形时，例：</p><p>  <img src="https://s2.loli.net/2022/10/05/pwfxo1imyKztODA.png" alt="image-20221005085722720"></p><p>原理：    和上面类似，图解：</p><p>​    <img src="https://s2.loli.net/2022/10/05/EAzkygNa9QG23i8.png" alt="image-20221005085758685"></p><pre><code>.box2 &#123;    width: 0;    height: 0;    // 上边框取高点，撑起盒子高度：    border-top: 100px solid transparent;    border-right: 50px solod skyblue;    // 下面这行可以让一个正方形的4个三角变为3个：    // 左边和下边的边框宽度必须为0：    border-bottom: 0 solod blue;   border-left: 0 solod green;&#125;</code></pre><p>​           </p><p>上面的代码简写为：</p><pre><code>.box2 &#123;    width: 0;    height: 0;    border-color: transparent skyblue transparent transparent;    border-style: solid;    border-width: 100px 50px 0 0;    &#125;</code></pre><p>​       </p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Less</title>
      <link href="posts/73843be1/"/>
      <url>posts/73843be1/</url>
      
        <content type="html"><![CDATA[<p>CSS的弊端：</p><img src="https://s2.loli.net/2022/10/05/aV2fh4OoXpzNFKr.png" alt="image.png" style="zoom:80%;" /><hr><h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><h2 id="1-Less介绍"><a href="#1-Less介绍" class="headerlink" title="1. Less介绍"></a>1. Less介绍</h2><ul><li>Leaner Style Sheets，是一门CSS扩展语言，也称为<span style="color: #FFB700">CSS预处理器</span>。</li><li>作为CSS的一种形式的扩展，在现有的CSS语法上为CSS加入程序式的特性。</li><li>它在CSS的语法上，引入了<u>变量，Mixin（混入），运算以及函数</u>等功能，简化了CSS的编写，降低了维护成本。</li><li>既可以在客户端运行，也可以在服务器端运行（Node、Rhino平台）。</li><li>Less中文网址：<a href="http://lesscss.cn/">http://lesscss.cn/</a></li><li>中文文档：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></li><li>常见的CSS预处理器：<span style="background-color: #f2f4f5;">Sass、Less、Stylus</span>。</li></ul><h2 id="2-Less使用"><a href="#2-Less使用" class="headerlink" title="2. Less使用"></a>2. Less使用</h2><h3 id="2-1-Less编译为CSS"><a href="#2-1-Less编译为CSS" class="headerlink" title="2.1 Less编译为CSS"></a>2.1 Less编译为CSS</h3><p><strong>方式一</strong>：less文件需要编译，在<strong>官网下载less.js文件</strong>，引入该文件。</p><p>需要注意：</p><ul><li>引入的less文件要放在js编译文件之上，否则没效果。</li><li><span style="background-color: #f2f4f5;">rel=”stylesheet/less” </span>，在原先写法上加 <span style="background-color: #f2f4f5;">/less</span>。</li></ul><pre><code>&lt;link rel=&quot;stylesheet/less&quot; href=&quot;&quot;&gt;&lt;script src=&quot;/less.js&quot;&gt; &lt;/script&gt;</code></pre><p><strong>方式二   Vscode less 插件：</strong></p><ul><li><span style="color: #ff0001"><strong>Easy LESS</strong></span><strong>插件用来把less文件编译为css文件。</strong></li><li><strong>安装完插件后，重新加载下Vscode。只要保存一下less文件，会自动生成css文件。</strong></li><li>在写样式时只需关注less文件，对应的css文件会自动更新。</li></ul><h3 id="2-2-Less的注释"><a href="#2-2-Less的注释" class="headerlink" title="2.2 Less的注释"></a>2.2 Less的注释</h3><ul><li><span style="color: #ff0001;background-color: #f2f4f5;">// </span>：这种注释在编译后不会出现在css文件中。</li><li><span style="color: #ff0001;background-color: #f2f4f5;">/* */</span>：这种编译后会出现在css文件中。</li></ul><hr><h2 id="3-Less变量"><a href="#3-Less变量" class="headerlink" title="3. Less变量"></a>3. Less变量</h2><h3 id="3-1-几种变量的使用"><a href="#3-1-几种变量的使用" class="headerlink" title="3.1 几种变量的使用"></a>3.1 几种变量的使用</h3><h4 id="1-选择器变量"><a href="#1-选择器变量" class="headerlink" title="1. 选择器变量"></a>1. 选择器变量</h4><p>将选择器名称写为变量。</p><p>举例：</p><pre><code>@boxSelector: #wrap;@wrap: wrap;使用：@&#123;boxSelector&#125; &#123;    color: #bbb;    width: 200px;&#125;.@&#123;wrap&#125; &#123;    color: #bbb;    width: 200px;&#125;最后编译的css为：#boxSelector &#123;    color: #bbb;    width: 200px;&#125;.wrap &#123;    color: #bbb;    width: 200px;&#125;</code></pre><h4 id="2-属性变量"><a href="#2-属性变量" class="headerlink" title="2. 属性变量"></a>2. 属性变量</h4><ul><li><span style="color: #FFB700">属性名</span>和<span style="color: #FFB700">属性值</span>都可以是变量。<ul><li><strong>语法</strong>： <span style="background-color: #f2f4f5;"><strong>@{ xxx }: @yyy;</strong></span></li><li><strong>注意</strong>：<span style="color: #0091ff">属性名</span>要被一对<span style="color: #0091ff">花括号</span>包起来，而<span style="color: #0091ff">值不用</span>。</li></ul></li><li>举例：</li></ul><pre><code>定义变量：@w: width;@w-value: 100px;使用： .box&#123;     @&#123;w&#125;: @w-value; &#125; </code></pre><h4 id="3-URL变量"><a href="#3-URL变量" class="headerlink" title="3. URL变量"></a>3. URL变量</h4><p>方便拼接，后续路径更改只需改一次变量中的值。</p><p>举例：</p><pre><code>@images: &quot;../img/&quot;;.box &#123;    background: url(&#39;@images/除变量以外需要拼接的路径.png&#39;);&#125;</code></pre><h4 id="4-声明变量"><a href="#4-声明变量" class="headerlink" title="4. 声明变量"></a>4. 声明变量</h4><p>相当于<span style="color: #ff0001">属性名和值一起</span>。</p><ul><li>使用变量的语法：<span style="color: #E95200;background-color: #f2f4f5;">@bg();</span>；</li><li>注意后面需要加上 <span style="color: #E95200;background-color: #f2f4f5;"> () </span> 。</li></ul><p>举例：</p><pre><code>@bg: &#123; background: #fff; &#125;;.box &#123;    @bg();&#125;</code></pre><h4 id="5-变量的运算"><a href="#5-变量的运算" class="headerlink" title="5. 变量的运算"></a>5. 变量的运算</h4><p><strong>1. 用法示例</strong>：</p><pre><code>@w = 100px;div &#123;    width: @w - 50;&#125;</code></pre><p><strong>2.</strong> <span style="color: #CC0000"><strong>注意点：</strong></span></p><ul><li>运算符<span style="color: #FFB700">左右</span>必须有个<span style="color: #ff0001"><strong>空格</strong></span>；</li><li>变量的<span style="color: #ff0001"><strong>单位</strong></span>问题：<ul><li>加减法：<span style="color: #E95200"><strong>取第一个</strong></span>为准。</li><li>乘除法：<span style="color: #E95200"><strong>单位一定要统一</strong></span>。</li></ul></li></ul><h4 id="6-变量的作用域-amp-用变量定义变量"><a href="#6-变量的作用域-amp-用变量定义变量" class="headerlink" title="6. 变量的作用域 &amp; 用变量定义变量"></a>6. 变量的作用域 &amp; 用变量定义变量</h4><p><strong>作用域：就近原则</strong>，和css的处理方式是一样的。</p><p>两种结合起来举例：</p><pre><code>@width: @a;@a: 100%;.div &#123;    width: @width;    @a: 9%&#125;以上被解析为：width: 9%;个人理解：不仅是变量的就近原则，还有下面样式覆盖上面的因素在。</code></pre><h4 id="7-混合"><a href="#7-混合" class="headerlink" title="7. 混合"></a>7. 混合</h4><ul><li>可以带参数。。。。(此处待记……)</li><li>可以有多个参数。</li></ul><p><img src="https://s2.loli.net/2022/10/05/kcuTQpieW9aqBwC.png" alt="image-20221005113444528"></p><h3 id="3-2-变量命名规范"><a href="#3-2-变量命名规范" class="headerlink" title="3.2 变量命名规范"></a>3.2 <strong>变量命名规范</strong></h3><ul><li><strong>必须含有</strong><span style="color: #ff0001"><strong>@为前缀</strong></span>；</li><li><strong>不能包含</strong><span style="color: #ff0001"><strong>特殊字符</strong></span>；</li><li><strong>不能以数字开头</strong>；</li><li><strong>大小写敏感</strong>。（@color和@<span style="color: #ff0001">C</span>olor是两个变量）</li></ul><p>例：</p><pre><code>// 定义一个蓝色的变量：@color: pink;body &#123;    background: @color;&#125;</code></pre><h2 id="4-Less嵌套"><a href="#4-Less嵌套" class="headerlink" title="4. Less嵌套"></a>4. Less嵌套</h2><h3 id="4-1-amp-符的使用"><a href="#4-1-amp-符的使用" class="headerlink" title="4.1 &amp;符的使用"></a>4.1 &amp;符的使用</h3><ul><li>当结构有<strong>嵌套</strong>时，<strong>使用</strong> <strong><span style="color: #FFB700">&amp;</span> 与不使用的区别</strong>：<ul><li>使用 &amp;符会不发生嵌套，而是直接替换了。</li></ul></li><li>有<strong>伪类/伪元素</strong>时需要用<span style="color: #FFB700"><strong>&amp;</strong></span>。</li></ul><p><strong>例1：</strong></p><pre><code>#header &#123;    &amp;:after &#123;        content: &#39;less is more&#39;;        &#125;    .title &#123;        font-weight: bold;        &#125;    &amp;_content &#123;        margin: 20px;        &#125;&#125;// 生成的css： 下面注意区分#header::after &#123;    content: &#39;less is more&#39;;&#125;#header .title &#123;   // 嵌套了    font-weight: bold;&#125;#header_content &#123;   // 没嵌套！！！替换了    margin: 20px;&#125;</code></pre><p><strong>例2</strong>：</p><pre><code>&lt;div class=&quot;logo&quot;&gt;  &lt;a href=&quot;&quot;&gt;这是一个网站名称&lt;/a&gt;&lt;/div&gt;</code></pre><p>less的写法：</p><pre><code>.logo &#123;  width: 100px;  a &#123;    color: blue;  &#125;&#125;</code></pre><p><strong>例3：</strong>当有<strong>伪类/伪元素</strong>时，用**&amp;**。</p><p>例：</p><pre><code>a &#123;    color: blue;&#125;a:hover &#123;    color: green;&#125;</code></pre><p><strong>要写成：</strong></p><pre><code>a &#123;    color: blue;    // 要变成这样    &amp;:hover &#123;        color: green;    &#125;&#125;</code></pre><h3 id="4-2-媒体查询"><a href="#4-2-媒体查询" class="headerlink" title="4.2 媒体查询"></a>4.2 媒体查询</h3><p>在css中，不同元素样式要在每个尺寸下都写，Less可以在写当前元素样式时顺带写媒体查询（如下）。</p><p><strong>缺点</strong>：每个元素汇编出自己的 @media 声明，并<strong>不会合并</strong>。</p><pre><code>#wrap &#123;    width: 500px;&#125;@media screen and (max-width: 768px) &#123;    #wrap &#123;        width: 100px;        &#125;&#125;// 使用Less：#main &#123;    @media screen &#123;        @media (max-width: 768px) &#123;            width: 100px;                &#125;        &#125;    @media tv &#123;        width: 100px;          &#125;&#125;</code></pre><h3 id="使用技巧——定义私有样式-（待续…）"><a href="#使用技巧——定义私有样式-（待续…）" class="headerlink" title="使用技巧——定义私有样式  （待续…）"></a>使用技巧——定义私有样式  （待续…）</h3><hr><h2 id="5-匹配模式——条件判断"><a href="#5-匹配模式——条件判断" class="headerlink" title="5. 匹配模式——条件判断"></a>5. 匹配模式——条件判断</h2><p>条件符合时使用该样式渲染页面。</p><p><a href="https://www.bilibili.com/video/BV13F411Y7ro?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=427.5">https://www.bilibili.com/video/BV13F411Y7ro?p=7&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=427.5</a></p><p>举例：</p>  <img src="https://s2.loli.net/2022/10/05/rwnDo5TUtB6O29u.png" alt="image-20221005113936555" style="zoom:80%;" /><p>如何使用上面的判断：同样在括号中放入参数，进入匹配模式。</p><p>  <img src="https://s2.loli.net/2022/10/05/1DQS9yq2u5Nvcn8.png" alt="image.png"></p><h2 id="6-导入"><a href="#6-导入" class="headerlink" title="6. 导入"></a>6. 导入</h2><p><a href="https://www.bilibili.com/video/BV1fS4y127nt?p=6&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=11.0">https://www.bilibili.com/video/BV1fS4y127nt?p=6&amp;vd_source=d839eda9a2b875da47ce4ee8814c818f&amp;t=11.0</a></p><p><strong>1.</strong> <span style="color: #0091ff"><strong>文件导入</strong></span>：可以不加文件后缀名。</p><pre><code>// 在index.less文件中导入nav.less：@import &quot;nav&quot;;</code></pre><p><strong>2.</strong> <span style="color: #0091ff"><strong>reference</strong></span>：引入Less文件，而不编译它。</p><pre><code>@import (reference) &quot;nav&quot;;</code></pre><p><strong>3.</strong> <span style="color: #0091ff"><strong>once</strong></span>：@import语句的**<u>默认行为</u>**。表明相同的文件只会被导入一次，随后导入的文件的重复代码不会再解析。</p><pre><code>@import (once) &quot;nav&quot;;</code></pre><p><strong>4.</strong> <span style="color: #0091ff"><strong>multiple</strong></span>：<u>允许导入<strong>多个同名文件</strong></u>。</p><pre><code>@import (multiple) &quot;nav&quot;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swiper自定义分页器&amp;自定义切换按钮</title>
      <link href="posts/7b1d00b1/"/>
      <url>posts/7b1d00b1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-swiper自定义分页器："><a href="#1-swiper自定义分页器：" class="headerlink" title="1. swiper自定义分页器："></a>1. swiper自定义分页器：</h3><p>js部分：</p><pre><code>pagination: &#123;  el: &#39;.swiper-pagination&#39;,  type: &#39;custom&#39;,  renderCustom: function (swiper, current, total) &#123;    // 分页器激活样式的改变---给自己添加激活样式并将兄弟的激活样式移出。    // $(&#39;.swiper-pagination&#39;).children().eq(current - 1).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);    var paginationHtml = &quot; &quot;;    for (var i = 0; i &lt; total; i++) &#123;      // 判断是不是焦点，是的话添加active类，不是就只添加基本样式类      if (i === (current - 1)) &#123;        paginationHtml += &#39;&lt;span class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;/span&gt;&#39;;      &#125; else &#123;        paginationHtml += &#39;&lt;span class=&quot;swiper-pagination-customs&quot;&gt;&lt;/span&gt;&#39;;      &#125;    &#125;    return paginationHtml;  &#125;&#125;,</code></pre><p>​           </p><p>上面的代码可以忽略：</p><p>下面是最终的：</p><pre><code>renderCustom: function (swiper, current, total) &#123;  // 分页器激活样式的改变---给自己添加激活样式并将兄弟的激活样式移出。  $(&#39;.swiper-pagination&#39;).children().eq(current - 1).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);  var paginationHtml = &quot; &quot;;  for (var i = 0; i &lt; total; i++) &#123;    if (i === (current - 1)) &#123;      // paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;/li&gt;&#39;;      if (i === 0) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon1.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;猎人来了我怕怕&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 1) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon2.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;幼犬皮皮&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 2) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon3.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;正义街道儿&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 3) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs swiper-pagination-customs-active&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon4.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;3A大作&lt;/p&gt;&lt;/li&gt;&#39;;      &#125;    &#125; else &#123;      // paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs&quot;&gt;&lt;/li&gt;&#39;;      if (i === 0) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon1.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;猎人来了我怕怕&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 1) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon2.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;幼犬皮皮&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 2) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon3.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;正义街道儿&lt;/p&gt;&lt;/li&gt;&#39;;      &#125; else if (i === 3) &#123;        paginationHtml += &#39;&lt;li class=&quot;swiper-pagination-customs&quot;&gt;&lt;img src=&quot;./static/imgs/gamedetail/icon4.png&quot; alt=&quot;&quot;&gt;&lt;p&gt;3A大作&lt;/p&gt;&lt;/li&gt;&#39;;      &#125;    &#125;  &#125;  return paginationHtml;&#125;</code></pre><p>​       </p><p>2021/12/23 16:26 更新</p><h3 id="2-自定义切换按钮："><a href="#2-自定义切换按钮：" class="headerlink" title="2. 自定义切换按钮："></a>2. 自定义切换按钮：</h3><p>效果：</p><p><img src="https://s2.loli.net/2022/10/05/QoZKAk5LDpW1txN.png" alt="image-png"></p><p>html代码：</p><pre><code>&lt;div class=&quot;swiper-button-next drag-right&quot;&gt;&lt;/div&gt;</code></pre><p>配置项：           </p><pre><code>navigation: &#123;  nextEl: &#39;.swiper-button-next&#39;,&#125;,</code></pre><p>css代码：</p><pre><code>/*去掉默认样式*/.swiper-button-next:after &#123;  display: none;&#125;.swiper-button-next &#123;  background: url(&quot;https://vplus-1302389019.cos.ap-guangzhou.myqcloud.com/mobile/slideRight.png&quot;)    no-repeat;  background-size: 100% 100%;  bottom: 6rem;  width: 1rem !important;  height: 1.3rem !important;&#125;.drag-right &#123;  bottom: 6rem;  right: 0.2rem;  position: absolute;  z-index: 888;  width: 1rem;  height: 1.3rem;  animation: 1.2s ease-in-out 0s infinite normal none running btn-run;  -webkit-animation: btn-run 1.2s infinite;  -moz-animation: btn-run 1.2s infinite;  -ms-animation: btn-run 1.2s infinite;&#125;@keyframes btn-run &#123;  0% &#123;    right: 0.2rem;    transform: scale(1);  &#125;  15% &#123;    right: 0.28rem;    transform: scale(1);  &#125;  30% &#123;    right: 0.36rem;    transform: scale(1.05);  &#125;  50% &#123;    right: 0.43rem;    transform: scale(1.1);  &#125;  70% &#123;    right: 0.36rem;    transform: scale(1.05);  &#125;  85% &#123;    right: 0.28rem;    transform: scale(1);  &#125;  100% &#123;    right: 0.2rem;    transform: scale(1);  &#125;&#125;.drag-right img &#123;  width: 100%;  height: 100%;&#125;</code></pre><p><strong>PS:</strong> </p><p>自定义按钮去掉点击时的蓝色边框：</p><pre><code>cursor: none;// 或删掉：cursor: pointer;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 插件&amp;工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件&amp;工具使用 </tag>
            
            <tag> swiper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>border、padding与margin</title>
      <link href="posts/553bfec9/"/>
      <url>posts/553bfec9/</url>
      
        <content type="html"><![CDATA[<p><strong>场景</strong>：鼠标悬停出现内边框，位置不是写死的，所以导致li上下动。</p><p><strong>解决</strong>：添加padding。且padding值 = -border里的数字。</p><pre><code>border: #00FFFF 5px inset;margin: -5px;</code></pre><p><strong>PS</strong>：如果是外边框，就添加margin。</p><pre><code>border: #00FFFF 5px inset;padding: -5px;</code></pre><p>（一开始我想反了，觉得内边框加padding。因为觉得内边框在里面，内容撑大了盒子所以要padding为负来解决。）</p><p>但刚好相反。</p><ul><li>另外，关于<strong>border颜色不一。</strong></li></ul><p>原先：</p><pre><code>border: #00FFFF 5px inset; </code></pre><p>改成solid：</p><pre><code>border: #00FFFF 5px solid;</code></pre><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外边距合并现象</title>
      <link href="posts/62abd823/"/>
      <url>posts/62abd823/</url>
      
        <content type="html"><![CDATA[<p><strong>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并</strong>。</p><h3 id="1-相邻块元素垂直外边距的合并："><a href="#1-相邻块元素垂直外边距的合并：" class="headerlink" title="1. 相邻块元素垂直外边距的合并："></a>1. 相邻块元素垂直外边距的合并：</h3><ul><li>当上下两个相邻的两个块元素（兄弟元素）相遇时，如果上面的元素有下边距margin-bottom，下面的元素有上边距margin-top。则它们之间的距离不是两者之和，而是其一的最大值。</li><li><strong>解决方案</strong>：避免这种写法。</li></ul><h3 id="2-嵌套块元素垂直外边距的塌陷："><a href="#2-嵌套块元素垂直外边距的塌陷：" class="headerlink" title="2. 嵌套块元素垂直外边距的塌陷："></a>2. 嵌套块元素垂直外边距的塌陷：</h3><ul><li>对于两个嵌套关系（父子）的块元素，父元素有上边距，同时子元素也有上边距，此时父元素会塌陷较大的外边距值。</li><li><strong>解决方案</strong>：<ul><li>给父元素定义上边框；</li><li>给父元素定义上内边距；    (和上一种一样，都是与子元素分开)</li><li>给父元素添加：overflow: hidden;    （比较常用）</li><li>还有其他方法，比如浮动、固定、绝对定位的盒子不会有塌陷问题。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需要留意的可置换元素</title>
      <link href="posts/1fc36a4e/"/>
      <url>posts/1fc36a4e/</url>
      
        <content type="html"><![CDATA[<h2 id="block，inline和inlinke-block细节对比："><a href="#block，inline和inlinke-block细节对比：" class="headerlink" title="block，inline和inlinke-block细节对比："></a>block，inline和inlinke-block细节对比：</h2><p> inline-block看上去值名inline-block是一个混合产物，实际上确是如此，将元素显示为行内块状元素，设置该属性后，其他的行内块级元素会排列在同一行。比如我们li元素一个inline-block，使其既有block的宽度高度特性，又有inline的同行特性，在同一行内有不同高度内容的元素时，通常要设置对齐方式如vertical-align: top;来使元素顶部对齐。</p><blockquote><p>原文：<a href="https://www.cnblogs.com/rdchen/p/14025566.html">https://www.cnblogs.com/rdchen/p/14025566.html</a></p></blockquote><h3 id="1-vertical-align-属性"><a href="#1-vertical-align-属性" class="headerlink" title="1. vertical-align 属性"></a>1. vertical-align 属性</h3><p>设置行内元素的垂直对齐方式。</p><blockquote><p>​    vertical：竖的；垂直的。</p></blockquote><p><strong>属性值bottom和text-bottom区别</strong>：前者是根据盒子底部对齐，后者根据文本底部对齐。</p><p>​    在线演示：<a href="https://www.w3school.com.cn/tiy/t.asp?f=eg_csse_vertical-align">https://www.w3school.com.cn/tiy/t.asp?f=eg_csse_vertical-align</a></p><p><strong>解决图片底部默认空白缝隙现象：</strong></p><p><strong>原因</strong>：行内块元素会和文字的基线对齐。</p><p><strong>两种解决方法</strong>：</p><ol><li> 给图片加<span style="color: #ff0001">vertical-align: middle | top | bottom</span>  等。（建议）</li><li> 把图片转换为块级元素 <span style="color: #ff0001">display: block;</span></li></ol><h3 id="2-为什么-input-元素能用-width-属性？"><a href="#2-为什么-input-元素能用-width-属性？" class="headerlink" title="2.为什么 input 元素能用 width 属性？"></a>2.为什么 input 元素能用 width 属性？</h3><p>因为是<span style="color: #ff0001"><strong>可置换元素</strong></span>，<strong>拥有</strong><span style="color: #FFB700"><strong>内在尺寸</strong></span>。比如 <u>img，也属于可置换元素（Replaced element）</u>。</p><blockquote><p>一个解释：<a href="https://www.zhihu.com/question/20495297">https://www.zhihu.com/question/20495297</a></p><p>另一个解释：<a href="https://www.cnblogs.com/xiaofenguo/p/6086488.html">https://www.cnblogs.com/xiaofenguo/p/6086488.html</a></p><p>另外关于haslayout详解：<a href="https://www.cnblogs.com/xiaohuochai/p/4845314.html">https://www.cnblogs.com/xiaohuochai/p/4845314.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精灵图与字体图标</title>
      <link href="posts/4f464521/"/>
      <url>posts/4f464521/</url>
      
        <content type="html"><![CDATA[<h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1. 精灵图"></a>1. 精灵图</h2><p>盒子位置是固定的，移动的是图片，所以一般x,y的值都是负的（向左，向下）。</p><pre><code>background: url() no-repeat -x坐标 -y坐标;</code></pre><p>坐标数值在切片工具上看。</p><p><strong>缺点</strong>：</p><ol><li>图片文件还是比较大；</li><li>图片本身放大和缩小会失真；</li><li>一旦图片制作完毕想要更换比较麻烦。</li></ol><p><strong>字体图标iconfont可以解决以上问题。</strong></p><p><span style="color: #ff0001">字体图标</span>提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。</p><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2. 字体图标"></a>2. 字体图标</h2><p><strong>优点</strong>：</p><ol><li>轻量级：图标字体要比图像小，一旦字体加载了，图标就会马上渲染出来，减少了服务器请求。</li><li>灵活性：其本质是文字，可以随意改变颜色，加阴影，透明效果，旋转等。</li><li>兼容性：几乎支持所有浏览器。</li></ol><p><strong>注意：</strong>字体图标不能代替精灵技术，只是对工作中图标部分技术的提升和优化。</p><p><strong>使用：</strong>可以直接网上下载</p><ol><li>字体图标的下载；</li><li>字体图标的引入（引入到html页面）；</li><li>字体图标的追加（以后添加的新的小图标）。</li></ol><h3 id="2-1-推荐下载的网站：-免费"><a href="#2-1-推荐下载的网站：-免费" class="headerlink" title="2.1 推荐下载的网站：(免费)"></a>2.1 推荐下载的网站：(免费)</h3><ul><li><strong>IcoMoon字体库：<a href="http://icomoon.io/">http://icomoon.io</a></strong>    <ul><li>IcoMoon成立于2011年，内容种类多很全面，服务器在国外，可能打开比较慢。</li></ul></li><li><strong>阿里iconfont： <a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></strong><ul><li>（感觉这个更好用）</li><li>是阿里妈妈M2UX的一个字库，包含淘宝图标库和阿里妈妈图标库，可以使用AI制作图标上传生成。</li></ul></li></ul><h3 id="2-2-使用步骤："><a href="#2-2-使用步骤：" class="headerlink" title="2.2 使用步骤："></a>2.2 使用步骤：</h3><ol><li><p>把下载包里的fonts文件夹放入页面根目录下。</p></li><li><p>在CSS样式中全局声明字体。(打开style.css，复制到页面style标签里。)</p></li><li><p>html标签内部添加小图标。（去网站复制过来，是个很小的方框）</p><pre><code>// 可以写在span标签里&lt;body&gt;    &lt;span&gt;  &lt;/span&gt;&lt;/body&gt;</code></pre><p>​      </p></li><li><p>只有了span不行，要给span指定字体：(写在第二步的下面)</p><pre><code>// 例：&lt;style&gt;    span &#123;        font-family: &#39;icomoon&#39;;   /* 关键 */        font-size: 100px;         /* 可以自定义其它样式 */        color: pink;    &#125;&lt;/style&gt;</code></pre></li></ol><h3 id="2-3-字体文件格式："><a href="#2-3-字体文件格式：" class="headerlink" title="2.3 字体文件格式："></a>2.3 字体文件格式：</h3><p>不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。</p><ol><li>TureType(.ttf)格式 ，.ttf字体是Windows和Mac最常用的，支持这种字体的浏览器有IE9+，Firefox3.5+，Chrome4+，Safari3+，Opera10+，iOS mobile。</li><li>Web Open Font Format(.woff)格式woff字体，支持的浏览器有IE9+，Firefox3.5+，Chrome6+，Safari3.6+，Opera11.1+。</li><li>Embedded Open Type(.eot)格式.eot字体是IE专用字体，支持的有IE4+。</li><li>SVG(.svg)格式.svg字体是基于SVG字体渲染的一种格式，支持的浏览器有Chrome4+，Safari3.1+，Opera10+，iOS mobile Safari3.2+。</li></ol><h3 id="2-4-字体图标的追加："><a href="#2-4-字体图标的追加：" class="headerlink" title="2.4 字体图标的追加："></a>2.4 字体图标的追加：</h3><p>如果工作中原来的字体图标不够用了，需要添加心的字体图标到原来的字体文件中。</p><ol><li>把压缩包里的 <span style="color: #ff0001">selection.json</span> 重新上传，然后选中要添加的新图标，重新下载压缩包， 并替换原来的文件就行了。</li><li>在网站里的操作：左上角导入旧的selection.json，然后继续选，再正常操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式的继承</title>
      <link href="posts/dbc5d360/"/>
      <url>posts/dbc5d360/</url>
      
        <content type="html"><![CDATA[<h2 id="1-行高的继承"><a href="#1-行高的继承" class="headerlink" title="1.行高的继承"></a>1.行高的继承</h2><pre><code>font:12px/24px &#39;Microsoft YaHei&#39;;              </code></pre><p>指的是行高24px。</p><pre><code>font:12px/1.5 &#39;Microsoft YaHei&#39;;</code></pre><ul><li>指的是让子元素继承父元素1.5，而且是子元素字体大小*1，5。</li><li>行高可以有或没有单位。</li><li>例：</li></ul><img src="https://s2.loli.net/2022/10/05/kgiL2KZDFUzonf4.png" alt="image.png" style="zoom: 50%;" /><h2 id="2-权重的注意点"><a href="#2-权重的注意点" class="headerlink" title="2. 权重的注意点"></a>2. 权重的注意点</h2><h3 id="2-1-选择器权重："><a href="#2-1-选择器权重：" class="headerlink" title="2.1 选择器权重："></a>2.1 选择器权重：</h3>  <img src="https://s2.loli.net/2022/10/05/2VbphskzyWPR8an.png" alt="image.png" style="zoom: 67%;" /><h3 id="2-2-注意：继承的权重是0！！！！！！"><a href="#2-2-注意：继承的权重是0！！！！！！" class="headerlink" title="2.2 注意：继承的权重是0！！！！！！"></a>2.2 注意：继承的权重是0！！！！！！</h3><ul><li>所以当父元素设置了属性，其子元素也设置并且属性值冲突时的时候，子元素并不会继承，而是按照自己给的值显示。因为就算父元素权重再大，继承的权重也是0。</li><li>再比如最近写Vplus官网碰到的，给body设置颜色，但a便签依旧没变，这是因为继承过来为0，同时在浏览器中，a是有自己的默认样式的，所以自然影响不到。</li></ul><h3 id="2-3-权重会叠加，但不会出现进位。"><a href="#2-3-权重会叠加，但不会出现进位。" class="headerlink" title="2.3 权重会叠加，但不会出现进位。"></a>2.3 权重会叠加，但不会出现进位。</h3>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新建分支后与本地git建立联系</title>
      <link href="posts/c35f114b/"/>
      <url>posts/c35f114b/</url>
      
        <content type="html"><![CDATA[<ol><li>先查看所有分支：</li></ol><pre><code>git branch -a    </code></pre><p>​          </p><ol start="2"><li>获取所有分支，这时就可以看到新的分支出现了。</li></ol><pre><code>git fetch     </code></pre><p>​         </p><ol start="3"><li>新建&amp;切换分支：</li></ol><pre><code> git checkout -b XXX              </code></pre><ol start="4"><li>和远程分支建立联系：</li></ol><pre><code>git branch -u origin/XXX XXX</code></pre><p>​              </p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各类居中&amp;定位</title>
      <link href="posts/a561de53/"/>
      <url>posts/a561de53/</url>
      
        <content type="html"><![CDATA[<h2 id="图片的各类居中"><a href="#图片的各类居中" class="headerlink" title="图片的各类居中"></a>图片的各类居中</h2><ul><li>想让图片水平居中：<ul><li>让其父元素margin: 0 auto;    <u>有宽度的情况下</u>。</li><li>让其父元素text-align: center;</li></ul></li><li>如果是小图标，可以用背景图的方法：<ul><li>然后加background-position属性改变位置；</li><li>有文本的话再改一下间距，不然重叠一起了。</li></ul></li></ul><h2 id="定位的扩展"><a href="#定位的扩展" class="headerlink" title="定位的扩展"></a>定位的扩展</h2><h3 id="1-绝对定位的盒子居中"><a href="#1-绝对定位的盒子居中" class="headerlink" title="1. 绝对定位的盒子居中"></a>1. 绝对定位的盒子居中</h3><p>加了绝对定位的盒子不能通过<span style="color: #CC0000">margin: 0 auto;</span> 水平居中，但是可以通过以下计算方式实现。</p><pre><code>position: absolute;left: 50%;margin-left: 盒子宽度的一半;// 这是水平居中，垂直居中同理。</code></pre><p>​              </p><ul><li><strong>优点</strong>：屏幕变小，依旧居中。</li><li>固定定位也可以使用。</li></ul><h3 id="2-定位特殊特性"><a href="#2-定位特殊特性" class="headerlink" title="2. 定位特殊特性"></a>2. 定位特殊特性</h3><p>绝对定位和固定定位也和浮动类似。</p><p><strong>1.</strong> 行内元素添加绝对定位或者固定定位，可以直接设置高度和宽度。（行内元素本身是不能设置宽高的）</p><p><strong>2.</strong> 块级元素添加绝对或固定定位，如果不给宽度或高度，默认大小是内容的大小。</p><h3 id="3-脱标（标准流）的盒子不会触发外边距塌陷"><a href="#3-脱标（标准流）的盒子不会触发外边距塌陷" class="headerlink" title="3. 脱标（标准流）的盒子不会触发外边距塌陷"></a>3. 脱标（标准流）的盒子不会触发外边距塌陷</h3><p>浮动元素、绝对定位（固定定位）元素的都不会出发外边距合并的问题。</p><h3 id="4-绝对-固定定位会完全压住盒子"><a href="#4-绝对-固定定位会完全压住盒子" class="headerlink" title="4. 绝对/固定定位会完全压住盒子"></a>4. 绝对/固定定位会完全压住盒子</h3><ul><li>和浮动元素不同，只会压住下面标准流的盒子，不会压住下面标准流盒子里的图片和文字。<ul><li>浮动最初就是为了文字环绕效果，所以不会压住图片和文字。</li></ul></li><li>而绝对/固定定位会压住下面标准流的所有内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边框图片的使用</title>
      <link href="posts/b6e8d24f/"/>
      <url>posts/b6e8d24f/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>场景</strong>：盒子大小不一，但是边框样式相同时。不以背景图的形式。</li><li><strong>实现</strong>：使用css或js切图。把四个角切出去，中间部分可以铺排，拉伸或环绕。（九宫格）</li><li><strong>切的顺序</strong>：顺时针，上右下左。</li><li><strong>边框图片的语法</strong>：</li></ul><img src="https://s2.loli.net/2022/10/05/QnRwkyj5GAPLUtN.png" alt="image-20221005100553055" style="zoom: 67%;" /><p><strong>PS</strong>：</p><ul><li>具体四个角的宽度可以使用切图工具测量。</li><li>border-image-width不会挤压文字的大小。</li><li>border-image-repeat不同值的效果区别：</li></ul><img src="https://s2.loli.net/2022/10/05/Te4O9dhrw2iLfpl.png" alt="image-20221005100659125" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒体查询+rem实现元素动态变化</title>
      <link href="posts/5e16b5cd/"/>
      <url>posts/5e16b5cd/</url>
      
        <content type="html"><![CDATA[<h2 id="1-rem"><a href="#1-rem" class="headerlink" title="1. rem"></a>1. rem</h2><ul><li>em相对于父元素的字体大小来说的。</li><li>rem相对于HTML元素字体大小来说的。1rem等于html元素上字体设置的大小。</li><li>rem的优点就是可以通过修改HTML里的文字大小来改变页面中元素的大小 可以整体控制。</li></ul><h2 id="2-媒体查询"><a href="#2-媒体查询" class="headerlink" title="2. 媒体查询"></a>2. 媒体查询</h2><ul><li>Media Query是C3的新语法。</li><li>使用@media查询，可以针对不同的媒体类型定义不同的样式。</li><li>@media可以<strong>针对不同的屏幕尺寸设置不同的样式。</strong></li><li>当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</li></ul><h3 id="语法规范："><a href="#语法规范：" class="headerlink" title="语法规范："></a>语法规范：</h3><pre><code>@media mediatype and|not|only (media feature) &#123;    css code;&#125;</code></pre><ul><li>mediatype：媒体类型</li><li>关键字：and   not   only</li><li>media featrue：媒体特性，必须得有小括号包着。</li></ul><h3 id="1-mediatype查询类型：将不同的终端设备划分为不同的类型，称为媒体查询。"><a href="#1-mediatype查询类型：将不同的终端设备划分为不同的类型，称为媒体查询。" class="headerlink" title="1. mediatype查询类型：将不同的终端设备划分为不同的类型，称为媒体查询。"></a>1. mediatype查询类型：将不同的终端设备划分为不同的类型，称为媒体查询。</h3><table><thead><tr><th>值</th><th>解释说明</th></tr></thead><tbody><tr><td>all</td><td>用于所有设备</td></tr><tr><td>print</td><td>用于打印机和打印预览</td></tr><tr><td>screen</td><td>用于电脑屏幕，平板电脑，智能手机</td></tr></tbody></table><h3 id="2-关键字将媒体类型或多个媒体特性连接到一起，作为媒体查询的条件。"><a href="#2-关键字将媒体类型或多个媒体特性连接到一起，作为媒体查询的条件。" class="headerlink" title="2. 关键字将媒体类型或多个媒体特性连接到一起，作为媒体查询的条件。"></a>2. 关键字将媒体类型或多个媒体特性连接到一起，作为媒体查询的条件。</h3><ul><li>and：可以将多个媒体特性连一起，相当于“且”。用较多。</li><li>not：排除某个媒体类型，相当于“非”，可以省略。</li><li>only：指定某个特定的媒体类型，可以省略。</li></ul><h3 id="3-media-feature媒体特性：每种媒体类型都有不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。"><a href="#3-media-feature媒体特性：每种媒体类型都有不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。" class="headerlink" title="3. media feature媒体特性：每种媒体类型都有不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。"></a>3. media feature媒体特性：每种媒体类型都有不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。</h3><p>*<strong>注意</strong>：他们要有小括号包着。</p><table><thead><tr><th>值</th><th>解释说明</th></tr></thead><tbody><tr><td>width</td><td>定义输出设备中页面可见区域的宽度</td></tr><tr><td>min-width</td><td>定义输出设备中页面最小可见区域的宽度</td></tr><tr><td>max-width</td><td>定义输出设备中页面最大可见区域的宽度</td></tr></tbody></table><p>例：</p><pre><code>// 这句话的意思就是：在屏幕上，且最大宽度是800px像素。@media mediatype and (max-width: 800px) &#123;    body &#123;        background-color: pink;      /*当屏幕小于800px才会是粉色。*/    &#125;&#125;@media mediatype and (max-width: 500px) &#123;    body &#123;        background-color: blue;      /*当屏幕小于500px才会是蓝色。*/    &#125;&#125;</code></pre><p>在线效果演示： <a href="https://c.runoob.com/codedemo/5371/">https://c.runoob.com/codedemo/5371/</a></p><h2 id="3-媒体查询-rem实现元素动态变化"><a href="#3-媒体查询-rem实现元素动态变化" class="headerlink" title="3. 媒体查询+rem实现元素动态变化"></a>3. 媒体查询+rem实现元素动态变化</h2><ul><li>rem单位是跟着HTML的，有了rem页面元素可以设置不同大小尺寸。</li><li>媒体查询可以根据不同设备宽度来修改样式。</li><li>媒体查询+rem就可以实现不同设备宽度，实现页面元素大小的动态变化。</li></ul><h3 id="引入资源："><a href="#引入资源：" class="headerlink" title="引入资源："></a>引入资源：</h3><ul><li>当样式比较多，可以针对不同的媒体引入使用不同的样式表。</li><li>原理：直接在link中判断设备尺寸，然后引入不同的CSS文件。</li><li>建议：媒体查询最好是从小到大的顺序。</li></ul><p>例：当屏幕大于640px时，一行显示3个div；屏幕小于640px时，一行显示1个。</p><pre><code>  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css320&quot; media=&quot;screen and (min-width: 320px)&quot;&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;./css640&quot; media=&quot;screen and (max-width: 640px)&quot;&gt;</code></pre><p>​        </p><h2 id="4-rem的适配方案"><a href="#4-rem的适配方案" class="headerlink" title="4. rem的适配方案"></a>4. rem的适配方案</h2><h3 id="4-1-rem适配的技术选用（市场主流）"><a href="#4-1-rem适配的技术选用（市场主流）" class="headerlink" title="4.1 rem适配的技术选用（市场主流）"></a>4.1 rem适配的技术选用（市场主流）</h3><h4 id="技术方案一："><a href="#技术方案一：" class="headerlink" title="技术方案一："></a>技术方案一：</h4><ul><li><strong>less</strong></li><li><strong>媒体查询</strong></li><li><strong>rem</strong></li></ul><p><strong>关于动态设置html标签的font-size大小</strong>：</p><ol><li>假设设计稿是750px;</li><li>把整个屏幕划分成15等份（也可以是10份20份，标准不一样）</li><li>则每一份就作为html字体大小，这里就是50px；</li><li>那么在320px设备时，字体大小：320/15=21.33px。</li><li>这时会发现页面元素的大小除以不同的html字体大小的比例还是相同的。</li><li>比如以750为标准的设计稿。一个100*100的元素在750屏幕下，就是100/50，转换为rem就是2rem，比例是一比一。</li><li> 320屏幕下，html字体大小为21.33，则2rem=42.66px，此时宽高都是42.66px，宽高依旧一比一。</li><li>这时已经实现不同屏幕，元素等比例缩放。</li></ol><p><strong>步骤总结</strong>：</p><ol><li>选一套标准尺寸，750为准。</li><li>屏幕宽度/划分的份数得到html font-size的大小。</li><li>页面元素的rem值 = 页面元素值(px) / html font-size的大小。</li></ol><h4 id="技术方案二（推荐）："><a href="#技术方案二（推荐）：" class="headerlink" title="技术方案二（推荐）："></a>技术方案二（推荐）：</h4><ul><li><strong>flexible.js</strong>    （淘宝出的）</li><li><strong>rem</strong></li></ul><p><strong>总结</strong>: </p><ol><li>两种方案都存在；</li><li>方案二更简单。</li></ol><p><strong>PS</strong>:</p><p><img src="https://s2.loli.net/2022/10/05/l69pwZ1xkKJUXPf.png" alt="image-20221005105215181"></p><p>基本以750为准。</p><p><strong>代码示例</strong>：</p><p>css：</p><pre><code> @media screen and (min-width: 320px) &#123;    html &#123;      font-size: 21.33px;    &#125;  &#125;  @media screen and (min-width: 750px) &#123;    html &#123;      font-size: 50px;    &#125;  &#125;  div &#123;    width: 2rem;    height: 2rem;    background-color: #fff;  &#125;</code></pre><p>​         </p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局&amp;原理</title>
      <link href="posts/14cadbc/"/>
      <url>posts/14cadbc/</url>
      
        <content type="html"><![CDATA[<ul><li><p><span style="color: #0091ff"><strong>flex布局原理</strong></span>：</p><ul><li>flex是flexible Box的缩写，意为：弹性布局。用来给盒子模型提供最大的灵活性，任何一个盒子模型都可以使用。</li><li><strong>当给父盒子设置flex布局后，子元素的float，clear，vertical-align属性将失效。</strong></li><li>伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex布局。</li></ul></li><li><p> 子容器可以纵向排列也可以横向排列。</p></li><li><p>常见<span style="color: #0091ff"><strong>父元素属性</strong></span>：</p><ul><li><span style="color: #0091ff">flex-direction</span>：设置<span style="color: #E95200">主轴的方向</span>。<ul><li>默认的主轴是x轴，row；那么y轴就是侧轴。</li><li>row：从左到右；</li><li>row-reverse：从右到左；</li><li>column：从上到下；</li><li>column-reverse：从下到上。</li></ul></li></ul></li><li><ul><li><span style="color: #0091ff">justify-content</span>：设置<span style="color: #E95200">主轴</span>上的<span style="color: #E95200">子元素的排列方式</span>。<ul><li>flex-start：默认值：从头部开始。如果主轴是x轴，则从左往右。</li><li>flex-end：从尾部开始排列。</li><li>center：在主轴居中对齐（若主轴是x轴，则水平居中。）</li><li>space-around：平分剩余空间。</li><li>space-between：<strong>先两边贴边，再平分剩余空间。</strong></li></ul></li><li><span style="color: #0091ff">flex-wrap</span>：设置<span style="color: #E95200">子元素是否换行</span>。<img src="https://s2.loli.net/2022/10/05/siH9OghT4WzdA38.png" alt="image.png" style="zoom: 80%;" /></li></ul></li><li><ul><li>align-content：设置侧轴上的子元素的排列方式（多行）。</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap。</li></ul></li><li><p>元素是跟着主轴来排列的。</p></li><li><p>可以把主轴设置为y轴，那么x轴就成了侧轴。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除已推送的某个文件</title>
      <link href="posts/f85ba3a7/"/>
      <url>posts/f85ba3a7/</url>
      
        <content type="html"><![CDATA[<ol><li>查看当前分支：</li></ol><pre><code>git branch -a</code></pre><ol start="2"><li>切换分支：</li></ol><pre><code>git checkout 想切换的分支</code></pre><p>​     3.1 在本地仓库删除文件：</p><pre><code>git rm 文件名      </code></pre><ol start="3"><li>2 在本地仓库删除文件夹：</li></ol><pre><code>git rm -r 文件夹名   </code></pre><p>​           </p><ol start="4"><li>提交：</li></ol><pre><code>git commit -m &quot;xxx&quot;  </code></pre><p>​            </p><ol start="5"><li>推送：</li></ol><pre><code>git push origin 要推送的分支              </code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios拦截器</title>
      <link href="posts/9ccbc75b/"/>
      <url>posts/9ccbc75b/</url>
      
        <content type="html"><![CDATA[<h2 id="1-请求拦截器"><a href="#1-请求拦截器" class="headerlink" title="1. 请求拦截器"></a>1. 请求拦截器</h2><ul><li><strong>axios.interceptors.request.use();</strong></li><li><strong>axios请求拦截器</strong>：是发出请求前执行的一个<strong>回调函数</strong>。</li><li><strong>作用</strong>：对所有请求做统一处理：追加请求头、追加参数、界面loading提示。</li><li>所以可以写为以下方式：<ul><li>一般会在这里带个<strong>token</strong>。</li></ul></li></ul><pre><code>axios.interceptors.request.use((config) =&gt; &#123;    console.log(&#39;config&#39;, config);        // 判断身份信息：    if (store.getters.token) &#123;      // 让每个请求携带token--[&#39;X-Token&#39;]为自定义key：  请根据实际情况自行修改。      config.headers[&#39;X-Token&#39;] = getToken();     &#125;    // 经过拦截检查后，再把config还回来：    return config;&#125;);</code></pre><ul><li>请求发送出去之前，会经过请求拦截器。所有配置都交给了请求拦截器里的函数。<ul><li>把所有请求的信息打包成一个config对象。</li><li>检查过后会把config再给回来。</li></ul></li></ul><h2 id="2-响应拦截器"><a href="#2-响应拦截器" class="headerlink" title="2. 响应拦截器"></a>2. 响应拦截器</h2><ul><li><strong>axios.interceptors.response.use();</strong></li><li><strong>axios响应拦截器</strong>：得到响应后执行的回调函数。</li><li>请求成功：对成功的数据进行处理使用。</li><li>请求失败：对失败统一的操作。<ul><li><strong>什么时候调error</strong>：只要状态码不是2开头的，就都被认作失败。</li><li>需要返回一个失败的Promise实例（<strong>注意</strong>：除了Promise之外的返回，都被认定为成功，所以这里必须返回Promise）。</li><li>可以直接在这里做整体的状态码提示，这样不用后续所有响应中中些error，因为在拦截时就已经可以统一处理 &amp; 弹出提示了。</li></ul></li><li>PS：不同的是，响应拦截器的两个函数：response、 error。</li><li>在返回的所有数据中只有data是后续需要的，所以直接 return response.data </li></ul><pre><code>axios.interceptors.response.use(    // 成功回调：    (response) =&gt; &#123;        console.log(&#39;response成功的回调&#39;, response);        // 同样需要return：        return response.data;    &#125;,        // 失败回调：    (error) =&gt; &#123;      console.log(&#39;error失败的回调&#39;, error);       alert(error);      // 失败时需要返回Promise实例：      return Promise.reject(error);    &#125;);// 前几行写法的好处体现在直接可以这样写：    // btn.onclick = async() =&gt; &#123;    const result = await axios.get(&#39;请求地址&#39;);&#125;</code></pre><p><strong>另外</strong>：</p><ul><li>可以写多个拦截器。</li><li>有多个时：先指定的后执行。</li><li>可以参考PanJiaChen写的后台文档总结：<a href="https://juejin.cn/post/6844903476661583880">https://juejin.cn/post/6844903476661583880</a></li></ul><p>关联笔记：<br><a href="">权限控制</a></p>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Axios </tag>
            
            <tag> 更新中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git推送部分文件</title>
      <link href="posts/65f9be6e/"/>
      <url>posts/65f9be6e/</url>
      
        <content type="html"><![CDATA[<p><strong>步骤</strong>：</p><p><span style="color: #0091ff">1.</span> <span style="color: #FFB700">git status</span>                                查看未提交文件及其路径</p><p><span style="color: #0091ff">2.</span> <span style="color: #FFB700">git add 文件路径 </span>                   按需暂存文件，文件路径使用git status的结果</p><p><span style="color: #0091ff">3.</span> <span style="color: #FFB700">git stash -u -k</span>                         忽略未被暂存的文件，以免影响后续commit。</p><p><span style="color: #0091ff">4.</span> <span style="color: #FFB700">git commit -m “update”</span>          后续正常推送流程</p><p><span style="color: #0091ff">5.</span> <span style="color: #FFB700">git push</span></p><p><span style="color: #0091ff">6.</span> <span style="color: #FFB700">git stash pop</span>                恢复被忽略文件。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与Axios</title>
      <link href="posts/d0bdcfbc/"/>
      <url>posts/d0bdcfbc/</url>
      
        <content type="html"><![CDATA[<h2 id="1-请求方式与请求参数"><a href="#1-请求方式与请求参数" class="headerlink" title="1.请求方式与请求参数"></a>1.请求方式与请求参数</h2><h3 id="1-1-请求方式"><a href="#1-1-请求方式" class="headerlink" title="1.1 请求方式"></a>1.1 请求方式</h3><ol><li><strong>GET</strong>：从服务器端读取数据           查（R）</li><li><strong>POST</strong>：向服务器端添加新数据            增（C）</li><li><strong>PUT</strong>：更新服务器端已存在的数据        改（U）</li><li><strong>DELETE</strong>：删除服务器端的数据        删（D）</li></ol><p>略…</p><h3 id="1-2-请求参数："><a href="#1-2-请求参数：" class="headerlink" title="1.2 请求参数："></a>1.2 请求参数：</h3><h4 id="1-2-1-query参数（查询字符串参数）"><a href="#1-2-1-query参数（查询字符串参数）" class="headerlink" title="1.2.1 query参数（查询字符串参数）"></a>1.2.1 query参数（查询字符串参数）</h4><ul><li>参数包含在请求地址中，格式为 :/xxx?name=xxx&amp;age=18 </li><li><strong>敏感数据不要用query参数</strong>，因为是地址的组成部分，比较危险。</li><li>备注：query参数又称<strong>查询字符串参数</strong>，编码方式为urlencoded。</li></ul><h4 id="1-2-2-params参数"><a href="#1-2-2-params参数" class="headerlink" title="1.2.2 params参数"></a>1.2.2 params参数</h4><ul><li>参数包含在请求地址中，格式为 <a href="http://localhost:3000/add_person/tom/188">http://localhost:3000/add_person/tom/188</a></li><li>敏感数据也不要params参数，原因同上。</li></ul><h4 id="1-2-3-请求体参数"><a href="#1-2-3-请求体参数" class="headerlink" title="1.2.3 请求体参数"></a>1.2.3 请求体参数</h4><ul><li>参数包含在请求体中，可以通过浏览器开发工具查看。</li></ul><h5 id="1-2-3-1-请求体参数常用的两种格式："><a href="#1-2-3-1-请求体参数常用的两种格式：" class="headerlink" title="1.2.3.1 请求体参数常用的两种格式："></a>1.2.3.1 请求体参数常用的两种格式：</h5><ul><li>格式1：<strong>urlencoded格式</strong>：<ul><li><strong>例如</strong>： name=tom&amp;age=18  </li><li>对应请求头： Content-Type: application/x-www-form-urlencoded</li></ul></li><li>格式2：<strong>json格式</strong>：<ul><li><strong>例如</strong>： { “name”: “tom”, “age”, 12 } </li><li>对应请求头： Content-Type: application/json</li></ul></li><li><strong>不同的格式必须要添加对应的请求头</strong>。</li></ul><p><strong>特别注意</strong>：</p><ol><li>GET请求不能携带请求体参数，因为GET请求没有请求体。</li><li>理论上一次请求可以随意使用上述3种类型参数的任何一种，甚至一次请求的3个参数可以用3种形式携带，但一般不会这样。</li><li>有一些约定俗成的<strong>规则</strong>：<ol><li>例如form表单发送post请求时：自动使用请求体参数，用urlencoded编码。</li><li>例如jQuery发送ajax-post请求时：自动使用请求体参数，用urlencoded编码（因为这种编码方式转换比较简单）。</li></ol></li></ol><hr><h2 id="2-API分类"><a href="#2-API分类" class="headerlink" title="2. API分类"></a>2. API分类</h2><h3 id="2-1-REST-API-restful-风格的API"><a href="#2-1-REST-API-restful-风格的API" class="headerlink" title="2.1 REST API(restful 风格的API)"></a>2.1 REST API(restful 风格的API)</h3><ol><li>用请求方式来决定是CRUD中的哪个操作。</li><li>同一个请求路径可以进行多个操作。</li><li>请求方式会用到GET/POST/PUT/DELETE</li></ol><h3 id="2-2-非REST-API-restless-风格的API"><a href="#2-2-非REST-API-restless-风格的API" class="headerlink" title="2.2 非REST API(restless 风格的API)"></a><strong>2.2 非REST API(restless 风格的API)</strong></h3><ol><li>请求方式不决定请求的CRUD操作</li><li>一个请求路径只对应一个操作</li><li>一般只有GET/POST</li></ol><hr><h2 id="3-使用json-server的使用搭建REST-API"><a href="#3-使用json-server的使用搭建REST-API" class="headerlink" title="3. 使用json-server的使用搭建REST API"></a>3. 使用json-server的使用搭建REST API</h2><ul><li>json-server：用来快速搭建<strong>REST API</strong>的工具包。</li><li>可以用来模拟数据。</li><li>注意：接收不到query参数。视频讲解：<a href="https://www.bilibili.com/video/BV1Ga41177Tn?p=5&amp;t=1181.9">https://www.bilibili.com/video/BV1Ga41177Tn?p=5&amp;t=1181.9</a></li></ul><h3 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h3><p>GitHub：<a href="https://github.com/typicode/json-server">https://github.com/typicode/json-server</a></p><p><strong>步骤：</strong></p><ul><li><strong>全局安装</strong>：npm i json-server -g</li><li><strong>启动</strong>：<ul><li> json-server xxx.json  ， 其中xxx代表任意名称。这行命令会<strong>自动创建</strong>json文件，该文件代表新建的数据库json文件。</li><li>完整写法： json-server –watch xx.json  </li><li>可以<strong>在任意文件夹执行命令</strong>。</li><li>已解决跨域。</li></ul></li></ul><hr><h2 id="4-postman接口测试工具"><a href="#4-postman接口测试工具" class="headerlink" title="4. postman接口测试工具"></a>4. postman接口测试工具</h2><p>下载：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p><p>其余略…</p><hr><h2 id="5-http请求与ajax请求"><a href="#5-http请求与ajax请求" class="headerlink" title="5. http请求与ajax请求"></a>5. http请求与ajax请求</h2><ol><li>ajax请求是<strong>一种特别的http请求</strong>。</li><li>对服务器端来说，没有任何区别，区别在浏览器端。</li><li>浏览器端发请求：只有XHR或fetch发出的才是Ajax请求，其他所有的都是非ajax请求。</li><li>浏览器端接收到响应：<ol><li><strong>一般请求</strong>：浏览器一般会直接显示响应体数据，也就是常说的自动刷新/跳转页面。</li><li><strong>ajax请求</strong>：浏览器不会对界面进行任何更新操作（页面无刷新），只是调用监视的回调函数并传入响应相关数据。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Gitee搭建博客踩坑总结</title>
      <link href="posts/hexo-gitee/"/>
      <url>posts/hexo-gitee/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建过程如下："><a href="#一、搭建过程如下：" class="headerlink" title="一、搭建过程如下："></a>一、搭建过程如下：</h2><h3 id="阶段1：-本地搭建"><a href="#阶段1：-本地搭建" class="headerlink" title="阶段1： 本地搭建"></a>阶段1： 本地搭建</h3><p>1.下载安装node.js </p><p>2.下载安装git </p><p>3.使用命令行(win+r,输入cmd)下载淘宝镜像：    </p><pre><code>npm install -g cnpm --registry=https://.npm.taobao.org</code></pre><p>4.使用命令行下载hexo :    （git bash和cmd都可以）</p><pre><code>npm install -g hexo-cli</code></pre><p>5.建立空文件夹 ：</p><pre><code>md blog</code></pre><p>6.进入建好的文件夹：</p><pre><code>cd blog </code></pre><p>7.启动服务：</p><pre><code>hexo s</code></pre><p>8.停一下：ctrl c再按y </p><p>9.新建文章： hexo n “标题” </p><p>10.看这时在哪个目录下，然后cd进入 </p><p>11.确认新建的文章是否成功：dir </p><p>12.给博文加内容：这里我用typora写。用vim的方法是：vim 标题.md。然后保存退出：先按esc，再输入    wq(w保存，q退出)。 </p><p>13.文件退两层： cd../.. (到了blog目录) </p><p>14.win下写博文从文件夹用typora打开文章，然后保存刷新页面，不用重新启动hexo。 </p><p>15.清理 :</p><pre><code>hexo clean </code></pre><p>16.生成:</p><pre><code>hexo g </code></pre><h3 id="阶段2：部署到Gitee"><a href="#阶段2：部署到Gitee" class="headerlink" title="阶段2：部署到Gitee"></a>阶段2：部署到Gitee</h3><p>1.装一个git的部署插件cnpm install –save hexo-deployer-git(win用npm install) </p><p>2.注册登录Gitee账号，新建仓库，设置仓库名（一定要和用户名一样，否则可能会有无法预料结果）。</p><p>3.设置根目录的_config.yml文件，用typore打开，拉到最底下设置deploy的值：</p><pre><code>deploy:  type: git  repo: 你的仓库地址（去Gitee复制）  branch: master</code></pre><p>注意冒号和值之间一定要有空格，type后面有单引号的话可以直接删了。</p><p>4.这样就随时可以用电脑/手机访问了，地址可以直接复制仓库名访问。接下来就是换主题和自定义主题为满意的样式，我用的是Matery，网上有很多，Hexo官网也有。</p><h2 id="二、需要注意的地方："><a href="#二、需要注意的地方：" class="headerlink" title="二、需要注意的地方："></a>二、需要注意的地方：</h2><p>1.主题名别忘了在_config.ym中更改，这种配置文件一定要严格按照格式！否则一言不合就报错！</p><p>2.下载的主题在解压缩后不要更改</p><p>3.注意有没有漏下的插件，检查所有插件及版本号的指令：</p><pre><code>npm list</code></pre><p>4.卸载某个插件的指令：</p><pre><code>npm uninstall 插件名@版本号</code></pre><p>5.怕出错想找回改动前的文件：可以提前复制粘贴一份在桌面，方便随时对照/改动。</p><p>6.Typora可以选择是否显示目录，设置toc: true，如果某篇文章不显示目录了，可以查看文章最上方的设置是否正确。</p><h2 id="三、踩坑-amp-解决："><a href="#三、踩坑-amp-解决：" class="headerlink" title="三、踩坑&amp;解决："></a>三、踩坑&amp;解决：</h2><p>1.报错：FATAL err:[Error: EBUSY: resource busy or locked, rmdir ‘C:\User...]</p><p>网上搜索了一下，关闭软件重启电脑，果然有奇效。</p><p>2.我的页面刚开始一直404，我百思不得其解，大佬们的各路招数试了个遍，然而它的纹丝不动仿佛在告诉我不要浪费时间。</p><p>最后！我在Gitee Page页面看到了一个更新的按钮，我一脸疑惑的点了一下。接着，大不一样，顿时体会到柳暗花明又一村天无绝人之路。没错，我想了一下，大概是因为我的git一键部署功能出错了。总之，现在是记了，    每次终端部署完之后，在这个页面再点更新就好了。</p><p>3.我发现我的主题，在设置成功之后无法在网站中更新，在尝试了很多方法之后，我发现把根目录的config yml文件的repo由SSH的地址变换为HTTPS的位置，这样就可以成功解决，不过还有一个问题就是这样的话，每次重新部署都要输入用户名和密码。</p><p>然后我就尝试在网上搜集一些办法，但是没有什么用。这时我就想，如果我把repo. 再换成SSH的地址。这样换了之后我看会有什么变化变化，结果发现。重新部署之后是可以的，页面刷新也没有完全问题。</p><p>4.我在所选的主题下找到了read me，开始按照里面的提示来配置我的主题文件夹。其中有一个是配置评论的表情的。我在配置过后发现你发现在本地运行的时候都会报错，后来在网上查找，提示说检查Jason文件格式，一般情况下，他都是一对花括号是首尾。后来我把最上面那行Json删了也把最外层的中括号删了。结果发现依旧报    错，接着我又尝试把中括号加上，运行一下再也没有红色字段，就Json这四个字母导致了运行报错。</p><p>​    5.修改根目录配置文件时，注意缩进，有报错的情况！</p><p>​    6.卸载了<a href="mailto:&#104;&#x69;&#x67;&#104;&#x6c;&#x69;&#103;&#x68;&#116;&#46;&#x6a;&#x73;&#x40;&#49;&#x30;&#x2e;&#x37;&#46;&#x31;">&#104;&#x69;&#x67;&#104;&#x6c;&#x69;&#103;&#x68;&#116;&#46;&#x6a;&#x73;&#x40;&#49;&#x30;&#x2e;&#x37;&#46;&#x31;</a>：npm uninstall <a href="mailto:&#x68;&#101;&#120;&#111;&#45;&#x71;&#105;&#110;&#x69;&#x75;&#x2d;&#115;&#x79;&#x6e;&#x63;&#64;&#x31;&#46;&#x34;&#x2e;&#x37;">&#x68;&#101;&#120;&#111;&#45;&#x71;&#105;&#110;&#x69;&#x75;&#x2d;&#115;&#x79;&#x6e;&#x63;&#64;&#x31;&#46;&#x34;&#x2e;&#x37;</a> （相关的配置我暂时未删，试了一下已    经好了）</p><p>​    7.设置文章永久链接，下载指令：</p><pre><code>npm install hexo-abbrlink --save</code></pre><p>​    设置修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）:</p><pre><code>#设置永久链接permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlinkabbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: dec     #进制： dec(default) and hex</code></pre><p>​    8.npm resource busy or locked报错解决：</p><pre><code>npm cache verify</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位机制</title>
      <link href="posts/5d7648ee/"/>
      <url>posts/5d7648ee/</url>
      
        <content type="html"><![CDATA[<h2 id="一-文档流flow"><a href="#一-文档流flow" class="headerlink" title="一.文档流flow"></a>一.文档流flow</h2><ul><li><p>从上到下，从左到右。</p></li><li><h3 id="1-block元素："><a href="#1-block元素：" class="headerlink" title="1.block元素："></a>1.block元素：</h3><ul><li><p>元素独占一行；</p></li><li><p>元素的height、width、margin、padding都可以设置。</p></li><li><p>常见的block元素：div、p、h1~h6、ol、ul、table、form</p></li><li><p>将元素显示为block元素：<strong>display:block;</strong></p><p>例：</p></li></ul><pre><code>a&#123;    display:block;&#125;</code></pre><p>inline元素a转为block，从而使a元素具有块状元素的特点。</p></li><li><h3 id="2-inline元素："><a href="#2-inline元素：" class="headerlink" title="2.inline元素："></a>2.inline元素：</h3><ul><li>不用单独占用一行；</li><li>height、width不可设置；</li><li>width就是它已包含的文字或图片的宽度，不可改变。</li><li>常见inline元素：span、a</li><li>将元素显示为inline元素：<strong>display:inline;</strong></li><li>inline元素之间有个间距的问题，解决方法：转换为block。</li></ul></li><li><h3 id="3-inline-block元素："><a href="#3-inline-block元素：" class="headerlink" title="3.inline-block元素："></a>3.inline-block元素：</h3><ul><li>同时具备inline和block的特点：可平行的block；</li><li>不单独占用一行；</li><li>元素的height、width、margin、padding都可以设置；</li><li>常见的inline-block元素：img</li><li>显示为inline-block元素：<strong>display:inline-block；</strong></li></ul></li><li><h3 id="4-相互转换："><a href="#4-相互转换：" class="headerlink" title="4.相互转换："></a>4.相互转换：</h3><ul><li>display:none;                 元素不会被显示（<strong>不占原位置</strong>）</li><li>display:block                  显示为block元素</li><li>display:inline                  显示为inline元素</li><li>display:inline-block        显示为inline-block元素</li></ul></li></ul><h2 id="二-浮动定位float"><a href="#二-浮动定位float" class="headerlink" title="二.浮动定位float"></a>二.浮动定位float</h2><ul><li><p>float属性：left、right、none（不浮动）；</p></li><li><p>clear属性（清除）：left、right、both。</p></br></li></ul><p>*<em>当有3列都要水平时，将3列都设为左浮动即可。（宽度够用时）</em></p><h3 id="float属性的特点："><a href="#float属性的特点：" class="headerlink" title="float属性的特点："></a>float属性的特点：</h3><ul><li><p>当其中一个盒子移动时，<strong>其原有位置丢失，并被其他元素占用位置。</strong></p></br></li></ul><p>*<em>3个盒子并行，当高度不够时：</em></p><ul><li>第一种情况：box3下降</li><li>第二种情况：box1较高，box3向左下降时被卡住。</li></ul><h3 id="clear属性："><a href="#clear属性：" class="headerlink" title="clear属性："></a>clear属性：</h3><ul><li><p>单方向清除浮动的发法：比如将一行的box1和box2变为上下的列关系</p><ul><li><p>使box1位置不变，将box2设为：</p></li><li><pre><code>clear:right; </code></pre><p>  意思是清除右侧浮动，使其占据右侧。</p></br></li></ul></li><li><p>双侧清除：</p><pre><code>clear:right;</code></pre><p>意思是清楚两侧的浮动，使设置的元素单独占一行。</p></li></ul><h2 id="三-层定位layer"><a href="#三-层定位layer" class="headerlink" title="三.层定位layer"></a>三.层定位layer</h2><h3 id="position属性：（相对于谁定位）"><a href="#position属性：（相对于谁定位）" class="headerlink" title="position属性：（相对于谁定位）"></a>position属性：（相对于谁定位）</h3><ul><li><p>static：      默认值（没有定位，相当于不是层定位，定位的属性失效）</p></li><li><p>fixed：      固定定位（相对于浏览器窗口定位）</p></li><li><p>relative： 相对定位（相对于原来自己的位置定位），元素会脱离文档流，但在文档流中的<strong>位置还在，不会被占据。</strong></p></li><li><p>absolute：绝对定位（相对于static以外的第一个父元素定位），元素脱离文档流，在文档流中的<strong>原位置不再存在，会被占据</strong>。</p></br></li></ul><p>概述：像图像软件中的图层一样可以对每个layer进行精准定位操作。</p></br><p><em>当子元素相对于父元素定位，且父元素也相对于其父元素定位。可将最外层用相对定位，<strong>里面两层用绝对定位。</strong></em></p></br><p>*<em>特殊情况;：</em></p><p><em>对于absolute定位的层，若其父层都未定义absolute或relative，则将会<strong>相对body进行定位</strong>。</em></p></br><p><strong>relative+absolute：</strong>（父相子绝）</p><ul><li>父元素box1：position: relative;</li><li>子元素box2：position: absolute;</li><li>子元素box2：left、right、top、bottom相对于父元素进行偏移定位。</li></ul><p><strong>好处</strong>：当父元素box1移动时，子元素会相对于父元素的位置进行定位，可以一起移动。</p><h3 id="定位的属性："><a href="#定位的属性：" class="headerlink" title="定位的属性："></a>定位的属性：</h3><ul><li>left属性</li><li>right属性</li><li>top属性</li><li>bottom属性</li><li>z-index属性  （值大在上面）</li></ul><p>*<em>当想把图片设为背景，可将z-index设为负数，以留在最底层。</em></p></br></br>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS添加方法&amp;优先级&amp;CSS选择器</title>
      <link href="posts/6a1f6cdf/"/>
      <url>posts/6a1f6cdf/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS添加方法："><a href="#一、CSS添加方法：" class="headerlink" title="一、CSS添加方法："></a>一、CSS添加方法：</h2><h3 id="1-行内样式："><a href="#1-行内样式：" class="headerlink" title="1.行内样式："></a>1.行内样式：</h3><p>表示当前样式作为CSS样式被添加到标签上（只对这个标签起作用）。</p><h3 id="2-内嵌样式："><a href="#2-内嵌样式：" class="headerlink" title="2.内嵌样式："></a>2.内嵌样式：</h3><p>将CSS代码内嵌到当前页面的head标签部分（只对当前页面起作用）。</p><p>首先body部分不再包含样式，将样式放在style标签中表示，和head标签为嵌套关系。</p><h3 id="3-链接样式（单独文件）："><a href="#3-链接样式（单独文件）：" class="headerlink" title="3.链接样式（单独文件）："></a>3.链接样式（单独文件）：</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;</code></pre><p>stylesheet为样式表文件；</p><p>href后面的是相对路径。</p><h2 id="二、样式优先级："><a href="#二、样式优先级：" class="headerlink" title="二、样式优先级："></a>二、样式优先级：</h2><ul><li><input disabled="" type="checkbox"> 多重样式可重叠，可覆盖。</li><li><input disabled="" type="checkbox"> 样式的优先级按”就近原则“。</li><li><input disabled="" type="checkbox"> 行内样式&gt;内嵌样式&gt;链接样式&gt;浏览器默认样式</li></ul><h2 id="三、CSS选择器："><a href="#三、CSS选择器：" class="headerlink" title="三、CSS选择器："></a>三、CSS选择器：</h2><h3 id="1-标签选择器："><a href="#1-标签选择器：" class="headerlink" title="1.标签选择器："></a>1.标签选择器：</h3><p>与标签同名，紧跟着一对花括号，例如：</p><pre><code>body&#123;    border-color: #aaaaff;&#125;</code></pre><h3 id="2-类选择器："><a href="#2-类选择器：" class="headerlink" title="2.类选择器："></a>2.类选择器：</h3><p>以.开头，例:</p><pre><code>.one&#123;    font-size:18px;&#125;</code></pre><h3 id="3-ID选择器："><a href="#3-ID选择器：" class="headerlink" title="3.ID选择器："></a>3.ID选择器：</h3><p>以#开头，例:</p><pre><code>#two&#123;    font-size:18px;&#125;</code></pre><p>2和3的区别：</p><ul><li><input disabled="" type="checkbox"> ID是唯一的，只能在HTML被引用一次。</li><li><input disabled="" type="checkbox"> 类选择器可以被多次引用，应用中多个页面元素上。</li><li><input disabled="" type="checkbox"> *因此：ID选择器用来布局，class选择器用在样式。</li></ul><h3 id="4-后代选择器："><a href="#4-后代选择器：" class="headerlink" title="4.后代选择器："></a>4.后代选择器：</h3><pre><code>p span&#123;    clor:red;            //作用于p标签内部的span标签&#125;</code></pre><p>两个标签之间使用空格空开。</p><h3 id="5-并集选择器："><a href="#5-并集选择器：" class="headerlink" title="5.并集选择器："></a>5.并集选择器：</h3><pre><code>p,span&#123;    clor:red;            //同时作用于两个标签&#125;</code></pre><p>连接符为,会使两者都变为红色。</p><h3 id="6-伪类选择器-Pseudo-classes-："><a href="#6-伪类选择器-Pseudo-classes-：" class="headerlink" title="6.伪类选择器(Pseudo-classes)："></a>6.伪类选择器(Pseudo-classes)：</h3><p>语法：</p><pre><code>selector:pseudo-class &#123;property:value;&#125;</code></pre><p>例如：</p><pre><code>a:link            //普通的，未被访问的链接a:visited         //用户已经访问过的链接a:hover         //鼠标悬停于链接上的样式a:active         //链接被点击时的样式</code></pre><p>​    注意：必须严格遵守以下顺序。</p><p>a:hover            <strong>必须在a:link和a:visited之后</strong></p><p>a:active             <strong>必须在a:hover之后</strong></p><p><strong>口诀：</strong></p><p><strong>l</strong>o<strong>v</strong>e&amp;<strong>ha</strong>te</p><h3 id="7-混合："><a href="#7-混合：" class="headerlink" title="7.混合："></a>7.混合：</h3><ul><li>多个class选择器混用，用空格分开。</li></ul><pre><code>&lt;div class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id和class混用：</li></ul><pre><code>&lt;div id=&quot;my&quot; class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id选择器不可以多个同时使用。</li></ul></br></br></br>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像格式和路径</title>
      <link href="posts/66ad3928/"/>
      <url>posts/66ad3928/</url>
      
        <content type="html"><![CDATA[</br><h2 id="一、图像格式："><a href="#一、图像格式：" class="headerlink" title="一、图像格式："></a>一、图像格式：</h2></br><p>JPG：有损压缩，图片色彩丰富。（快，不失真）</p><p>GIF：简单动画，背景透明。</p><p>PNG：无损压缩，透明，交错，动画（支持有/无损，比GIF色彩丰富）。</p></br><p>透明：可以给定图片一种颜色，使其不被显示而成为透明。</p><p>交错：在显示图片的过程中可以从概貌逐渐变化为全貌，看上去也就是清晰度从低到高。</p><h2 id="二、插入图片img："><a href="#二、插入图片img：" class="headerlink" title="二、插入图片img："></a>二、插入图片img：</h2></br><p>src属性：组成为 路径+文件名（不仅要带有图片的名字及后缀，还要有图片的完整路径）</p><p>alt属性：当图片没有被找到时，显示的替代文本。</p></br><h2 id="三、绝对路径-amp-相对路径："><a href="#三、绝对路径-amp-相对路径：" class="headerlink" title="三、绝对路径&amp;相对路径："></a>三、绝对路径&amp;相对路径：</h2></br><p>绝对路径：以根目录为基准。</p><p>相对路径：以该文件所在位置为基准。</p><ul><li><input disabled="" type="checkbox"> ..表示上一级</li><li><input disabled="" type="checkbox"> /表示下一级</li></ul></br></br></br></br></br>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础回顾 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符，编码，乱码问题</title>
      <link href="posts/1ce900cc/"/>
      <url>posts/1ce900cc/</url>
      
        <content type="html"><![CDATA[</br></br><p>1.字符：文字，符号 空符字符：&amp;nbsp</p></br><p>2.字符集：字符的集合</p></br><p>3.编码：将字符和二进制码对应起来</p><p>ASCⅡ：数字、英文字母、符号进行编码</p><p>GB2313: 简体中文</p><p>Unicode：所有语言</p><p>UTF-8：所有语言，占用空间更小</p></br><h6 id="4-乱码问题："><a href="#4-乱码问题：" class="headerlink" title="4.乱码问题："></a>4.乱码问题：</h6><ul><li><input disabled="" type="checkbox"> 源文件保存时的编码</li><li><input disabled="" type="checkbox"> 源文件标签里的声明： meta charset = “编码模式”</li></ul><p>以上两个不一致，就会出现乱码。</p></br></br></br></br></br></br>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础回顾 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
