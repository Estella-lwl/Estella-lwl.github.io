<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3变更总结</title>
      <link href="posts/97e721dd/"/>
      <url>posts/97e721dd/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ref &amp; reactive &amp; 响应式差异</title>
      <link href="posts/9badfa3f/"/>
      <url>posts/9badfa3f/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h2><ul><li><p><strong>作用</strong>：定义一个响应式的数据。</p></li><li><p><strong>语法</strong>：const xxx = ref(initValue)  </p></li><li><ul><li>创建一个包含响应式数据的引用对象（reference对象）。</li><li>模板中使用引用对象不用后面加.value，而setup中使用该值时需要加.value。</li></ul></li><li><p><strong>接收的数据</strong>：</p></li><li><ul><li>可以是：基本类型、对象类型。</li><li>ref处理 <strong>基本类型： 响应式</strong>依旧使用是<strong>defineProperty</strong> ，以set &amp; get数据劫持的方式。</li><li>而处理 <strong>对象类型</strong>时使用<strong>proxy</strong>实现的（proxy是封装在reactive函数中的，ref内部会自动通过reactive转为代理对象）。</li><li>补充：使用ref数据要 .value 是因为Object.defineProperty本身无法作用于基本数据类型，所以通过对象做了一层转化。</li></ul></li><li><p><strong>使用ref获取节点</strong>：</p></li><li><p><strong>注意</strong>：如果要在setup中拿到DOM元素，声明的变量名必须与元素中写的ref<strong>一致</strong>。</p></li></ul><p><template>  <div id="countBox" ref="countupRef">    <span class="countSpan"></span>  </div> </template></p><ul><li><p>在<strong>onMounted</strong>中可以拿到节点：</p><pre><code>  setup() &#123;      // 这里的变量名countupRef必须与ref写的一样：    const countupRef = ref(null);    console.log(&quot;ref&quot;, countupRef);    onMounted(() =&gt; &#123;      // 拿到ref节点      console.log(countupRef);    &#125;);    return &#123;      countupRef    &#125;;  &#125;,</code></pre></li></ul><h2 id="2-reactive："><a href="#2-reactive：" class="headerlink" title="2. reactive："></a><strong>2. reactive：</strong></h2><ul><li><p><strong>作用</strong>：定义一个<strong>对象/数组类型</strong>的响应式数据（基本类型别用，要用ref函数）。</p></li><li><p><strong>语法</strong>：const 代理对象 = reactive(源对象);  接收一个对象或数组，返回一个<strong>代理对象</strong>（Proxy的实例对象，简称proxy对象）。</p></li><li><ul><li>绿色框里的就是源对象，粉色的是代理对象：</li></ul></li></ul><p> <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035136457-16600746990031.png" alt="image-20220810035136457"></p><ul><li>reactive定义的响应式数据是”深层次的“。</li><li>内部基于ES6的Proxy实现，通过代理对象操作源对象内部的数据。</li></ul><h2 id="3-ref对比reactive总结"><a href="#3-ref对比reactive总结" class="headerlink" title="3. ref对比reactive总结"></a><strong>3. ref对比reactive总结</strong></h2><ul><li><p><strong>从定义数据据角度对比</strong>：</p></li><li><ul><li>ref定义：基本类型数据。</li><li>reactive定义：对象/数组类型数据。</li><li>注意：ref也可以定义对象/数组类型数据，它内部会自动通过reactive转为代理对象。</li></ul></li><li><p><strong>从原理角度对比</strong>：</p></li><li><ul><li>ref：通过Object.defineProperty()的get和set实现响应式（数据劫持）。</li><li>reactive：通过使用Proxy实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</li></ul></li><li><p><strong>从使用角度对比</strong>：</p></li><li><ul><li>ref定义的数据：操作数据需要.value，读取数据时模板会直接读取不用.value。</li><li>reactive定义的数据：操作数据与读取数据均不需要.value。</li></ul></li></ul><h2 id="4-响应式原理对比"><a href="#4-响应式原理对比" class="headerlink" title="4. 响应式原理对比"></a><strong>4. 响应式原理对比</strong></h2><h2 id="4-1-Vue2的响应式"><a href="#4-1-Vue2的响应式" class="headerlink" title="4.1 Vue2的响应式"></a><strong>4.1 Vue2的响应式</strong></h2><ul><li><p><strong>实现原理</strong>：</p></li><li><ul><li><p><strong>对象类型</strong>：通过<strong>Object.defineProperty()</strong> 对属性的读取、修改进行拦截（<strong>数据劫持</strong>）。</p></li><li><p><strong>数组类型</strong>：通过<strong>重写更新数组的方法实现拦截</strong>。</p></li><li><ul><li><p>比如：调用push方法，其实调用的是vue2二次封装后的push。</p></li><li><p>这个push里做了两件事：</p></li><li><ul><li>\1. 帮助正常调用push方法。</li><li>\2. 帮助更新界面。</li></ul></li></ul></li></ul></li><li><p><strong>存在的问题</strong>：</p></li><li><ul><li>新增属性 or 删除属性，<strong>界面不会自动更新</strong>。</li><li>直接通过下标修改数组，界面也不会自动更新。</li></ul></li></ul><pre><code>// 修改对象：//     添加属性：this.$set(target, &#39;name&#39;, value);Vue.set(target, &#39;name&#39;, value);// 删除属性：this.$delete(target, &#39;name&#39;, value);Vue.delete(target, &#39;name&#39;, value);// 修改数组：this.xxx.splice(0, 1, &#39;&#39;);</code></pre><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035246493-16600747685122.png" alt="image-20220810035246493"></p><ul><li><p><strong>Object.defineProperty</strong>:</p></li><li><ul><li>读取和修改有<strong>get</strong>和<strong>set</strong>方法，但是添加和删除是捕获不到的。</li><li><strong>configurable</strong>配置项：能否使用delete删除属性，默认值为false。</li></ul></li></ul><h3 id="4-2-Vue3的响应式"><a href="#4-2-Vue3的响应式" class="headerlink" title="4.2 Vue3的响应式"></a><strong>4.2 Vue3的响应式</strong></h3><h4 id="4-2-1实现原理："><a href="#4-2-1实现原理：" class="headerlink" title="4.2.1实现原理："></a><strong>4.2.1实现原理：</strong></h4><ul><li><p>通过<strong>Proxy</strong>（代理）：拦截对象中任意属性的变化，<strong>包括</strong>：属性的读写 、添加、删除 等。</p></li><li><p>通过<strong>Reflect</strong>（反射）：对源对象（被代理）的属性进行操作。</p></li><li><p>MDN文档中描述的<strong>Proxy</strong>与<strong>Reflect</strong>：</p></li><li><ul><li><strong>Proxy</strong>：window上内置的，接收<strong>两个参数</strong>（必填）：<strong>1</strong>.target(代理对谁的操作)；<strong>2.</strong> 对象，至少要有个空对象占位。</li><li><strong>Reflect</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul></li><li><p>vue2和vue3响应时原理对比的补充：<a href="https://juejin.cn/post/7001999813344493581">https://juejin.cn/post/7001999813344493581</a></p></li><li><ul><li><strong>模拟Vue3中实现响应式</strong>：（不完整，看下面的<strong>reflect</strong>。）</li></ul></li></ul><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return target[pcropName];        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        target[propName] = value;        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真实结果给他返回：        return delete target[propName]       &#125;&#125;)</code></pre><p>绿色框在真正修改源数据：</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810035353361-16600748348953.png" alt="image-20220810035353361"></p><h4 id="4-2-2-响应式中Reflect的应用："><a href="#4-2-2-响应式中Reflect的应用：" class="headerlink" title="4.2.2. 响应式中Reflect的应用："></a>4.2.2. 响应式中Reflect的应用：</h4><ul><li><strong>ES6</strong>，<strong>Windows内置</strong>。</li><li>增删改查<strong>用法</strong>：reflect.get、reflect.set、 reflect.delete。</li><li>reflect里也有defineProperty方法，且有返回值（若不返回的话就不知道是否操作成功，因为它不报错。返回值是布尔值）。</li></ul><p><strong>与Object.definProperty<strong><strong>对比</strong></strong>：</strong></p><ul><li><p><strong>在做封装的时候，Object.definProperty捕获错误只能通过try catch。若使用reflect就可以避免。</strong><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=147&amp;t=672.1</a></p></li><li><p> <strong>模拟Vue3中实现响应式</strong>（使用<strong>reflect</strong>改进后）：</p></li><li><ul><li><p>用到了proxy代理对象，及reflect反射对象。</p><pre><code>        // 模拟Vue3中实现响应式：        const p = new Proxy(person,  &#123;    // 读取某个属性时调用此方法：接收两个参数：源对象&amp;当前属性名    get(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被读取~`);        return Reflect.get(target, propName);        &#125;,    // 修改/增加某个属性时调用此方法：接收两个参数：比get多收到一个value值。    set(target, propName, value) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        Reflect.set(target, propName, value);        &#125;,    // 删除某个属性时调用此方法：    deleteProperty(target, propName) &#123;        console.log(`$&#123;propName&#125;属性被修改，准备更新界面`);        // delete target[propName]  最好是把真是结果给他返回：        return Reflect.deleteProperty(target, propName);     &#125;&#125;)</code></pre></li></ul></li></ul><hr><p><strong>toRef</strong></p><ul><li>toRef可以创建一个ref，其的value值可以指向令一个对象的属性。</li></ul><p><strong>举例</strong>：</p><pre><code>const obj = &#123;    a: 10,    b: &#39;start&#39;&#125;const obj2 = toRef(obj)return &#123;    obj,    // 返回的格式：    ...toRef(obj)&#125;</code></pre><p><strong>toRefs</strong></p><p>指向多个</p><p><strong>toRefs</strong></p><p>指向多个属性</p>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3生命周期的变更</title>
      <link href="posts/2606f5b3/"/>
      <url>posts/2606f5b3/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p>销毁的概念改为<strong>卸载</strong>（unmounted），更名：</p></li><li><ul><li>beforeDestroy改名为beforeUnmounted。</li><li>destroyed改名为unmounted。</li></ul></li><li><p>vue2中的两次判断改为一次。</p></li></ul><p>​    <img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810030613459.png" alt="image-20220810030613459"></p><ul><li><p>Vue3提供的<strong>Composition API</strong>形式对比：</p></li><li><ul><li>beforeCreate     =&gt;     <strong>setup()</strong></li><li>created     =&gt;     <strong>setup()</strong></li><li>beforeMount     =&gt;     <strong>onBeforeMount</strong></li><li>mounted         =&gt;     <strong>onMounted</strong></li><li>beforeUpdate      =&gt;     <strong>onBeforeUpdate</strong></li><li>updated         =&gt;     <strong>onUpdated</strong></li><li>beforeUnmounted     =&gt;     <strong>onBeforeUnmounted</strong></li><li>unmounted     =&gt;     <strong>OnUnmounted</strong></li></ul></li><li><p>组合式API的vue2生命钩子的<strong>优先级：</strong></p></li><li><ul><li><p>下图打印结果可以看到：setup中的组合式API优先级更高。</p><p><img src="C:\Users\失频本人\Desktop\blog修改历史\blog\source_posts\image-20220810034139355-16600741018631.png" alt="image-20220810034139355"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小总结</title>
      <link href="posts/ac58b7ea/"/>
      <url>posts/ac58b7ea/</url>
      
        <content type="html"><![CDATA[<h2 id="1-函数："><a href="#1-函数：" class="headerlink" title="1. 函数："></a><strong>1. 函数：</strong></h2><ul><li>在实际开发中，经常会使用一个变量来接收函数返回的结果。</li><li>return 有终止函数的作用，return后的语句不会被执行。</li><li>return只能返回一个值。（有多个时返回最后一个）</li><li>所以当要return返回多个时，可以使用数组：</li></ul><p>return [num1+num2,num1*num2]</p><ul><li><p>函数都有返回值。若有，则返回return后的值；若没有，则返回undefined。</p></li><li><ul><li><strong>arguments的使用：</strong> ( 注意：只有函数才有arguments)</li><li>当不确定有多少个参数传递的时候，可以用arguments来获取。在JS中，arguments实际上是当前函数的一个内置对象。<strong>所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</strong></li></ul></li><li><p>arguments的展示形式是一个伪数组，因此可以进行遍历。</p></li><li><p>伪数组的特点：     （伪数组并不是真正意义上的数组）</p></li><li><ul><li>具有length属性；</li><li>按索引方式存储数据；</li><li>不具有数组的push，pop等方法。</li></ul></li><li><p>代码从上往下执行。当执行到调用某函数时，会去找执行部分的代码，如下面的 函数中调用另一个函数：</p></li></ul><pre><code>function fn1() &#123;    console.log(111)         /* 第1个执行 */    fn2()    console.log(&#39;fn1&#39;)       /* 第4个执行 */  &#125;  function fn2() &#123;    console.log(222)         /* 第2个执行 */    console.log(&#39;fn2&#39;)       /* 第3个执行 */  &#125;  fn1();                     /* 先找到这里 */   // 执行顺序： // 从上往下，fn1和fn2的代码块都未调用，所以这两个代码块都先不管。 // 所以1.先走到fn1(); =&gt;找到fn1代码块=&gt;执行并输出111。 // 2.又走到fn2()=&gt;所以去找fn2代码块=&gt;执行并输出222，fn2。 // 3.回去接着执行并输出fn1。</code></pre><h2 id="2-JS作用域："><a href="#2-JS作用域：" class="headerlink" title="2. JS作用域："></a><strong>2. JS作用域：</strong></h2><ul><li><p>就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突。</p></li><li><p>在ES6之前：全局作用域，局部作用域（也叫函数作用域）。两者就算名字一样也互不影响。</p></li><li><p>注意：函数的形参也可以看作局部变量。</p></li><li><p>从执行效率来说，</p></li><li><ul><li>全局变量：只有在浏览亲关闭的时候才会销毁。比较占内存资源。</li><li>局部变量：当程序执行完之后就会销毁。比较节约内存资源。</li></ul></li><li><p>块级作用域：ES6新增的，原本JS中没有块级作用域。</p></li><li><p><strong>作用域链：</strong>     （<strong>就近原则</strong>）</p></li><li><ul><li>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值。这种结构就叫作用域链。</li></ul></li></ul><h2 id="3-JS预解析："><a href="#3-JS预解析：" class="headerlink" title="3. JS预解析："></a><strong>3. JS预解析：</strong></h2><ul><li><p>JS引擎运行JS分为两步：预解析、代码执行。</p></li><li><p>预解析：JS引擎会把JS里所有的var和function提升到当前作用域的最前面。</p></li><li><ul><li>变量预解析（变量提升）：就是把所有的变量声明提升到<strong>当前</strong>作用域的最前面，<strong>不提升赋值操作</strong>。</li><li>函数预解析（函数提升）：就是把所有函数声明提升到当前作用域的最前面，不调用函数。<strong>只有函数声明形式才有函数提升。</strong></li><li><strong>函数提升优先级高于变量提升。</strong></li></ul></li></ul><pre><code>// 1.下面的输出结果是什么：  console.log(num);  var num = 10;  // 其实相当于下面的代码：  var num;  console.log(num);                   /* 所以undefined */  num = 10;</code></pre><pre><code> // 2.下面的输出结果是什么：  fun();  var fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)  &#125;  // 其实相当于下面的代码：  var fun;  fun();  fun = function() &#123;               /* 函数表达式声明的是变量名不是函数名 */    console.log(22)                 /* 所以报错 */  &#125;</code></pre><pre><code>// 3.为什么调用写在最前面也可以：  fn();  function fn() &#123;    console.log(11);         /* 因为函数提升，把函数声明提升到当前作用域的最前面。 */  &#125;// 例子1 ：  var num= 10  fun();  function fun() &#123;    console.log(num);    var num = 20;  &#125;  // 相当于执行下面的代码：  var num;                         /* 外层的变量提升 */  function fun() &#123;                 /* 外层的函数提升 */    var num;                       /* 里层的变量提升 */    console.log(num);               /* undefined，因为就近原则 */    num = 20;  &#125;  num = 10;  fun();</code></pre><pre><code>// 例子2 ：  var num = 10;  function fn() &#123;    console.log(num);    var num = 20;    console.log(num);  &#125;  fn();​  // 相当于执行下面的代码：  var num;  function fn() &#123;    var num;    console.log(num);                   /* undefined，就近原则 */    num = 20;    console.log(num);                   /* 20 */  &#125;  num = 10;  fn();</code></pre><pre><code>// 例子3 ：  var a = 18;  f1();  function f1() &#123;    var b = 9;    console.log(a);    console.log(b);    var a = &#39;123&#39;;  &#125;  // 相当于执行下面的代码：  var a;  function f1() &#123;    var b;    b = 9;    var a;    console.log(a);                     /* undefined */    console.log(b);                     /* 9 */    a = &#39;123&#39;;  &#125;  a = 18;  f1();</code></pre><pre><code>// 例子4 ：     这道题需要注意  f1();  console.log(c);  console.log(b);  console.log(a);  function f1() &#123;    // 这句相当于var a =9； b = 9；c = 9; 而不是var a;var b;var c;    // 所以b、c并没有声明!!! 要当全局看    var a = b = c = 9;                  console.log(a);    console.log(b);    console.log(c);  &#125;  // 相当于执行下面的代码：  function f1() &#123;    var a;      a = b = c = 9;      // var b;     不是这样，写错了。。。    // var c;    // a = 9;    // b = 9;    // c = 9;    var a;    console.log(a);                   /* 9 */    console.log(b);                   /* 9 */    console.log(c);                   /* 9 */  &#125;  f1();  console.log(c);                     /* 9 */  console.log(b);                     /* 9 */  console.log(a);                     /* undefined,局部变量 */</code></pre><ul><li>代码执行：按照代码顺序从上往下执行。</li></ul><h2 id="对象："><a href="#对象：" class="headerlink" title="对象："></a><strong>对象：</strong></h2><ul><li><p>在JS中，对象是一组无序的相关属性和方法的集合，所有事物都是对象，如数组、字符串、函数、数值。</p></li><li><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的。</p></li><li><p>属性：是事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示。（常用名词）</p></li><li><p>方法：是事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示。（常用动词）</p></li><li><p>为什么需要对象：</p></li><li><ul><li>保存一个值时，可以使用变量，保存多个值时，可以使用数组，如果要保存一个人的完整信息嘞~    </li></ul></li><li><p>现阶段可以用三种方式创建对象：</p></li><li><ul><li>字面量创建；</li><li>new Object创建对象；</li><li>利用构造函数创建对象。</li></ul></li></ul><h2 id="类class："><a href="#类class：" class="headerlink" title="类class："></a><strong>类class：</strong></h2><ul><li>在ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。</li><li><strong>类</strong>抽象了对象的公共部分，它泛指某一大类(class)。</li><li><strong>对象</strong>特指某一个，通过类实例化一个具体的对象。</li></ul><h3 id="1-创建类："><a href="#1-创建类：" class="headerlink" title="1.创建类："></a><strong>1.创建类：</strong></h3><p>语法：</p><pre><code>class name &#123;    //class body&#125;</code></pre><p>创建实例：</p><pre><code>var xx =  new name();</code></pre><p>注意：类必须使用new实例化对象。</p><h3 id="2-类-constructor-构造函数"><a href="#2-类-constructor-构造函数" class="headerlink" title="2.类 constructor 构造函数"></a><strong>2.类 constructor 构造函数</strong></h3><ul><li><strong>constructor()</strong> 方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显式定义，类的内部会自动创建一个constructor()。</li><li>有了它就不用return。</li></ul><p>例：</p><pre><code>// 1.创建类class，创建一个Star类。class name &#123;    constructor(uname) &#123;        // this指向创建的实例：        this.uname = uname;      /* 将uname指向创建的实例，这样就接收了这个参数 */        this.age = age;    &#125;    sing(song) &#123;        console.log(&#39;略略略&#39;);        console.log(this.name + song);    &#125;&#125;// 2.利用类创建对象 newvar zs = new Star(&#39;张三&#39;,18);   /* 只要加了new，就自动调用constructor。 */var ls = new Star(&#39;李四&#39;,20); console.log(zs);           /* 输出张三 */console.log(ls);zs.sing(&#39;lost river&#39;);zs.sing(&#39;///////&#39;);</code></pre><p><strong>注意点：</strong></p><ol><li>通过class关键字创建类，类名要大写。</li><li>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象。</li><li>constructor函数只要new生成实例时，就会自动调用这个函数，如果不写这个函数，类也会自动生成这个函数。</li><li>生成实例，new不能省略。</li><li>最后注意语法规范，<strong>创建类</strong>，类名后面不要加小括号，<strong>生成实例</strong>，类名后面要加小括号，构造函数不需要加function。</li></ol><p>另外：</p><ul><li>类里面所有的函数都不用写function来声明。</li><li>类里面，所有函数/方法之间不能加逗号分割。</li><li></li></ul><h3 id="3-类的继承："><a href="#3-类的继承：" class="headerlink" title="3. 类的继承："></a><strong>3. 类的继承：</strong></h3><p>下次更新写。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础回顾 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/3eeb/"/>
      <url>posts/3eeb/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Gitee搭建博客踩坑总结</title>
      <link href="posts/hexo-gitee/"/>
      <url>posts/hexo-gitee/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建过程如下："><a href="#一、搭建过程如下：" class="headerlink" title="一、搭建过程如下："></a>一、搭建过程如下：</h2><h3 id="阶段1：-本地搭建"><a href="#阶段1：-本地搭建" class="headerlink" title="阶段1： 本地搭建"></a>阶段1： 本地搭建</h3><p>1.下载安装node.js </p><p>2.下载安装git </p><p>3.使用命令行(win+r,输入cmd)下载淘宝镜像：    </p><pre><code>npm install -g cnpm --registry=https://.npm.taobao.org</code></pre><p>4.使用命令行下载hexo :    （git bash和cmd都可以）</p><pre><code>npm install -g hexo-cli</code></pre><p>5.建立空文件夹 ：</p><pre><code>md blog</code></pre><p>6.进入建好的文件夹：</p><pre><code>cd blog </code></pre><p>7.启动服务：</p><pre><code>hexo s</code></pre><p>8.停一下：ctrl c再按y </p><p>9.新建文章： hexo n “标题” </p><p>10.看这时在哪个目录下，然后cd进入 </p><p>11.确认新建的文章是否成功：dir </p><p>12.给博文加内容：这里我用typora写。用vim的方法是：vim 标题.md。然后保存退出：先按esc，再输入    wq(w保存，q退出)。 </p><p>13.文件退两层： cd../.. (到了blog目录) </p><p>14.win下写博文从文件夹用typora打开文章，然后保存刷新页面，不用重新启动hexo。 </p><p>15.清理 :</p><pre><code>hexo clean </code></pre><p>16.生成:</p><pre><code>hexo g </code></pre><h3 id="阶段2：部署到Gitee"><a href="#阶段2：部署到Gitee" class="headerlink" title="阶段2：部署到Gitee"></a>阶段2：部署到Gitee</h3><p>1.装一个git的部署插件cnpm install –save hexo-deployer-git(win用npm install) </p><p>2.注册登录Gitee账号，新建仓库，设置仓库名（一定要和用户名一样，否则可能会有无法预料结果）。</p><p>3.设置根目录的_config.yml文件，用typore打开，拉到最底下设置deploy的值：</p><pre><code>deploy:  type: git  repo: 你的仓库地址（去Gitee复制）  branch: master</code></pre><p>注意冒号和值之间一定要有空格，type后面有单引号的话可以直接删了。</p><p>4.这样就随时可以用电脑/手机访问了，地址可以直接复制仓库名访问。接下来就是换主题和自定义主题为满意的样式，我用的是Matery，网上有很多，Hexo官网也有。</p><h2 id="二、需要注意的地方："><a href="#二、需要注意的地方：" class="headerlink" title="二、需要注意的地方："></a>二、需要注意的地方：</h2><p>1.主题名别忘了在_config.ym中更改，这种配置文件一定要严格按照格式！否则一言不合就报错！</p><p>2.下载的主题在解压缩后不要更改</p><p>3.注意有没有漏下的插件，检查所有插件及版本号的指令：</p><pre><code>npm list</code></pre><p>4.卸载某个插件的指令：</p><pre><code>npm uninstall 插件名@版本号</code></pre><p>5.怕出错想找回改动前的文件：可以提前复制粘贴一份在桌面，方便随时对照/改动。</p><p>6.Typora可以选择是否显示目录，设置toc: true，如果某篇文章不显示目录了，可以查看文章最上方的设置是否正确。</p><h2 id="三、踩坑-amp-解决："><a href="#三、踩坑-amp-解决：" class="headerlink" title="三、踩坑&amp;解决："></a>三、踩坑&amp;解决：</h2><p>1.报错：FATAL err:[Error: EBUSY: resource busy or locked, rmdir ‘C:\User...]</p><p>网上搜索了一下，关闭软件重启电脑，果然有奇效。</p><p>2.我的页面刚开始一直404，我百思不得其解，大佬们的各路招数试了个遍，然而它的纹丝不动仿佛在告诉我不要浪费时间。</p><p>最后！我在Gitee Page页面看到了一个更新的按钮，我一脸疑惑的点了一下。接着，大不一样，顿时体会到柳暗花明又一村天无绝人之路。没错，我想了一下，大概是因为我的git一键部署功能出错了。总之，现在是记了，    每次终端部署完之后，在这个页面再点更新就好了。</p><p>3.我发现我的主题，在设置成功之后无法在网站中更新，在尝试了很多方法之后，我发现把根目录的config yml文件的repo由SSH的地址变换为HTTPS的位置，这样就可以成功解决，不过还有一个问题就是这样的话，每次重新部署都要输入用户名和密码。</p><p>然后我就尝试在网上搜集一些办法，但是没有什么用。这时我就想，如果我把repo. 再换成SSH的地址。这样换了之后我看会有什么变化变化，结果发现。重新部署之后是可以的，页面刷新也没有完全问题。</p><p>4.我在所选的主题下找到了read me，开始按照里面的提示来配置我的主题文件夹。其中有一个是配置评论的表情的。我在配置过后发现你发现在本地运行的时候都会报错，后来在网上查找，提示说检查Jason文件格式，一般情况下，他都是一对花括号是首尾。后来我把最上面那行Json删了也把最外层的中括号删了。结果发现依旧报    错，接着我又尝试把中括号加上，运行一下再也没有红色字段，就Json这四个字母导致了运行报错。</p><p>​    5.修改根目录配置文件时，注意缩进，有报错的情况！</p><p>​    6.卸载了<a href="mailto:&#x68;&#105;&#x67;&#104;&#x6c;&#105;&#103;&#x68;&#116;&#x2e;&#x6a;&#115;&#x40;&#49;&#x30;&#46;&#x37;&#x2e;&#49;">&#x68;&#105;&#x67;&#104;&#x6c;&#105;&#103;&#x68;&#116;&#x2e;&#x6a;&#115;&#x40;&#49;&#x30;&#46;&#x37;&#x2e;&#49;</a>：npm uninstall <a href="mailto:&#104;&#x65;&#x78;&#x6f;&#x2d;&#x71;&#x69;&#x6e;&#x69;&#117;&#45;&#x73;&#121;&#110;&#99;&#x40;&#x31;&#x2e;&#52;&#x2e;&#x37;">&#104;&#x65;&#x78;&#x6f;&#x2d;&#x71;&#x69;&#x6e;&#x69;&#117;&#45;&#x73;&#121;&#110;&#99;&#x40;&#x31;&#x2e;&#52;&#x2e;&#x37;</a> （相关的配置我暂时未删，试了一下已    经好了）</p><p>​    7.设置文章永久链接，下载指令：</p><pre><code>npm install hexo-abbrlink --save</code></pre><p>​    设置修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）:</p><pre><code>#设置永久链接permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlinkabbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: dec     #进制： dec(default) and hex</code></pre><p>​    8.npm resource busy or locked报错解决：</p><pre><code>npm cache verify</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位机制</title>
      <link href="posts/5d7648ee/"/>
      <url>posts/5d7648ee/</url>
      
        <content type="html"><![CDATA[<h2 id="一-文档流flow"><a href="#一-文档流flow" class="headerlink" title="一.文档流flow"></a>一.文档流flow</h2><ul><li><p>从上到下，从左到右。</p></li><li><h3 id="1-block元素："><a href="#1-block元素：" class="headerlink" title="1.block元素："></a>1.block元素：</h3><ul><li><p>元素独占一行；</p></li><li><p>元素的height、width、margin、padding都可以设置。</p></li><li><p>常见的block元素：div、p、h1~h6、ol、ul、table、form</p></li><li><p>将元素显示为block元素：<strong>display:block;</strong></p><p>例：</p></li></ul><pre><code>a&#123;    display:block;&#125;</code></pre><p>inline元素a转为block，从而使a元素具有块状元素的特点。</p></li><li><h3 id="2-inline元素："><a href="#2-inline元素：" class="headerlink" title="2.inline元素："></a>2.inline元素：</h3><ul><li>不用单独占用一行；</li><li>height、width不可设置；</li><li>width就是它已包含的文字或图片的宽度，不可改变。</li><li>常见inline元素：span、a</li><li>将元素显示为inline元素：<strong>display:inline;</strong></li><li>inline元素之间有个间距的问题，解决方法：转换为block。</li></ul></li><li><h3 id="3-inline-block元素："><a href="#3-inline-block元素：" class="headerlink" title="3.inline-block元素："></a>3.inline-block元素：</h3><ul><li>同时具备inline和block的特点：可平行的block；</li><li>不单独占用一行；</li><li>元素的height、width、margin、padding都可以设置；</li><li>常见的inline-block元素：img</li><li>显示为inline-block元素：<strong>display:inline-block；</strong></li></ul></li><li><h3 id="4-相互转换："><a href="#4-相互转换：" class="headerlink" title="4.相互转换："></a>4.相互转换：</h3><ul><li>display:none;                 元素不会被显示（<strong>不占原位置</strong>）</li><li>display:block                  显示为block元素</li><li>display:inline                  显示为inline元素</li><li>display:inline-block        显示为inline-block元素</li></ul></li></ul><h2 id="二-浮动定位float"><a href="#二-浮动定位float" class="headerlink" title="二.浮动定位float"></a>二.浮动定位float</h2><ul><li><p>float属性：left、right、none（不浮动）；</p></li><li><p>clear属性（清除）：left、right、both。</p></br></li></ul><p>*<em>当有3列都要水平时，将3列都设为左浮动即可。（宽度够用时）</em></p><h3 id="float属性的特点："><a href="#float属性的特点：" class="headerlink" title="float属性的特点："></a>float属性的特点：</h3><ul><li><p>当其中一个盒子移动时，<strong>其原有位置丢失，并被其他元素占用位置。</strong></p></br></li></ul><p>*<em>3个盒子并行，当高度不够时：</em></p><ul><li>第一种情况：box3下降</li><li>第二种情况：box1较高，box3向左下降时被卡住。</li></ul><h3 id="clear属性："><a href="#clear属性：" class="headerlink" title="clear属性："></a>clear属性：</h3><ul><li><p>单方向清除浮动的发法：比如将一行的box1和box2变为上下的列关系</p><ul><li><p>使box1位置不变，将box2设为：</p></li><li><pre><code>clear:right; </code></pre><p>  意思是清除右侧浮动，使其占据右侧。</p></br></li></ul></li><li><p>双侧清除：</p><pre><code>clear:right;</code></pre><p>意思是清楚两侧的浮动，使设置的元素单独占一行。</p></li></ul><h2 id="三-层定位layer"><a href="#三-层定位layer" class="headerlink" title="三.层定位layer"></a>三.层定位layer</h2><h3 id="position属性：（相对于谁定位）"><a href="#position属性：（相对于谁定位）" class="headerlink" title="position属性：（相对于谁定位）"></a>position属性：（相对于谁定位）</h3><ul><li><p>static：      默认值（没有定位，相当于不是层定位，定位的属性失效）</p></li><li><p>fixed：      固定定位（相对于浏览器窗口定位）</p></li><li><p>relative： 相对定位（相对于原来自己的位置定位），元素会脱离文档流，但在文档流中的<strong>位置还在，不会被占据。</strong></p></li><li><p>absolute：绝对定位（相对于static以外的第一个父元素定位），元素脱离文档流，在文档流中的<strong>原位置不再存在，会被占据</strong>。</p></br></li></ul><p>概述：像图像软件中的图层一样可以对每个layer进行精准定位操作。</p></br><p><em>当子元素相对于父元素定位，且父元素也相对于其父元素定位。可将最外层用相对定位，<strong>里面两层用绝对定位。</strong></em></p></br><p>*<em>特殊情况;：</em></p><p><em>对于absolute定位的层，若其父层都未定义absolute或relative，则将会<strong>相对body进行定位</strong>。</em></p></br><p><strong>relative+absolute：</strong>（父相子绝）</p><ul><li>父元素box1：position: relative;</li><li>子元素box2：position: absolute;</li><li>子元素box2：left、right、top、bottom相对于父元素进行偏移定位。</li></ul><p><strong>好处</strong>：当父元素box1移动时，子元素会相对于父元素的位置进行定位，可以一起移动。</p><h3 id="定位的属性："><a href="#定位的属性：" class="headerlink" title="定位的属性："></a>定位的属性：</h3><ul><li>left属性</li><li>right属性</li><li>top属性</li><li>bottom属性</li><li>z-index属性  （值大在上面）</li></ul><p>*<em>当想把图片设为背景，可将z-index设为负数，以留在最底层。</em></p></br></br>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS添加方法&amp;优先级&amp;CSS选择器</title>
      <link href="posts/6a1f6cdf/"/>
      <url>posts/6a1f6cdf/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS添加方法："><a href="#一、CSS添加方法：" class="headerlink" title="一、CSS添加方法："></a>一、CSS添加方法：</h2><h3 id="1-行内样式："><a href="#1-行内样式：" class="headerlink" title="1.行内样式："></a>1.行内样式：</h3><p>表示当前样式作为CSS样式被添加到标签上（只对这个标签起作用）。</p><h3 id="2-内嵌样式："><a href="#2-内嵌样式：" class="headerlink" title="2.内嵌样式："></a>2.内嵌样式：</h3><p>将CSS代码内嵌到当前页面的head标签部分（只对当前页面起作用）。</p><p>首先body部分不再包含样式，将样式放在style标签中表示，和head标签为嵌套关系。</p><h3 id="3-链接样式（单独文件）："><a href="#3-链接样式（单独文件）：" class="headerlink" title="3.链接样式（单独文件）："></a>3.链接样式（单独文件）：</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;</code></pre><p>stylesheet为样式表文件；</p><p>href后面的是相对路径。</p><h2 id="二、样式优先级："><a href="#二、样式优先级：" class="headerlink" title="二、样式优先级："></a>二、样式优先级：</h2><ul><li><input disabled="" type="checkbox"> 多重样式可重叠，可覆盖。</li><li><input disabled="" type="checkbox"> 样式的优先级按”就近原则“。</li><li><input disabled="" type="checkbox"> 行内样式&gt;内嵌样式&gt;链接样式&gt;浏览器默认样式</li></ul><h2 id="三、CSS选择器："><a href="#三、CSS选择器：" class="headerlink" title="三、CSS选择器："></a>三、CSS选择器：</h2><h3 id="1-标签选择器："><a href="#1-标签选择器：" class="headerlink" title="1.标签选择器："></a>1.标签选择器：</h3><p>与标签同名，紧跟着一对花括号，例如：</p><pre><code>body&#123;    border-color: #aaaaff;&#125;</code></pre><h3 id="2-类选择器："><a href="#2-类选择器：" class="headerlink" title="2.类选择器："></a>2.类选择器：</h3><p>以.开头，例:</p><pre><code>.one&#123;    font-size:18px;&#125;</code></pre><h3 id="3-ID选择器："><a href="#3-ID选择器：" class="headerlink" title="3.ID选择器："></a>3.ID选择器：</h3><p>以#开头，例:</p><pre><code>#two&#123;    font-size:18px;&#125;</code></pre><p>2和3的区别：</p><ul><li><input disabled="" type="checkbox"> ID是唯一的，只能在HTML被引用一次。</li><li><input disabled="" type="checkbox"> 类选择器可以被多次引用，应用中多个页面元素上。</li><li><input disabled="" type="checkbox"> *因此：ID选择器用来布局，class选择器用在样式。</li></ul><h3 id="4-后代选择器："><a href="#4-后代选择器：" class="headerlink" title="4.后代选择器："></a>4.后代选择器：</h3><pre><code>p span&#123;    clor:red;            //作用于p标签内部的span标签&#125;</code></pre><p>两个标签之间使用空格空开。</p><h3 id="5-并集选择器："><a href="#5-并集选择器：" class="headerlink" title="5.并集选择器："></a>5.并集选择器：</h3><pre><code>p,span&#123;    clor:red;            //同时作用于两个标签&#125;</code></pre><p>连接符为,会使两者都变为红色。</p><h3 id="6-伪类选择器-Pseudo-classes-："><a href="#6-伪类选择器-Pseudo-classes-：" class="headerlink" title="6.伪类选择器(Pseudo-classes)："></a>6.伪类选择器(Pseudo-classes)：</h3><p>语法：</p><pre><code>selector:pseudo-class &#123;property:value;&#125;</code></pre><p>例如：</p><pre><code>a:link            //普通的，未被访问的链接a:visited         //用户已经访问过的链接a:hover         //鼠标悬停于链接上的样式a:active         //链接被点击时的样式</code></pre><p>​    注意：必须严格遵守以下顺序。</p><p>a:hover            <strong>必须在a:link和a:visited之后</strong></p><p>a:active             <strong>必须在a:hover之后</strong></p><p><strong>口诀：</strong></p><p><strong>l</strong>o<strong>v</strong>e&amp;<strong>ha</strong>te</p><h3 id="7-混合："><a href="#7-混合：" class="headerlink" title="7.混合："></a>7.混合：</h3><ul><li>多个class选择器混用，用空格分开。</li></ul><pre><code>&lt;div class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id和class混用：</li></ul><pre><code>&lt;div id=&quot;my&quot; class=&quot;one yellow left&quot;&gt;&lt;/div&gt;</code></pre><ul><li>id选择器不可以多个同时使用。</li></ul></br></br></br>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 基础回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像格式和路径</title>
      <link href="posts/66ad3928/"/>
      <url>posts/66ad3928/</url>
      
        <content type="html"><![CDATA[</br><h2 id="一、图像格式："><a href="#一、图像格式：" class="headerlink" title="一、图像格式："></a>一、图像格式：</h2></br><p>JPG：有损压缩，图片色彩丰富。（快，不失真）</p><p>GIF：简单动画，背景透明。</p><p>PNG：无损压缩，透明，交错，动画（支持有/无损，比GIF色彩丰富）。</p></br><p>透明：可以给定图片一种颜色，使其不被显示而成为透明。</p><p>交错：在显示图片的过程中可以从概貌逐渐变化为全貌，看上去也就是清晰度从低到高。</p><h2 id="二、插入图片img："><a href="#二、插入图片img：" class="headerlink" title="二、插入图片img："></a>二、插入图片img：</h2></br><p>src属性：组成为 路径+文件名（不仅要带有图片的名字及后缀，还要有图片的完整路径）</p><p>alt属性：当图片没有被找到时，显示的替代文本。</p></br><h2 id="三、绝对路径-amp-相对路径："><a href="#三、绝对路径-amp-相对路径：" class="headerlink" title="三、绝对路径&amp;相对路径："></a>三、绝对路径&amp;相对路径：</h2></br><p>绝对路径：以根目录为基准。</p><p>相对路径：以该文件所在位置为基准。</p><ul><li><input disabled="" type="checkbox"> ..表示上一级</li><li><input disabled="" type="checkbox"> /表示下一级</li></ul></br></br></br></br></br>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础回顾 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
